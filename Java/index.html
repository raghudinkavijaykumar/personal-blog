<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.30.3"/><style data-styled="" data-styled-version="5.2.1">.lbxEjx{width:800px;margin:0 auto;}/*!sc*/
data-styled.g1[id="Layout__AppStyles-sc-1q9f5ll-0"]{content:"lbxEjx,"}/*!sc*/
</style><link as="script" rel="preload" href="/personal-blog/webpack-runtime-e97e5792841cfd3b9064.js"/><link as="script" rel="preload" href="/personal-blog/framework-078d6d248b03e80a6d05.js"/><link as="script" rel="preload" href="/personal-blog/app-7f3ebe45394a9b8abff6.js"/><link as="script" rel="preload" href="/personal-blog/commons-a0cdf84f460a5805ce1d.js"/><link as="script" rel="preload" href="/personal-blog/component---src-templates-blog-post-template-js-67eb11ed87f6378502cd.js"/><link as="fetch" rel="preload" href="/personal-blog/page-data\Java\page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/personal-blog/page-data/sq/d/4080856488.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/personal-blog/page-data\app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><main class="Layout__AppStyles-sc-1q9f5ll-0 lbxEjx"><a href="/personal-blog/"><h1>The Study Blog</h1><p>This is personal study blog</p></a><h1>Java</h1><p>2021 January 17th</p><p>Java</p><p>Important Links</p><p><a href="https://docs.oracle.com/javase/specs/index.html">Java Language and Virtual Machine Specifications</a></p><p>[toc]</p><h1>The Java Platform</h1><p>A <em>platform</em> is the hardware or software environment in which a program runs. The Java platform differs from most other platforms in that it&#x27;s a software-only platform that runs on top of other hardware-based platforms, Windows, Linux <!-- -->.<!-- -->...</p><p>The Java platform has two components:</p><ul><li>The <em>Java Virtual Machine</em></li><li>The <em>Java Application Programming Interface</em> (API)</li></ul><p>Java Virtual Machine; it&#x27;s the base for the Java platform and is ported onto various hardware-based platforms.</p><p>The API is a large collection of ready-made software components that provide many useful capabilities.</p><p>The API and Java Virtual Machine <strong>insulate the program from the underlying hardware</strong>.</p><p>As a platform-independent environment, the Java platform can be a bit slower than native code. However, advances in compiler and virtual machine technologies are bringing performance close to that of native code without threatening portability.</p><h1>Object-Oriented Programming Concepts</h1><h2>What Is an Object?</h2><p>Object consists of <strong>state and related behavior</strong>. An object stores its <strong>state in <em>fields</em></strong> and exposes its <strong>behavior through <em>methods</em></strong>. Methods operate on an object&#x27;s internal state and serve as the primary mechanism for object-to-object communication. <strong>Hiding internal state and requiring all interaction to be performed through an object&#x27;s methods is known as <em>data encapsulation</em></strong> </p><p>Bundling code into individual software objects provides a number of benefits, including:</p><ul><li><strong>Modularity</strong>: The source code for an object can be <strong>written and maintained independently</strong> of the source code for other objects. Once created, an object can be easily passed around inside the system.</li><li><strong>Information-hiding</strong>: By interacting only with an object&#x27;s methods, the <strong>details of its internal implementation remain hidden</strong> from the outside world.</li><li><strong>Code reuse</strong>: If an object already exists (perhaps written by another software developer), you can use that object in your program. This allows specialists to implement/test/debug complex, task-specific objects, which you can then trust to run in your own code.</li><li><strong>Pluggability and debugging ease</strong>: If a particular object turns out to be problematic, you can simply remove it from your application and plug in a different object as its replacement.</li></ul><h2>What Is a Class?</h2><p><strong>A <em>class</em> is the blueprint from which individual objects are created</strong>.</p><pre><code class="language-java"> class NewClass {
     //Constructor or default                                             
     //Fields and Methods(based on its behaviour)                         
 }       
</code></pre><p>You may have noticed that the NewClass<strong> class does not contain a main method</strong>. That&#x27;s because it&#x27;s not a complete application; Here&#x27;s a AppClass class that creates objects of new class and performs some operations.</p><pre><code class="language-java">class AppClass {
    public static void main(String[] args) {
        NewClass newClass = new NewClass();
        // Perform operations on newClass
    }
}
</code></pre><h2>What Is Inheritance?</h2><p>OOPs allows classes to <em>inherit</em> commonly used state and behavior from other classes. In the Java programming language, <strong>each class is allowed to have one direct superclass</strong>, and each superclass has the potential for an unlimited number of <em>subclasses</em>:</p><p><strong>Syntax</strong>: At the beginning of your class declaration, use the <strong>extends</strong> keyword, followed by the name of the class to inherit from:</p><p><strong>class</strong> NewExtendedClass <strong>extends</strong> NewClass { </p><p>// new fields and methods defining the NewExtendedClass apart from the existing functionalities already present by extending.  </p><p>}  </p><p><strong>You must take care to properly document the state and behavior that each superclass defines, since that code will not appear in the source file of each subclass.</strong></p><h2>What Is an Interface?</h2><p>An interface is a group of related methods with empty bodies.Its a logical grouping of necessary functions that needs to be implemented by a class. Implementing an interface allows a class to become more formal about the behavior it promises to provide. <strong>Interfaces form a contract between the class and the outside world, and this contract is enforced at build time by the compiler</strong>. If your class claims to implement an interface, all methods defined by that interface must appear in its source code before the class will successfully compile.</p><pre><code class="language-java">// Methods based on its requirement.
void method1();
void method2(arguments..);
}
class  NewExtendedClass  extends  NewClass implements Interface  { 
    // new fields and methods defining the NewExtendedClass apart from the existing functionalities already present by extending.  
    void method1() { /* Implementation goes here */ }
    void method2(arguments..) { /* Implementation goes here */ }
}  
</code></pre><h2>What Is a Package?</h2><p>A package is a namespace that organizes a set of related classes and interfaces. The <a href="https://docs.oracle.com/javase/8/docs/api/index.html">Java Platform API Specification</a> contains the complete listing for all packages, interfaces, classes, fields, and methods supplied by the Java SE platform.</p><h1>3 Language Basics</h1><h2>3.1 Variables</h2><p>The Java programming language defines the following kinds of variables:</p><ul><li><strong>Instance Variables (Non-Static Fields)</strong> : used to store the states of an object.</li><li><strong>Class Variables (Static Fields)</strong>: Used to store a common state across all objects, exactly one copy exists.</li><li><strong>Local Variables</strong>: A local state store usually used in methods that are necessary to store transient states and have no meaningful usage as an instance variable.</li><li><strong>Parameters:</strong> Values accepted by methods required in computation.</li></ul><h3>3.1.1 Declaring a Variable</h3><p>In Java, all variables must be declared before they can be used. The basic form of a variable declaration is shown here:</p><p><strong>type identifier <!-- -->[ = value ]<!-- -->, identifier <!-- -->[= value ]<!-- --> ...];</strong></p><p>Here, <em>type</em> is one of Java&#x27;s atomic types, or the name of a class or interface. The <em>identifier</em> is the name of the variable.</p><pre><code class="language-java">int a, b, c; // declares three ints, a, b, and c.
int d = 3, e, f = 5; // declares three more ints, initializing // d  and f.
byte z = 22; // initializes z.                     
double pi = 3.14159; // declares an approximation of pi.
char x = &#x27;x&#x27;; // the variable x has the value x.              
</code></pre><h3>3.1.2 Dynamic Initialization</h3><p>Java allows variables to be initialized dynamically, using any expression valid at the time the variable is declared. For example</p><p>+-----------------------------------------------------------------------+
| // c is dynamically initialized\                                      |
| double c = Math.sqrt(a <!-- -->*<!-- --> a + b <!-- -->*<!-- --> b);                                |
+-----------------------------------------------------------------------+</p><p>The key point here is that the initialization expression may use any element valid at the time of the initialization, including calls to methods, other variables, or literals.</p><h2>3.2 Primitive Data Types</h2><p>The Java programming language supports seven other <em>primitive data types</em>. A primitive type is predefined by the language and is named by a reserved keyword. Primitive values do not share state with other primitive values. The eight primitive data types supported by the Java programming language are:</p><ul><li><strong>byte</strong>: The byte data type is an 8-bit signed two&#x27;s complement integer. It has a minimum value of -128 and a maximum value of 127 (inclusive).</li><li><strong>short</strong>: The short data type is a 16-bit signed two&#x27;s complement integer. It has a minimum value of -32,768 and a maximum value of 32,767 (inclusive).</li><li><strong>int</strong>: By default, the int data type is a 32-bit signed two&#x27;s complement integer, which has a minimum value of -2^31^ and a maximum value of 2^31^-1. In Java SE 8 and later, you can use the int data type to represent an unsigned 32-bit integer, which has a minimum value of 0 and a maximum value of 2^32^-1. Use the Integer class to use int data type as an unsigned integer to support unsigned operations.</li><li><strong>long</strong>: The long data type is a 64-bit two&#x27;s complement integer. The signed long has a minimum value of -2^63^ and a maximum value of 2^63^-1. In Java SE 8 and later, you can use the long data type to represent an unsigned 64-bit long, which has a minimum value of 0 and a maximum value of 2^64^-1.</li><li><strong>float</strong>: The float data type is a single-precision 32-bit IEEE 754 floating point. Its range of values is beyond the scope of this discussion, but is specified in the <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.3">Floating-Point Types, Formats, and Values</a> section of the Java Language Specification. <strong>This data type should never be used for precise values, such as currency</strong>. For that, you will need to use the <a href="https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html">java.math.BigDecimal</a> class instead.</li><li><strong>double</strong>: The double data type is a double-precision 64-bit IEEE 754 floating point. Its range of values is beyond the scope of this discussion but is specified in the <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.3">Floating-Point Types, Formats, and Values</a> section of the Java Language Specification. For decimal values, this data type is generally the default choice. <strong>As mentioned above, this data type should never be used for precise values, such as currency.</strong></li><li><strong>boolean</strong>: The boolean data type has only two possible values: <strong>true and false</strong>. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its &quot;size&quot; isn&#x27;t something that&#x27;s precisely defined.</li><li><strong>char</strong>: The char data type is a single <strong>16-bit Unicode character</strong>. It has a minimum value of &#x27;<!-- -->\<!-- -->u0000&#x27; (or 0) and a maximum value of &#x27;<!-- -->\<!-- -->uffff&#x27; (or 65,535 inclusive).</li></ul><p>In addition to the eight primitive data types listed above, the Java programming language also provides special support for character strings via the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">java.lang.String</a> class. Enclosing your character string within double quotes will automatically create a new String object; for example, String s = &quot;this is a string&quot;; <strong>String objects are <em>immutable</em></strong>, which means that once created, their values cannot be changed.</p><p>The primitive types represent single values---not complex objects. Although Java is otherwise completely object-oriented, the primitive types are not. They are analogous to the simple types found in most other non--object-oriented languages. The reason for this is efficiency. <strong>Making the primitive types into objects would have degraded performance too much.</strong></p><h3>Memory consumption of primitives vs. boxed primitives</h3><p>Primitive Boxed Type Memory Size of primitive / boxed</p><ul><li>boolean Boolean 1 byte / 16 bytes</li><li>byte Byte 1 byte / 16 bytes</li><li>short Short 2 bytes / 16 bytes</li><li>char Char 2 bytes / 16 bytes</li><li>int Integer 4 bytes / 16 bytes</li><li>long Long 8 bytes / 16 bytes</li><li>float Float 4 bytes / 16 bytes</li><li>double Double 8 bytes / 16 bytes</li></ul><p><strong>Boxed objects always require 8 bytes for type and memory management</strong>, and because the size of objects is always a multiple of 8, boxed types all require <strong>16 bytes total</strong>. In addition, each usage of a boxed object entails storing a reference which accounts for another 4 or 8 bytes, depending on the JVM and JVM options. In data-intensive operations, memory consumption can have a major impact on performance.</p><h4>Boxed value caches</h4><p>The space overheads of the boxed types can be mitigated to a degree by the <strong>boxed value caches.</strong> Some of the boxed types implement a cache of instances.</p><p>For example, by default, the Integer class will cache instances to represent numbers in the range -128 to +127. This does not, however, reduce the additional cost arising from the additional memory indirection.</p><p>If you create an instance of a boxed type either by autoboxing or by calling the static <strong>valueOf(primitive)</strong> method, the runtime system will attempt to use a cached value. If your application uses a lot of values in the range that is cached, then this can substantially reduce the memory penalty of using boxed types. Certainly, if you are <strong>creating boxed value instances &quot;by hand&quot;, it is better to use valueOf rather than new.</strong> (The new operation always creates a new instance.) <strong>If, however, the majority of your values are not in the cached range, it can be faster to call new and save the cache lookup.</strong></p><h3>3.2.1 Default Values</h3><p>Fields that are declared but not initialized will be set to a reasonable default by the compiler.</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Data Type</td><td>Default Value (for fields)</td></tr><tr><td>byte</td><td>0</td></tr><tr><td>short</td><td>0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr><tr><td>char</td><td>&#x27;<!-- -->\<!-- -->u0000&#x27;</td></tr><tr><td>String (or any object)  </td><td>null</td></tr><tr><td>boolean</td><td>false</td></tr></tbody></table><p>Local variables are slightly different; the <strong>compiler never assigns a default value to an uninitialized local variable</strong>. If you cannot initialize your local variable where it is declared, make sure to assign it a value before you attempt to use it. Accessing an uninitialized local variable will result in a compile-time error.</p><h4>3.2.1.1 Literals</h4><p>A <strong><em>literal</em> is the source code representation of a fixed value</strong>; literals are represented directly in your <strong>code without requiring computation</strong>. As shown below, it&#x27;s possible to assign a literal to a variable of a primitive type:</p><p><strong>boolean</strong> result = <strong>true</strong>;  </p><p><strong>char</strong> capitalC = &#x27;C&#x27;;  </p><p><strong>byte</strong> b = 100;  </p><p><strong>short</strong> s = 10000;  </p><p><strong>int</strong> i = 100000;  </p><h5>3.2.1.1.1 Integer Literals</h5><p>An integer literal is of type long if it ends with the letter <strong>L or l</strong>; otherwise it is of type int.</p><p>Values of the integral types byte, short, int, and long can be created from int literals. Values of type long that exceed the range of int can be created from long literals. Integer literals can be expressed by these number systems:</p><ul><li>Decimal: Base 10, whose digits consists of the numbers 0 through 9; this is the number system you use every day</li><li>Hexadecimal: Base 16, whose digits consist of the numbers 0 through 9 and the letters A through F</li><li>Binary: Base 2, whose digits consists of the numbers 0 and 1 (you can create binary literals in Java SE 7 and later)</li></ul><p>// The number 26, in decimal
int decVal = 26; // The number 26, in hexadecimal
int hexVal = 0x1a; // The number 26, in binary
int binVal = 0 b11010;  </p><h5>3.2.1.1.2 Hexadecimal, Octal and Binary literals</h5><p>A hexadecimal number is a value in base-16. There are 16 digits, 0-9 and the letters A-F (case does not matter). A-F represents 10-15. An octal number is a value in base-8, and uses the digits 0-7. A binary number is a value in base-2, and uses the digits 0 and 1.</p><p>All of these numbers result in the same value, 110:</p><p>+-----------------------------------------------------------------------+
| int dec = 110; // no prefix --&gt; decimal literal\                    |
| int bin = 0b1101110; // &#x27;0b&#x27; prefix --&gt; binary literal\           |
| int oct = 0156; // &#x27;0&#x27; prefix --&gt; octal literal                   |
+-----------------------------------------------------------------------+</p><h5>3.2.1.1.3 Floating-Point Literals</h5><p>A floating-point literal is of type float if it ends with the letter F or f; otherwise its type is double and it can optionally end with the letter D or d.</p><p>The floating point types (float and double) can also be expressed using E or e (for scientific notation), F or f (32-bit float literal) and D or d (64-bit double literal; this is the default and by convention is omitted).</p><p>double d1 <strong>=</strong> 123.4<strong>;</strong> // same value as d1, but in scientific notation</p><p>double d2 <strong>=</strong> 1.234e2<strong>;</strong> // 1.234E2</p><p>float f1 <strong>=</strong> 123.4 f<strong>;</strong></p><p>The hexadecimal form have an analogous syntax to the simple and scaled decimal forms with the following differences:</p><ul><li>Every hexadecimal floating point literal starts with a zero (0) and then an x or X.</li><li>The digits of the number (but not the exponent part!) also include the hexadecimal digits a through f and their uppercase equivalents.</li><li>The exponent is mandatory, and is introduced by the letter p (or P) instead of an e or E. The exponent represents a scaling factor that is a power of 2 instead of a power of 10.</li></ul><p>Here are some examples:</p><p>+-----------------------------------------------------------------------+
| 0x0.0p0f // this is zero expressed in hexadecimal form (<!-- -->`<!-- -->float<!-- -->`<!-- -->)    |
|                                                                       |
| 0xff.0p19 // this is 255.0 x 2\^19 (<!-- -->`<!-- -->double<!-- -->`<!-- -->)                       |
+-----------------------------------------------------------------------+</p><p>It is a <strong>compilation error if a floating point literal</strong> denotes a number that is too large or too small to represent in the selected representation; i.e. if the number would overflow to +INF or -INF, or underflow to 0.0. However, it is legal for a literal to represent a non-zero denormalized number.</p><p>The floating point literal syntax does not provide literal representations for IEEE 754 special values such as the INF and NaN values. If you need to express them in source code, the recommended way is to use the constants defined by the java.lang.Float and java.lang.Double; e.g. <strong>Float.NaN, Float.NEGATIVE_INFINITY and Float.POSITIVE_INFINITY</strong></p><h5>3.2.1.1.4 Character and String Literals</h5><p>Literals of types char and String may contain any Unicode (UTF-16) characters. If your editor and file system allow it, you can use such characters directly in your code. If not, you can use a &quot;Unicode escape&quot; such as &#x27;<!-- -->\<!-- -->u0108&#x27; (capital C with circumflex), or &quot;S<!-- -->\<!-- -->u00ED Se<!-- -->\<!-- -->u00F1or&quot; (Sí Señor in Spanish). Always use &#x27;single quotes&#x27; for <strong>char literals</strong> and &quot;double quotes&quot; for <strong>String literals</strong>. Unicode escape sequences may be used elsewhere in a program (such as in field names, for example), not just in char or String literals.</p><p>The Java programming language also supports a few special <strong>escape sequences</strong> for char and String literals: <!-- -->\<!-- -->b (backspace), <!-- -->\<!-- -->t (tab), <!-- -->\<!-- -->n (line feed), <!-- -->\<!-- -->f (form feed), <!-- -->\<!-- -->r (carriage return), <!-- -->\<!-- -->&quot;(double quote), <!-- -->\<!-- -->&#x27; (single quote), and <!-- -->\<!-- -->\<!-- --> (backslash).</p><p>There&#x27;s also a special <strong>null literal</strong> that can be used as a value for any reference type. null may be assigned to any variable, except variables of primitive types. There&#x27;s little you can do with a null value beyond testing for its presence. Therefore, null is often used in programs as a marker to indicate that some object is unavailable.</p><p>Finally, there&#x27;s also a special kind of literal called a <strong>class literal</strong>, formed by taking a type name and appending &quot;.class&quot;; for example, String.class. This refers to the object (of type Class) that represents the type itself.</p><h5>3.2.1.1.5 Boolean Literals</h5><p>Boolean literals are simple. There are only two logical values that a boolean value can have, <strong>true and false</strong>. The values of true and false do not convert into any numerical representation. The true literal in Java does not equal 1, nor does the false literal equal 0. In Java, the Boolean literals can only be assigned to variables declared as boolean or used in expressions with Boolean operators.</p><h3>3.2.2 Using Underscore Characters in Numeric Literals</h3><p>In Java SE 7 and later, any number of underscore characters (<!-- -->_<!-- -->) can appear anywhere between digits in a numerical literal. This feature enables you, for example. to separate groups of digits in numeric literals, which can <strong>improve the readability of your code</strong>.</p><p>For instance, if your code contains numbers with many digits, you can use an underscore character to separate digits in groups of three, similar to how you would use a punctuation mark like a comma, or a space, as a separator.</p><p>The following example shows other ways you can use the underscore in numeric literals:</p><pre><code class="language-java">long creditCardNumber **=** 1234 \_5678_9012_3456L**;**
long socialSecurityNumber **=** 999 \_99_9999L**;**
float pi **=** 3.14 \_15F**;**
long hexBytes **=** 0xFF \_EC_DE_5E**;**
long hexWords **=** 0xCAFE \_BABE**;**
long maxLong **=** 0x7fff \_ffff_ffff_ffffL**;**
byte nybbles **=** 0 b0010_0101**;**
long bytes **=** 0 b11010010_01101001_10010100_10010010**;** 
</code></pre><p>You can place underscores only between digits; you cannot place underscores in the following places:</p><ul><li>At the beginning or end of a number (e.g. <!-- -->_<!-- -->123 or 123<!-- -->_<!-- --> are not valid)</li><li>Adjacent to a decimal point in a floating point literal (e.g. 1.<!-- -->_<!-- -->23 or 1<!-- -->_<!-- -->.23 are not valid)</li><li>Prior to an F or L suffix (e.g. 1.23_F or 9999999_L are not valid)</li><li>In positions where a string of digits is expected (e.g. 0_xFFFF is not valid)</li></ul><h2>3.3 The Scope and Lifetime of Variables</h2><h3>3.3.1 Block Scope</h3><p>// Demonstrate block scope.</p><p>class Scope <strong>{</strong></p><p>public static void main<strong>(</strong>String args<strong>[])</strong> <strong>{</strong></p><p>int x<strong>;</strong> // known to all code within main</p><p>x <strong>=</strong> 10<strong>;</strong></p><p><strong>if</strong> <strong>(</strong>x <strong>==</strong> 10<strong>)</strong> <strong>{</strong> // start new scope</p><p>int y <strong>=</strong> 20<strong>;</strong> // known only to this block // x and y both known here.</p><p>System<strong>.</strong>out<strong>.</strong>println<strong>(</strong>&quot;x and y: &quot; <strong>+</strong> x <strong>+</strong> &quot; &quot; <strong>+</strong> y<strong>);</strong></p><p>x <strong>=</strong> y <strong>*</strong> 2<strong>;</strong></p><p><strong>}</strong> // y = 100; // Error! y not known here // x is still known here.</p><p>System<strong>.</strong>out<strong>.</strong>println<strong>(</strong>&quot;x is &quot; <strong>+</strong> x<strong>);</strong></p><p><strong>}</strong></p><p><strong>}</strong>  </p><h3>3.3.2 Out of scope in same block</h3><p>// This fragment is wrong!  </p><p>count = 100; // oops! cannot use count before it is declared!  </p><p><strong>int</strong> count  </p><h3>3.3.3 Lifetime of variable</h3><p>// Demonstrate lifetime of a variable.  </p><p><strong>class</strong> LifeTime {  </p><p>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String args[]) {  </p><p>        <strong>int</strong> x;  </p><p>        <strong>for</strong> (x = 0; x &lt; 3; x++) {  </p><p>            <strong>int</strong> y = -1; // y is initialized each time block is entered  </p><p>            System.out.println(&quot;y is: &quot; + y); // this always prints -1  </p><p>            y = 100;  </p><p>            System.out.println(&quot;y is now: &quot; + y);  </p><p>        }  </p><p>    }  </p><p>}  </p><p>As you can see, y is reinitialized to --1 each time the inner for loop is entered. Even though it is subsequently assigned the value 100, this value is lost.</p><h3>3.3.4 Redeclaration of same variable</h3><p>// This program will not compile  </p><p><strong>class</strong> ScopeErr {  </p><p>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String args[]) {  </p><p>        <strong>int</strong> bar = 1; { // creates a new scope  </p><p>            <strong>int</strong> bar = 2; // Compile-time error -- bar already defined!  </p><p>        }  </p><p>    }  </p><p>}  </p><h2>3.4 Type Conversion and Casting</h2><p><a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-5.html#jls-5.6.2">JLS Spec for conversions</a></p><p>When one type of data is assigned to another type of variable, an <strong>automatic type conversion</strong> will take place if the following two conditions are met:</p><ul><li>The two types are <strong>compatible</strong>.</li><li>The <strong>destination type is larger than the source type</strong>.</li></ul><p>A <strong>widening conversion</strong> is automatic based on the above conditions and doesn&#x27;t require any explicit cast operation, example <strong>byte to int, int to float</strong>. char and boolean are not compatible types.</p><p><strong>Integer literals</strong> are automatically casted into variables of type <strong>byte</strong>, <strong>short</strong>, <strong>long</strong>, or <strong>char</strong></p><p>A <strong>narrowing conversion</strong> of compatible types <strong>requires explicit casting</strong> as destination type is smaller than the source and the user knows what he is doing. int to byte, float/double to int.</p><p><strong>Syntax:</strong> (target-type) value</p><p>// Demonstrate casts.  </p><p><strong>class</strong> Conversion {  </p><p>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String args[]) {  </p><p>        <strong>byte</strong> b;  </p><p>        <strong>int</strong> i = 257;  </p><p>        <strong>double</strong> d = 323.142;  </p><p>        System.out.println(&quot;<!-- -->\<!-- -->nConversion of int to byte.&quot;);  </p><p>        b = (<strong>byte</strong>) i;  </p><p>        System.out.println(&quot;i and b &quot; + i + &quot; &quot; + b);  </p><p>        System.out.println(&quot;<!-- -->\<!-- -->nConversion of double to int.&quot;);  </p><p>        i = (<strong>int</strong>) d;  </p><p>        System.out.println(&quot;d and i &quot; + d + &quot; &quot; + i);  </p><p>        System.out.println(&quot;<!-- -->\<!-- -->nConversion of double to byte.&quot;);  </p><p>        b = (<strong>byte</strong>) d;  </p><p>        System.out.println(&quot;d and b &quot; + d + &quot; &quot; + b);  </p><p>    }  </p><p>}  </p><p>Conversion of <strong>int</strong> to <strong>byte</strong>.</p><p>i and b 257 1 </p><p>Conversion of <strong>double</strong> to <strong>int</strong>.</p><p>d and i 323.142 323 </p><p>Conversion of <strong>double</strong> to <strong>byte</strong>.</p><p>d and b 323.142 67  </p><h3>3.4.1 Automatic Type Promotion in Expressions</h3><p>Automatic type promotions happen in expression evaluation, for example any operation could lead to <strong>overflow in the underlying data type</strong>, hence java follows the following <strong>type promotion rules</strong></p><ul><li>All byte, short and char are promoted to int.</li><li>if one operand is long, the whole expression is promoted to long and similar is the case with float and double.</li><li><strong>Order of conversion happens in the order of evaluation</strong>.</li></ul><p>byte b <strong>=</strong> 50<strong>;</strong></p><p>b <strong>=</strong> <strong>(</strong>byte<strong>)(</strong>b <strong>*</strong> 2<strong>); // Auto type promotion and a narrowing conversion</strong></p><h2>3.5 Arrays</h2><p>An <strong><em>array</em></strong> is a container object that holds a <strong>fixed number</strong> of values of a <strong>single type</strong>. Each item in an array is called an <strong><em>element</em></strong>, and each element is accessed by its numerical <strong><em>index</em></strong>.</p><h3>3.5.1 Declaring a Variable to Refer to an Array</h3><p>+-----------------------------------------------------------------------+
| // declares an array\                                                 |
| int[] anArray;\                                                     |
| Object[] objArray;                                                  |
+-----------------------------------------------------------------------+</p><p><strong>Syntax: type[] identifier</strong></p><p><strong>type</strong> refers to any <strong>primitive types, class type, reference type, interface type</strong>. Identifier is the name of the array.</p><p>You can also place the brackets after the array&#x27;s name:</p><p>+-----------------------------------------------------------------------+
| // this form is discouraged, brackets identify the array type and     |
| should appear with the type designation.\                             |
| float anArrayOfFloats[];                                            |
+-----------------------------------------------------------------------+</p><h3>3.5.2 Creating, Initializing, and Accessing an Array</h3><p>+-----------------------------------------------------------------------+
| // Creating and Array                                                 |
|                                                                       |
| // identifier = new type<!-- -->[size]<!-- -->;                                     |
|                                                                       |
| anArray <strong>=</strong> <strong>new</strong> int<strong>[</strong>10<strong>];</strong>                              |
|                                                                       |
| // type[] identifier = {value1, value2, <!-- -->.<!-- -->..}; size = value count.  |
|                                                                       |
| int<strong>[]</strong> anArray <strong>=</strong> <strong>{</strong> 100<strong>,</strong> 200<strong>,</strong> 300<strong>,</strong> 400<strong>,</strong>   |
| 500<strong>,</strong> 600<strong>,</strong> 700<strong>,</strong> 800<strong>,</strong> 900<strong>,</strong> 1000 <strong>};</strong>              |
|                                                                       |
| // type <!-- -->[][]<!-- -->[]<!-- -->.<!-- -->.. identifier = new                             |
| type<!-- -->[size1][size2]<!-- -->[size3]<!-- -->..                                     |
|                                                                       |
| int<strong>[][]</strong> anArray <strong>=</strong> <strong>new</strong> int<strong>[</strong>10<strong>][</strong>5<strong>];</strong>     |
|                                                                       |
| int<strong>[][]</strong> anArray <strong>=</strong> <strong>{</strong> <strong>{</strong>1<strong>,</strong> 2<strong>},</strong> <strong>{</strong>3<strong>,</strong>   |
| 4<strong>},</strong> <strong>{</strong>5<strong>,</strong> 6<strong>}</strong> <strong>};</strong>                                     |
+-----------------------------------------------------------------------+</p><p>If this statement is missing, then the compiler prints an error like the following, and compilation fails: Variable anArray may not have been initialized.</p><p>// <strong>Initializing array</strong></p><p>Syntax: <strong>identifier<!-- -->[index]<!-- --> = value</strong>;</p><p>anArray<strong>[</strong>0<strong>]</strong> <strong>=</strong> 100<strong>;</strong> // initialize first element</p><p>anArray<strong>[</strong>1<strong>]</strong> <strong>=</strong> 200<strong>;</strong> // initialize second element</p><p>anArray<strong>[</strong>2<strong>]</strong> <strong>=</strong> 300<strong>;</strong> // and so forth</p><p>//<strong>Multidimensional array initialization</strong></p><p>Syntax: <strong>identifier<!-- -->[index1][index2]<!-- -->.. = value</strong>;</p><p>anArray<strong>[</strong>2<strong>][</strong>1<strong>]</strong> <strong>=</strong> 6</p><p>Arrays cannot be reinitialized using the array initializer shortcut syntax, since an array initializer can only be specified in a <strong>field declaration or local variable declaration</strong>, or as a part of <strong>an array creation expression</strong>.</p><p>// First initialization of array</p><p>int<strong>[]</strong> array <strong>=</strong> <strong>new</strong> int<strong>[]</strong> <strong>{</strong> 1<strong>,</strong> 2<strong>,</strong> 3 <strong>};</strong></p><p>// Re-initializes array to a new int[] array.</p><p>array <strong>=</strong> <strong>new</strong> int<strong>[]</strong> <strong>{</strong> 4<strong>,</strong> 5<strong>,</strong> 6 <strong>};</strong></p><p>// compilation error, neither a declaration nor array creation.</p><p>array <strong>=</strong> <strong>{</strong>1<strong>,</strong>2<strong>,</strong>3<strong>,</strong>4<strong>};</strong></p><p><strong>Array Access</strong></p><p><strong>Syntax</strong>: <strong>identifier<!-- -->[index1][index2]<!-- -->..</strong></p><p>Most commonly array initialization and access is done by looping over the bounds of indices.</p><p>if you need a very large n-dimensional array that is sparsely populated (that is, one in which not all of the elements will be used), then an irregular array might be a perfect solution. These are also called <strong>jagged/ragged</strong> arrays.</p><p>int<strong>[][]</strong> a <strong>=</strong> <strong>{</strong> <strong>{</strong>1<strong>},</strong> <strong>{</strong>2<strong>,</strong> 3<strong>},</strong> <strong>null</strong> <strong>};</strong></p><p>Here, a<!-- -->[0]<!-- --> is a one-length int array, whereas a<!-- -->[1]<!-- --> is a two-length int array and a<!-- -->[2]<!-- --> is null. It is very important to understand multi-dimensional arrays in Java are implemented as arrays of arrays, i.e. <strong>array<!-- -->[i][j]<!-- -->[k]<!-- --> is equivalent to ((array<!-- -->[i]<!-- -->)<!-- -->[j]<!-- -->)<!-- -->[k]</strong>. This can clarify lot of questions.</p><h3>Array Covariance</h3><p>Object arrays are <strong>covariant, which means that just as Integer is a subclass of Number, Integer[] is a subclass of Number[]</strong>. This may seem intuitive, but can result in surprising behavior:</p><pre><code class="language-java">+-----------------------------------------------------------------------+
| Integer[] integerArray = {1, 2, 3};\                                |
| Number[] numberArray = integerArray; // valid\                      |
| Number firstElement = numberArray[0]; // valid\                     |
| numberArray[0] = 4L; // throws **ArrayStoreException at runtime**   |
+----------------------------------------------------------------------
</code></pre><p>Although Integer[] is a subclass of Number[], it can only hold Integers, and trying to assign a Long element throws a runtime exception.</p><p>Note that this behavior is unique to arrays, and can be avoided by using a generic List instead:</p><pre><code class="language-java">+-----------------------------------------------------------------------+
| List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3);\                |
| //List&lt;Number&gt; numberList = integerList; // compile error\          |
| List&lt;? extends Number&gt; numberList = integerList;\                   |
| Number firstElement = numberList.get(0);\                             |
| //numberList.set(0, 4L); // compile error                             |
+----------------------------------------------------------------------+
</code></pre><p>It&#x27;s not necessary for all of the <strong>array elements to share the same type, as long as they are a subclass of the array&#x27;s type</strong>:</p><pre><code class="language-java">interface I {}
class A implements I {}
class B implements I {}
class C implements I {}
I[] array10 = new I[] { new A(), new B(), new C() }; // Create an array with new
// operator and array initializer.
I[] array11 = { new A(), new B(), new C() }; // Shortcut syntax with array
// initializer.
I[] array12 = new I[3]; // { null, null, null }
I[] array13 = new A[] { new A(), new A() }; // Works because A implements I.
Object[] array14 = new Object[] { &quot;Hello, World!&quot;, 3.14159, 42 }; // Create an array with
// new operator and array initializer.
Object[] array15 = { new A(), 64, &quot;My String&quot; }; // Shortcut syntax
// with array initializer.
</code></pre><h3>3.5.4 Arrays Class</h3><p>Useful operations provided by methods in the java.util.Arrays class, are:</p><ul><li><strong>Searching</strong> an array for a specific value to get the index at which it is placed (the <strong>binarySearch</strong> method).</li><li>Comparing two arrays to determine if they are equal or not (the <strong>equals</strong> method).</li><li><strong>Filling</strong> an array to place a specific value at each index (the fill method).</li><li><strong>Sorting</strong> an array into ascending order. This can be done either <strong>sequentially</strong>, using the sort method, or concurrently, using the parallelSort method introduced in Java SE 8. <strong>Parallel sorting</strong> of large arrays on multiprocessor systems is faster than sequential array sorting.</li><li><strong>Array copy</strong> from one to other, supporting <strong>partial and range</strong> copying.</li></ul><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html">Arrays</a></p><h2>3.6 Operators</h2><p><strong>Operators</strong> are special symbols that perform specific operations on <strong>one, two, or three <em>operands</em></strong>, and then return a result.</p><p>The operators in the following table are listed according to precedence order high to low.</p><ul><li>Operators with <strong>higher precedence are evaluated before operators with relatively lower precedence</strong>.</li><li>Operators on the <strong>same line have equal precedence</strong>. When operators of equal precedence appear in the same expression, a rule must govern which is evaluated first.</li><li><strong>All binary operators except for the assignment operators are evaluated from left to right</strong>.</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Operator Precedence</td><td></td></tr><tr><td>Operators</td><td><strong>Precedence</strong></td></tr><tr><td>postfix</td><td><em>expr</em>++ <em>expr</em>--</td></tr><tr><td>unary</td><td>++<em>expr</em> --<em>expr</em> +<em>expr</em> -<em>expr</em> ~ !</td></tr><tr><td>multiplicative</td><td>*<!-- --> / %</td></tr><tr><td>additive</td><td>+ -</td></tr><tr><td>shift</td><td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td></tr><tr><td>relational</td><td>&lt; &gt; &lt;= &gt;= instanceof</td></tr><tr><td>equality</td><td>== !=</td></tr><tr><td>bitwise AND</td><td>&amp;</td></tr><tr><td>bitwise exclusive OR</td><td>\^</td></tr><tr><td>bitwise inclusive OR</td><td>|</td></tr><tr><td>logical AND</td><td>&amp;&amp;</td></tr><tr><td>logical OR</td><td>|<!-- -->|</td></tr><tr><td>ternary</td><td>? :</td></tr><tr><td>assignment</td><td>= += -= <!-- -->*<!-- -->= /= %= &amp;= \^= <!-- -->|<!-- -->= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</td></tr></tbody></table><h2>3.7 Assignment, Arithmetic, and Unary Operators</h2><h3>3.7.1 The Simple Assignment Operator</h3><p>&quot;=&quot; is the assignment operator evaluating from right to left to assign value or object reference.</p><p>+-----------------------------------------------------------------------+
| int num = 5; //value is assigned here                                 |
|                                                                       |
| // reference is assigned here\                                        |
| Object obj1 = new Object();\                                          |
| Object obj2 = obj1;                                                   |
+-----------------------------------------------------------------------+</p><h3>3.7.2 The Arithmetic Operators</h3><p>The table defines the list of arithmetic operations.</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Operator</td><td>Description</td></tr><tr><td>+</td><td>Additive operator (also used for String concatenation)</td></tr><tr><td>-</td><td>Subtraction operator</td></tr><tr><td>*</td><td>Multiplication operator</td></tr><tr><td>/</td><td>Division operator</td></tr><tr><td>\%</td><td>Remainder operator</td></tr></tbody></table><h3>3.7.3 The Unary Operators</h3><p>The unary operators require only one operand; they perform various operations such as incrementing/decrementing a value by one, negating an expression, or inverting the value of a boolean.</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Operator</td><td>Description</td></tr><tr><td>+</td><td>Unary plus operator; indicates positive value (numbers are positive without this, however)</td></tr><tr><td>-</td><td>Unary minus operator; negates an expression</td></tr><tr><td>++</td><td>Increment operator; increments a value by 1, can be postfix or prefix</td></tr><tr><td>--</td><td>Decrement operator; decrements a value by 1, can be postfix or prefix</td></tr><tr><td>!</td><td>Logical complement operator; inverts the value of a boolean</td></tr></tbody></table><p>The only difference is that the prefix version (++result) evaluates to the incremented value, whereas the postfix version (result++) evaluates to the original value.</p><h2>3.8 Equality, Relational, and Conditional Operators</h2><h3>3.8.1 The Equality and Relational Operators</h3><p>The relational operators return boolean true or false based on the condition evaluation.</p><p><strong>Syntax: opr1<!-- -->[primitive type]<!-- --> operator oper2<!-- -->[primitive type]</strong></p><p><strong>==</strong> equal to</p><p><strong>!=</strong> not equal to</p><p><strong>&gt;</strong> greater than</p><p><strong>&gt;=</strong> greater than or equal to</p><p><strong>&lt;</strong> less than</p><p><strong>&lt;=</strong> less than or equal to</p><h3>3.8.2 The Conditional Operators</h3><p>The &amp;&amp; and <!-- -->|<!-- -->|<!-- --> operators perform Conditional-AND and Conditional-OR operations on two boolean expressions. These operators exhibit <strong>&quot;short-circuiting&quot;</strong> behavior, which means that the <strong>second operand is evaluated only if needed</strong>.</p><p>Syntax: <strong>Result<!-- -->[Boolean]<!-- --> = Expression1<!-- -->[Boolean result]<!-- --> ConditionOpr<!-- -->[&amp;&amp;/<!-- -->|<!-- -->|]<!-- --> Expression2<!-- -->[Boolean result]</strong></p><p><strong>Short circuiting helps to write concise code, where Expression2 needs to be evaluated only after Expression1. Which is otherwise implemented as nested if&#x27;s.</strong></p><h4>Ternary Operator</h4><p>Ternary operator is a shorthand if-else In the following example, this operator should be read as: &quot;If someCondition is true, assign the value of value1 to result. Otherwise, assign the value of value2 to result.&quot;</p><p>result <strong>=</strong> someCondition <strong>?</strong> value1 <strong>:</strong> value2<strong>;</strong></p><h3>3.8.3 The Type Comparison Operator instanceof</h3><p>The instanceof operator compares an object to a specified type and return boolean value.</p><p><strong>Syntax</strong>: <strong>Object instanceof ReferenceType<!-- -->[Class/interface]</strong></p><ul><li>Object is an instance of superclass and itself.</li><li>Object is an instance of interface if it&#x27;s implemented by itself or superclass.</li><li>Null is not an instance of anything.</li></ul><p>Consider the following.</p><p>class Parent <strong>{}</strong></p><p>class Child <strong>extends</strong> Parent <strong>implements</strong> MyInterface <strong>{}</strong></p><p>interface MyInterface <strong>{}</strong></p><p>Parent obj1 <strong>=</strong> <strong>new</strong> Parent<strong>();</strong></p><p>Parent obj2 <strong>=</strong> <strong>new</strong> Child<strong>();</strong></p><p>obj1 <strong>instanceof</strong> Parent<strong>:</strong> <strong>true</strong></p><p>obj1 <strong>instanceof</strong> Child<strong>:</strong> <strong>false</strong></p><p>obj1 <strong>instanceof</strong> MyInterface<strong>:</strong> <strong>false</strong></p><p>obj2 <strong>instanceof</strong> Parent<strong>:</strong> <strong>true</strong></p><p>obj2 <strong>instanceof</strong> Child<strong>:</strong> <strong>true</strong></p><p>obj2 <strong>instanceof</strong> MyInterface<strong>:</strong> <strong>true</strong></p><h2>3.9 Bitwise Operators</h2><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>~</td><td>Bitwise unary NOT</td></tr><tr><td>&amp;</td><td>Bitwise AND</td></tr><tr><td>|</td><td>Bitwise OR</td></tr><tr><td>\^</td><td>Bitwise exclusive OR</td></tr></tbody></table><p>The Java programming language also provides operators that perform bitwise and bit shift operations on integral types. The operators discussed in this section are less commonly used.</p><p>The unary bitwise complement operator &quot;~&quot; inverts a bit pattern; it can be applied to any of the integral types, making every &quot;0&quot; a &quot;1&quot; and every &quot;1&quot; a &quot;0&quot;. For example, a byte contains 8 bits; applying this operator to a value whose bit pattern is &quot;00000000&quot; would change its pattern to &quot;11111111&quot;.</p><p>The signed left shift operator &quot;&lt;&lt;&quot; shifts a bit pattern to the left, and the signed right shift operator &quot;&gt;&gt;&quot; shifts a bit pattern to the right. The bit pattern is given by the left-hand operand, and the number of positions to shift by the right-hand operand. The unsigned right shift operator &quot;&gt;&gt;&gt;&quot; shifts a zero into the leftmost position, while the leftmost position after &quot;&gt;&gt;&quot; depends on sign extension.</p><p>The following program, <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/BitDemo.java">BitDemo</a>, uses the bitwise AND operator to print the number &quot;2&quot; to standard output.</p><p>class BitDemo {</p><p>public static void main(String[] args) {</p><p>int bitmask = 0x000F;</p><p>int val = 0x2222;</p><p>// prints &quot;2&quot;</p><p>System.out.println(val &amp; bitmask);</p><p>}</p><p>}</p><h3>Assignment Operator</h3><p>The <strong>left hand operand for these operators must be a either a non-final variable or an element of an array</strong>. The <strong>right hand operand must be assignment compatible with the left hand operand</strong>. This means that either the types must be the same, or the right operand type must be convertible to the left operand type by a combination of <strong>boxing, unboxing or widening</strong>.</p><p>The precise meaning of the &quot;operation and assign&quot; operators is specified by JLS 15.26.2 as:</p><p>A compound assignment expression of the form <strong>E1 op= E2 is equivalent to E1 = (T) ((E1) op (E2))</strong>, where <strong>T is the type of E1</strong>, except that E1 is evaluated only once. <strong>Note that there is an implicit type-cast before the final assignment</strong>.</p><h3>Shift Operators</h3><p>The Java language provides three operators for performing <strong>bitwise shifting on 32 and 64 bit integer values</strong>. These are all binary operators with the <strong>first operand being the value to be shifted, and the second operand saying how far to shift</strong>.</p><p>The <strong>&lt;&lt; or left shift operator</strong> shifts the value given by the first operand leftwards by the number of bit positions given by the second operand. The <strong>empty positions at the right end are filled with zeros</strong>.</p><p>The <strong>&#x27;&gt;&gt;&#x27; or arithmetic shift</strong> operator shifts the value given by the first operand rightwards by the number of bit positions given by the second operand. <strong>The empty positions at the left end are filled by copying the left-most bit. This process is known as sign extension</strong>.</p><p>The <strong>&#x27;&gt;&gt;&gt;&#x27; or logical right shift</strong> operator shifts the value given by the first operand rightwards by the number of bit positions given by the second operand. <strong>The empty positions at the left end are filled with zeros</strong>.</p><p>Notes:</p><ul><li>These <strong>operators require an int or long value as the first operand</strong>, and produce a value with the same type as the first operand. (You will need to use an <strong>explicit type cast when assigning the result of a shift to a byte,short or char variable</strong>.)</li><li>If you use a shift operator with a first operand that is a <strong>byte, char or short</strong>, it is <strong>promoted to an int</strong> and the operation produces an int. <a href="file:///C:/Users/raghu/Google%20Drive/study/java/docs/Java-mammoth.html#_heading=h.3as4poj">Type Promotion</a></li><li>The second operand is reduced modulo the number of bits of the operation to give the amount of the shift. For more about the <strong>mod mathematical concept</strong>, see Modulus examples.</li><li>The <strong>bits that are shifted off the left or right end by the operation are discarded</strong>. (<strong>Java does not provide a primitive &quot;rotate&quot; operator.</strong>)</li><li>The arithmetic shift operator is equivalent to dividing a (two&#x27;s complement) number by a power of 2.</li><li>The left shift operator is equivalent to multiplying a (two&#x27;s complement) number by a power of 2.</li></ul><h3>The Lambda operator ( -&gt; )</h3><p>From Java 8 onwards, the <strong>Lambda operator</strong> ( -&gt; ) is the operator used to introduce a <strong>Lambda Expression</strong>. There are two common syntaxes, as illustrated by these examples:</p><p>a <strong>-&gt;</strong> a <strong>+</strong> 1 // a lambda that adds one to its argument</p><p>a <strong>-&gt;</strong> <strong>{</strong> <strong>return</strong> a <strong>+</strong> 1<strong>;</strong> <strong>}</strong> // an equivalent lambda using a block.</p><p>A lambda expression defines an <strong>anonymous function</strong>, or more correctly an <strong>instance of an anonymous class that implements a functional interface</strong>.</p><h3>3.11 Using Parentheses</h3><p>Parentheses are used for</p><ul><li>Raising the precedence of an operator. 1+2<!-- -->*<!-- -->3 =&gt; 1+(2<!-- -->*<!-- -->3) <!-- -->[According to precedence]<!-- --> =&gt; (1+2)<!-- -->*<!-- -->3 <!-- -->[+ is evaluated because of parenthesis]</li><li>Clarifying ambiguous operations. 1+2-3 =&gt; 1+(2-3) <!-- -->[Both + and - have equal precedence, evaluation precedence is from left to right]</li><li>Adding redundant parentheses for better understanding of evaluation, it doesn&#x27;t degrade the performance.<ul><li>a <!-- -->|<!-- --> 4 + c &gt;&gt; b &amp; 7 == (a <!-- -->|<!-- --> (((4 + c) &gt;&gt; b) &amp; 7))</li></ul></li></ul><h2>3.12 Expressions, Statements, and Blocks</h2><p>Operators may be used in building expressions, which compute values; expressions are the core components of statements; statements may be grouped into blocks.</p><h3>3.12.1 Expressions</h3><p>An <em>expression</em> is a construct made up of variables, operators, and method invocations, which are constructed according to the syntax of the language, that evaluates to a single value. You&#x27;ve already seen examples of expressions, illustrated in bold below:</p><p>int <strong>cadence = 0</strong>;</p><p><strong>anArray<!-- -->[0]<!-- --> = 100</strong>;</p><p>System.out.println(<strong>&quot;Element 1 at index 0: &quot; + anArray<!-- -->[0]</strong>);</p><p>int <strong>result = 1 + 2</strong>; // result is now 3</p><p>if (<strong>value1 == value2</strong>)</p><p>System.out.println(<strong>&quot;value1 == value2&quot;</strong>);</p><p>The data type of the value returned by an expression depends on the elements used in the expression. The expression cadence = 0 returns an int because the assignment operator returns a value of the same data type as its left-hand operand; in this case, cadence is an int. As you can see from the other expressions, an expression can return other types of values as well, such as boolean or String.</p><p>The Java programming language allows you to construct compound expressions from various smaller expressions as long as the data type required by one part of the expression matches the data type of the other. Here&#x27;s an example of a compound expression:</p><p>1 <!-- -->*<!-- --> 2 <!-- -->*<!-- --> 3</p><p>In this particular example, the order in which the expression is evaluated is unimportant because the result of multiplication is independent of order; the outcome is always the same, no matter in which order you apply the multiplications. However, this is not true of all expressions. For example, the following expression gives different results, depending on whether you perform the addition or the division operation first:</p><p>x + y / 100 // ambiguous</p><p>You can specify exactly how an expression will be evaluated using balanced parenthesis: ( and ). For example, to make the previous expression unambiguous, you could write the following.</p><p>(x + y) / 100 // unambiguous, recommended</p><p>If you don&#x27;t explicitly indicate the order for the operations to be performed, the order is determined by the precedence assigned to the operators in use within the expression. Operators that have a higher precedence get evaluated first. For example, the division operator has a higher precedence than does the addition operator. Therefore, the following two statements are equivalent:</p><p>x + y / 100</p><p>x + (y / 100) // unambiguous, recommended</p><p>When writing compound expressions, be explicit and indicate with parentheses which operators should be evaluated first. This practice makes code easier to read and to maintain.</p><h3>3.12.2 Statements</h3><p>Statements are roughly equivalent to sentences in natural languages. A <em>statement</em> forms a complete unit of execution. The following types of expressions can be made into a statement by terminating the expression with a semicolon (;).</p><ul><li>Assignment expressions</li><li>Any use of ++ or --</li><li>Method invocations</li><li>Object creation expressions</li></ul><p>Such statements are called <em>expression statements</em>. Here are some examples of expression statements.</p><p>// assignment statement</p><p>aValue = 8933.234;</p><p>// increment statement</p><p>aValue++;</p><p>// method invocation statement</p><p>System.out.println(&quot;Hello World!&quot;);</p><p>// object creation statement</p><p>Bicycle myBike = new Bicycle();</p><p>In addition to expression statements, there are two other kinds of statements: <em>declaration statements</em> and <em>control flow statements</em>. A <em>declaration statement</em> declares a variable. You&#x27;ve seen many examples of declaration statements already:</p><p>// declaration statement</p><p>double aValue = 8933.234;</p><h3>3.12.3 Blocks</h3><p>A <em>block</em> is a group of zero or more statements between balanced braces and can be used anywhere a single statement is allowed. The following example, <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/BlockDemo.java">BlockDemo</a>, illustrates the use of blocks:</p><p><strong>class</strong> BlockDemo {  </p><p>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </p><p>        <strong>boolean</strong> condition = <strong>true</strong>;  </p><p>        <strong>if</strong> (condition) { // begin block 1  </p><p>            System.out.println(&quot;Condition is true.&quot;);  </p><p>        } // end block one  </p><p>        <strong>else</strong> { // begin block 2  </p><p>            System.out.println(&quot;Condition is false.&quot;);  </p><p>        } // end block 2  </p><p>    }  </p><p>}  </p><h2>3.13 Control Flow Statements</h2><p><em>Control flow statements</em>, however, break up the flow of execution by employing decision making, looping, and branching, enabling your program to <em>conditionally</em> execute particular blocks of code.</p><h3>3.13.1 The switch Statement</h3><p>The switch statement is Java&#x27;s multi-way branch statement. It is used to take the place of long if-else if-else chains, and make them more readable. However, unlike if statements, one may not use inequalities; each value must be concretely defined.</p><p>There are three critical components to the switch statement:</p><ul><li><strong>case</strong>: This is the value that is evaluated for equivalence with the argument to the switch statement.</li><li><strong>default</strong>: This is an optional, catch-all expression, should none of the case statements evaluate to true.</li><li>Abrupt completion of the case statement; usually break: This is required to prevent the undesired evaluation of further case statements.</li></ul><p>With the exception of continue, it is possible to use any statement which would cause the abrupt completion of a statement. This includes:</p><ul><li>break</li><li>return</li><li>throw</li></ul><p>In the example below, a typical switch statement is written with four possible cases, including default.</p><p>+-----------------------------------------------------------------------+
| Scanner scan = new Scanner(System.in);                                |
|                                                                       |
| int i = scan.nextInt();                                               |
|                                                                       |
| switch (i) {                                                          |
|                                                                       |
| case 0:                                                               |
|                                                                       |
| System.out.println(&quot;i is zero&quot;);                                    |
|                                                                       |
| break;                                                                |
|                                                                       |
| case 1:                                                               |
|                                                                       |
| System.out.println(&quot;i is one&quot;);                                     |
|                                                                       |
| break;                                                                |
|                                                                       |
| case 2:                                                               |
|                                                                       |
| System.out.println(&quot;i is two&quot;);                                     |
|                                                                       |
| break;                                                                |
|                                                                       |
| default: System.out.println(&quot;i is less than zero or greater than     |
| two&quot;);                                                               |
|                                                                       |
| }                                                                     |
+-----------------------------------------------------------------------+</p><p>By omitting a break or any statement which would be an abrupt completion, we can leverage what are known as &quot;<strong>fallthrough</strong>&quot; cases, which evaluate against several values. This can be used to create ranges for a value to be successful against, but is still not as flexible as inequalities.</p><table><thead><tr><th></th></tr></thead><tbody><tr><td>Scanner scan = new Scanner(System.in); int foo = scan.nextInt(); switch(foo) { case 1: System.out.println(&quot;I&#x27;m equal or greater than one&quot;); case 2: case 3: System.out.println(&quot;I&#x27;m one, two, or three&quot;); break; default: System.out.println(&quot;I&#x27;m not either one, two, or three&quot;); }</td></tr></tbody></table><p>In case of foo == 1 the output will be:</p><p>I&#x27;m equal or greater than one</p><p>I&#x27;m one, two, or three</p><p>In case of foo == 3 the output will be:</p><p>I&#x27;m one, two, or three</p><p>Version ≥ Java SE 5 The <strong>switch statement can also be used with enums</strong>.</p><p>+-----------------------------------------------------------------------+
| enum Option { BLUE_PILL, RED_PILL }\                                  |
| public void takeOne(Option option) { switch(option) { case BLUE_PILL: |
| System.out.println(&quot;Story ends, wake up, believe whatever you        |
| want.&quot;); break; case RED_PILL: System.out.println(&quot;I show you how   |
| deep the rabbit hole goes.&quot;); break; } }                             |
+-----------------------------------------------------------------------+</p><p>Version ≥ Java SE 7 The <strong>switch statement can also be used with Strings</strong>.</p><table><thead><tr><th></th></tr></thead><tbody><tr><td>public void rhymingGame(String phrase) { switch (phrase) { case &quot;apples and pears&quot;: System.out.println(&quot;Stairs&quot;); break; case &quot;lorry&quot;: System.out.println(&quot;truck&quot;); break; default: System.out.println(&quot;Don&#x27;t know any more&quot;); } }</td></tr></tbody></table><p>A switch as part of the statement sequence of an outer switch. This is called a <strong>nested switch</strong>. Since a switch statement defines its own block, no conflicts arise between the case constants in the inner switch and those in the outer switch. For example, the following fragment is perfectly valid:</p><p>+-----------------------------------------------------------------------+
| switch (count) {\                                                     |
| case 1:\                                                              |
| switch (target) { // nested switch\                                   |
| case 0:\                                                              |
| System.out.println(&quot;target is zero&quot;);\                              |
| break;\                                                               |
| case 1: // no conflicts with outer switch\                            |
| System.out.println(&quot;target is one&quot;);\                               |
| break;\                                                               |
| }\                                                                    |
| break;\                                                               |
| case 2: // <!-- -->.<!-- -->..                                                       |
+-----------------------------------------------------------------------+</p><p>Here, the case 1: statement in the inner switch does not conflict with the case 1: statement in the outer switch. The count variable is compared only with the list of cases at the outer level. If count is 1, then target is compared with the inner list cases.</p><h3>3.13.2 if-then and if-then-else Statements</h3><h4>3.13.2.1 The if-then Statement</h4><p>The if-then statement is the most basic of all the control flow statements. It tells your program to execute a certain section of code <em>only if</em> a particular test evaluates to true.</p><p>void applyBrakes() { // the &quot;if&quot; clause: bicycle must be moving
if (isMoving) { // the &quot;then&quot; clause: decrease current speed
currentSpeed--;
}
}    </p><p>If this test evaluates to false, control jumps to the end of the if-then statement.In addition, the opening and closing braces are optional, provided that the &quot;then&quot; clause contains only one statement:</p><p><strong>void</strong>  applyBrakes()  {  // same as above, but without braces               </p><p>    <strong>if</strong>  (isMoving)  currentSpeed--;    </p><p>}    </p><h4>3.13.2.2 The if-then-else Statement</h4><p>+-----------------------------------------------------------------------+
| if (i &lt; 2) {                                                         |
|                                                                       |
| System.out.println(&quot;i is less than 2&quot;);                             |
|                                                                       |
| } else if (i &gt; 2) {                                                  |
|                                                                       |
| System.out.println(&quot;i is more than 2&quot;);                             |
|                                                                       |
| } else {                                                              |
|                                                                       |
| System.out.println(&quot;i is not less than 2, and not more than 2&quot;);    |
|                                                                       |
| }                                                                     |
+-----------------------------------------------------------------------+</p><p>The if block will only run when i is 1 or less. The else if condition is checked only if all the conditions before it (in previous else if constructs, and the parent if constructs) have been tested to false. In this example, the else if condition will only be checked if i is greater than or equal to 2. If its result is true, its block is run, and any else if and else constructs after it will be skipped. If none of the if and else if conditions have been tested to true, the else block at the end will be run</p><h2>3.14 The while and do-while Statements</h2><p>The while statement continually executes a block of statements while a particular condition is true. Its syntax can be expressed as:</p><p><strong>while</strong> (expression) {  </p><p>    statement(s)  </p><p>}  </p><p>The while statement evaluates <em>expression</em>, which must return a boolean value. If the expression evaluates to true, the while statement executes the <em>statement</em>(s) in the while block. The while statement continues testing the expression and executing its block until the expression evaluates to false.</p><p><strong>class</strong>  WhileDemo  {        </p><p>    <strong>public</strong>  <strong>static</strong>  <strong>void</strong>  main(String[]  args)  {            </p><p>        <strong>int</strong>  count  =  1;            </p><p>        <strong>while</strong>  (count  &lt;  11)  {                </p><p>            System.out.println(&quot;Count is: &quot;  +  count);                </p><p>            count++;            </p><p>        }        </p><p>    }    </p><p>}    </p><p>You can implement an infinite loop using the while statement as follows:</p><p><strong>while</strong>  (<strong>true</strong>)  {  // your code goes here    </p><p>}    </p><p>The Java programming language also provides a do-while statement, which can be expressed as follows:</p><p><strong>do</strong> {  </p><p>    statement(s)  </p><p>} <strong>while</strong> (expression);  </p><p>do-while evaluates its expression at the bottom of the loop instead of the top. Therefore, the statements within the do block are always executed at least once</p><p><strong>class</strong> DoWhileDemo {  </p><p>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </p><p>        <strong>int</strong> count = 1;  </p><p>        <strong>do</strong> {  </p><p>            System.out.println(&quot;Count is: &quot; + count);  </p><p>            count++;  </p><p>        } <strong>while</strong> (count &lt; 11);  </p><p>    }  </p><p>}  </p><h2>3.15 The for Statement</h2><p>The for statement provides a compact way to iterate over a range of values. Programmers often refer to it as the &quot;for loop&quot; because of the way in which it repeatedly loops until a particular condition is satisfied. The general form of the for statement can be expressed as follows:</p><p><strong>for</strong>  (initialization;  termination;  increment)  {        </p><p>    statement(s)    </p><p>}    </p><p>When using this version of the for statement, keep in mind that:</p><ul><li>The <em>initialization</em> expression initializes the loop; it&#x27;s executed once, as the loop begins.</li><li>When the <em>termination</em> expression evaluates to false, the loop terminates.</li><li>The <em>increment</em> expression is invoked after each iteration through the loop; it is perfectly acceptable for this expression to increment <em>or</em> decrement a value.</li></ul><p><strong>class</strong> ForDemo {  </p><p>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </p><p>        <strong>for</strong> (<strong>int</strong> i = 1; i &lt; 11; i++) {  </p><p>            System.out.println(&quot;Count is: &quot; + i);  </p><p>        }  </p><p>    }  </p><p>}  </p><p>The three expressions of the for loop are optional; an <strong>infinite loop</strong> can be created as follows:</p><p>// infinite loop  </p><p><strong>for</strong> (;;) { // your code goes here  </p><p>}  </p><p>Multiple variables in for loop.</p><p>// Using the comma.  </p><p><strong>class</strong> Comma {  </p><p>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String args[]) {  </p><p>        <strong>int</strong> a, b;  </p><p>        <strong>for</strong> (a = 1, b = 4; a &lt; b; a++, b--) {  </p><p>            System.out.println(&quot;a = &quot; + a);  </p><p>            System.out.println(&quot;b = &quot; + b);  </p><p>        }  </p><p>    }  </p><p>} </p><p>The for statement also has another form designed for iteration through <a href="https://docs.oracle.com/javase/tutorial/collections/index.html">Collections</a> and <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html">arrays</a> This form is sometimes referred to as the enhanced for statement, and can be used to make your loops more compact and easy to read. To demonstrate, consider the following array, which holds the numbers 1 through 10:</p><p><strong>int</strong>[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };  </p><p>The following program, <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/EnhancedForDemo.java">EnhancedForDemo</a>, uses the enhanced for to loop through the array:</p><p><strong>class</strong> EnhancedForDemo {  </p><p>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </p><p>        <strong>int</strong>[] numbers = {  </p><p>            1, 2, 3, 4, 5, 6, 7, 8, 9, 10  </p><p>        };  </p><p>        <strong>for</strong> (<strong>int</strong> item: numbers) {  </p><p>            System.out.println(&quot;Count is: &quot; + item);  </p><p>        }  </p><p>    }  </p><p>}  </p><p>In this example, the variable item holds the current value from the numbers array. The output from this program is the same as before.</p><h2>3.16 Branching Statements</h2><h3>3.16.1 The break Statement</h3><p>The break statement ends a loop (like for, while) or the evaluation of a switch statement.</p><p>+-----------------------------------------------------------------------+
| Loop:\                                                                |
| while(true) {\                                                        |
| if(someCondition == 5) {\                                             |
| break;\                                                               |
| }\                                                                    |
| }                                                                     |
+-----------------------------------------------------------------------+</p><p>The loop in the example would run forever. But when someCondition equals 5 at some point of execution, then the loop ends. If multiple loops are cascaded, only the most inner loop ends using break.</p><h3>3.16.2 The continue Statement</h3><p>The continue statement is used to skip the remaining steps in the current iteration and start with the next loop iteration. The control goes from the continue statement to the step value (increment or decrement), if any.</p><p>+-----------------------------------------------------------------------+
| String[] programmers = {&quot;Adrian&quot;, &quot;Paul&quot;, &quot;John&quot;,             |
| &quot;Harry&quot;};\                                                          |
| //john is not printed out\                                            |
| for (String name : programmers) {\                                    |
| if (name.equals(&quot;John&quot;)) continue;\                                 |
| System.out.println(name);\                                            |
| }                                                                     |
+-----------------------------------------------------------------------+</p><p>The continue statement can also make the control of the program shift to the step value (if any) of a named loop: Outer: // The name of the outermost loop is kept here as &#x27;Outer&#x27;</p><p>+-----------------------------------------------------------------------+
| for(int i = 0; i &lt; 5; ) {\                                           |
| for(int j = 0; j &lt; 5; j++) {\                                        |
| continue Outer;\                                                      |
| }\                                                                    |
| }                                                                     |
|                                                                       |
| It&#x27;s possible to break / continue to an outer loop by using label    |
| statements:                                                           |
|                                                                       |
| +------------------------------------------------------------------+  |
| | outerloop:\                                                      |  |
| | for(<!-- -->.<!-- -->..) {\                                                     |  |
| | innerloop:\                                                      |  |
| | for(<!-- -->.<!-- -->..) {\                                                     |  |
| | if(condition1)\                                                  |  |
| | break outerloop;\                                                |  |
| | if(condition2)\                                                  |  |
| | continue innerloop; // equivalent to: continue;\                 |  |
| | }\                                                               |  |
| | }                                                                |  |
| +------------------------------------------------------------------+  |
+-----------------------------------------------------------------------+</p><h3>3.16.3 The return Statement</h3><p>The last of the branching statements is the return statement. The return statement exits from the current method, and control flow returns to where the method was invoked. The return statement has two forms: one that returns a value, and one that doesn&#x27;t.</p><p><strong>return</strong> ++count;  </p><p>The data type of the returned value must match the type of the method&#x27;s declared return value. When a method is declared void, use the form of return that doesn&#x27;t return a value.</p><p><strong>return</strong>;  </p><h1>4 Classes and Objects</h1><h2>4.1 Classes</h2><h2>4.2 Declaring Classes</h2><p>Class declaration: the below is a minimal class declaration syntax.</p><p>class MyClass{</p><p>// field, constructor, and  // method declarations</p><p>}</p><p>A class can extend a superclass and implement functions of an interface in such cases the general syntax of declaration is.</p><p><strong>private class</strong> MyClass <strong>extends</strong> MySuperClass <strong>implements</strong> YourInterface { </p><p>// field, constructor, and // method declarations  </p><p>}</p><p>Class visibility to other classes in a package can be controlled my modifiers like public, private.   </p><p>In general, class declarations can include these components, in order:</p><ul><li><strong>Modifiers</strong> such as <em>public</em>, <em>private</em>, and a number of others.</li><li>The <strong>class name</strong>, with the initial letter capitalized by convention.</li><li>The name of the <strong>class&#x27;s parent</strong> (superclass), if any, preceded by the keyword <strong><em>extends</em></strong>. A class can only <em>extend</em> (subclass) <strong>one parent</strong>.</li><li>A comma-separated list of interfaces implemented by the <strong>class</strong>, if any, preceded by the keyword <strong><em>implements</em></strong>. A class can <em>implement</em> <strong>more than one interface</strong>.</li><li>The <strong>class body</strong>, surrounded by braces, {}.</li></ul><h2>4.3 Declaring Member/Class Variables or Fields</h2><p>Field declarations are composed of three components, in order:</p><ul><li>Zero or more <strong>modifiers</strong>, such as public or private.</li><li>The field&#x27;s <strong>type</strong>.</li><li>The field&#x27;s <strong>name</strong>.</li></ul><p><strong>public</strong> <strong>int</strong> cadence; </p><h3>4.3.1 Access Modifiers</h3><p>The first (left-most) modifier used lets you control what other classes have access to a member field.</p><ul><li>public modifier---the <strong>field is accessible from all classes</strong>.</li><li>private modifier---the <strong>field is accessible only within its own class</strong>.</li></ul><p>In the spirit of <strong>encapsulation</strong>, it is common to make <strong>fields private</strong> and use getters and setters for reading and writing values to the field.</p><p><strong>public</strong> <strong>class</strong> Bicycle {  </p><p>    <strong>private</strong> <strong>int</strong> cadence;  </p><p>// other fields, constructor</p><p>// getters for accessing private methods</p><p>    <strong>public</strong> <strong>int</strong> getCadence() {  </p><p>        <strong>return</strong> cadence;  </p><p>    }  </p><p>    <strong>public</strong> <strong>void</strong> setCadence(<strong>int</strong> newValue) {  </p><p>        cadence = newValue;  </p><p>    }  </p><p>}  </p><h2>4.4 Defining Methods</h2><p>Here is an example of a typical method declaration:</p><ol><li><strong>public</strong> <strong>double</strong> calculateAnswer(<strong>double</strong> wingSpan, <strong>int</strong> numberOfEngines, <strong>double</strong> length, <strong>double</strong> grossTons) { //do the calculation here  </li><li>}  </li></ol><p>The only required elements of a method declaration are the method&#x27;s return type, name, a pair of parentheses, (), and a body between braces, {}.</p><p>More generally, method declarations have six components, in order:</p><ul><li><strong>Modifiers</strong>---such as public, private<!-- -->.<!-- -->..</li><li>The <strong>return type</strong>---the data type of the value returned by the method, or void if the method does not return a value.</li><li>The <strong>method name</strong>---the rules for field names apply to method names as well, but the convention is a little different.</li><li>The <strong>parameter list in parenthesis</strong>---a comma-delimited list of input parameters, preceded by their data types, enclosed by parentheses, (). If there are no parameters, you must use empty parentheses.</li><li><strong>An exception list</strong>.</li><li>The method <strong>body, enclosed between braces</strong>---the method&#x27;s code, including the declaration of local variables, goes here.</li></ul><h3>4.4.2 Overloading Methods</h3><p>Java can <strong>distinguish between methods with different <em>method signatures</em></strong>. This means that methods within a class can have the same name and differentiated by the <strong>number and the type of the arguments</strong> passed into the method.</p><p><strong>public</strong> <strong>class</strong> DataArtist {<!-- -->.<!-- -->..<strong>public</strong> <strong>void</strong> draw(String s) {<!-- -->.<!-- -->..  </p><p>    }  </p><p>//overloaded draw methods</p><p>    <strong>public</strong> <strong>void</strong> draw(<strong>int</strong> i) {<!-- -->.<!-- -->..  </p><p>    }  </p><p>    <strong>public</strong> <strong>void</strong> draw(<strong>double</strong> f) {<!-- -->.<!-- -->..  </p><p>    }  </p><p>    <strong>public</strong> <strong>void</strong> draw(<strong>int</strong> i, <strong>double</strong> f) {<!-- -->.<!-- -->..  </p><p>    }  </p><p>}  </p><p>The compiler <strong>does not consider return type</strong> when differentiating methods, so you cannot declare two methods with the same signature even if they have a different return type</p><h2>4.5 Providing Constructors for Your Classes</h2><p>A class contains constructors that are invoked to <strong>create objects from the class blueprint</strong>.</p><p><strong>public</strong> Bicycle(<strong>int</strong> startCadence, <strong>int</strong> startSpeed, <strong>int</strong> startGear) {  </p><p>    gear = startGear;  </p><p>    cadence = startCadence;  </p><p>    speed = startSpeed;  </p><p>}  </p><p>Bicycle myBike = <strong>new</strong> Bicycle(30, 0, 8);</p><ul><li>Constructor declarations look like method declarations---except that they use the <strong>name of the class</strong> and <strong>have no return type</strong>.</li><li>A constructor can take arguments to initialize its class fields or can do a default initialization to a specific set of values.</li><li>Constructor <strong>overloading</strong> is supported.</li></ul><p><strong>public</strong> Bicycle() {  </p><p>    gear = 1;  </p><p>    cadence = 10;  </p><p>    speed = 0;  </p><p>} </p><ul><li>You don&#x27;t have to provide any constructors for your class, but you must be careful when doing this. The <strong>compiler automatically provides a no-argument, default constructor for any class without constructors</strong>. This default constructor will call the <strong>no-argument constructor of the superclass</strong>. <strong>If your class has no explicit superclass</strong>, then it has an implicit superclass of Object, which <em>does</em> have a no-argument constructor.</li><li>In case of <strong>private constructors</strong>, the class is responsible for creating objects and supplying them to the outside world.</li></ul><h2>4.6 Passing Information to a Method or a Constructor</h2><p><em>Parameters</em> refers to the list of variables in a method declaration. <em>Arguments</em> are the actual values that are passed in when the method is invoked. When you invoke a method, the arguments used must match the declaration&#x27;s parameters in type and order.</p><h3>4.6.1 Parameter Types</h3><p>Parameter type can be any data type primitive and reference types.</p><p><strong>public</strong> Polygon polygonFrom(Point[] corners) { </p><p>// method body goes here  </p><p>}  </p><p><strong>Note:</strong> If you want to pass a method into a method, then use a <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html"><strong>lambda expression</strong></a> or a <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html"><strong>method reference</strong></a>.</p><h3>4.6.2 Arbitrary Number of Arguments</h3><p>You can use a construct called <em>varargs</em> to pass an arbitrary number of values to a method. You use varargs when you don&#x27;t know how many of a particular type of argument will be passed to the method. It&#x27;s a shortcut to creating an array manually (the previous method could have used varargs rather than an array).</p><p>To use varargs, you follow the type of the last parameter by an ellipsis (three dots, <!-- -->.<!-- -->..), then a space, and the parameter name. The method can then be called with any number of that parameter, including none.</p><ol><li><strong>public</strong> Polygon polygonFrom(Point<!-- -->.<!-- -->..corners) {  </li><li>    <strong>int</strong> numberOfSides = corners.length;  </li><li>    <strong>double</strong> squareOfSide1, lengthOfSide1;  </li><li>    squareOfSide1 = (corners<!-- -->[1]<!-- -->.x - corners<!-- -->[0]<!-- -->.x) <!-- -->*<!-- --> (corners<!-- -->[1]<!-- -->.x - corners<!-- -->[0]<!-- -->.x) + (corners<!-- -->[1]<!-- -->.y - corners<!-- -->[0]<!-- -->.y) <!-- -->*<!-- --> (corners<!-- -->[1]<!-- -->.y - corners<!-- -->[0]<!-- -->.y);  </li><li>    lengthOfSide1 = Math.sqrt(squareOfSide1); // more method body code follows that creates and returns a  // polygon connecting the Points  </li><li>}  </li></ol><p>You can see that, inside the method, corners is treated like an array. The method can be called either with an array or with a sequence of arguments. The code in the method body will treat the parameter as an array in either case.</p><p>You will most commonly see varargs with the printing methods; for example, this printf method:</p><ol><li><strong>public</strong> PrintStream printf(String format, Object<!-- -->.<!-- -->..args)  </li></ol><p>allows you to print an arbitrary number of objects. It can be called like this:</p><ol><li>System.out.printf(&quot;%s: %d, %s%n&quot;, name, idnum, address);  </li></ol><p>or like this</p><ol><li>System.out.printf(&quot;%s: %d, %s, %s, %s%n&quot;, name, idnum, address, phone, email);  </li></ol><p>or with yet a different number of arguments.</p><p>Note: Finally, the implementation of such methods must take care of the fact that it may be called with an empty vararg! If you want to impose at least one argument, then you have to use an ugly trick such as:</p><ol><li><strong>void</strong> f(T arg1, T<!-- -->.<!-- -->..args) {<!-- -->.<!-- -->.. }  </li></ol><h3>4.6.3 Parameter Names</h3><p>When you declare a parameter to a method or a constructor, you provide a name for that parameter. This name is used within the method body to refer to the passed-in argument.</p><p>The name of a parameter must be unique in its scope. It cannot be the same as the name of another parameter for the same method or constructor, and it cannot be the name of a local variable within the method or constructor.</p><p>A parameter can have the same name as one of the class&#x27;s fields. If this is the case, the <strong>parameter is said to <em>shadow</em> the field</strong>. Shadowing fields can make your code difficult to read and is conventionally used only within constructors and methods that set a particular field. For example, consider the following Circle class and its setOrigin method:</p><ol><li><strong>public</strong> <strong>class</strong> Circle {  </li><li>    <strong>private</strong> <strong>int</strong> x, y, radius;  </li><li>    <strong>public</strong> <strong>void</strong> setOrigin(<strong>int</strong> x, <strong>int</strong> y) {<!-- -->.<!-- -->..  </li><li>    }  </li><li>}  </li></ol><p>The Circle class has three fields: x, y, and radius. The setOrigin method has two parameters, each of which has the same name as one of the fields. Each method parameter shadows the field that shares its name. So using the simple names x or y within the body of the method refers to the parameter, <em>not</em> to the field. To access the field, you must use a qualified name.</p><h3>4.6.4 Passing Primitive Data Type Arguments</h3><p>Primitive arguments, such as an int or a double, are <strong>passed into methods <em>by value</em></strong>. This means that any changes to the values of the parameters exist only within the scope of the method. When the method returns, the parameters are gone and any changes to them are lost. Here is an example:</p><ol><li><strong>public</strong> <strong>class</strong> PassPrimitiveByValue {  </li><li>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li><li>            <strong>int</strong> x = 3; // invoke passMethod() with  // x as argument  </li><li>            passMethod(x); // print x to see if its  // value has changed  </li><li>            System.out.println(&quot;After invoking passMethod, x = &quot; + x);  </li><li>        } // change parameter in passMethod()  </li><li>    <strong>public</strong> <strong>static</strong> <strong>void</strong> passMethod(<strong>int</strong> p) {  </li><li>        p = 10;  </li><li>    }  </li><li>}  </li><li>When you run <strong>this</strong> program, the output is: After invoking passMethod, x = 3  </li></ol><h3>4.6.5 Passing Reference Data Type Arguments</h3><p>Reference data type parameters, such as <strong>objects, are also passed into methods <em>by value</em></strong>. This means that when the method returns, the passed-in reference still references the same object as before. <em>However</em>, the values of the object&#x27;s fields <em>can</em> be changed in the method, if they have the proper access level.</p><p>For example, consider a method in an arbitrary class that moves Circle objects:</p><ol><li><strong>public</strong> <strong>void</strong> moveCircle(Circle circle, <strong>int</strong> deltaX, <strong>int</strong> deltaY) { // code to move origin of circle to x+deltaX, y+deltaY  </li><li>    circle.setX(circle.getX() + deltaX);  </li><li>    circle.setY(circle.getY() + deltaY); </li><li>// code to assign a new reference to circle, creates a new circle object (new reference) since its scope is confined to the method, the changes are lost.  </li><li>    circle = <strong>new</strong> Circle(0, 0);  </li><li>}  </li></ol><p>Let the method be invoked with these arguments:</p><ol><li>moveCircle(myCircle, 23, 56)  //There is no change in myCircle</li></ol><p>Inside the method, circle initially refers to myCircle. The method changes the x and y coordinates of the object that circle references (i.e., myCircle) by 23 and 56, respectively. These changes will persist when the method returns. Then circle is assigned a reference to a new Circle object with x = y = 0. This reassignment has no permanence, however, because the reference was passed in by value and cannot change. Within the method, the object pointed to by circle has changed, but, when the method returns, myCircle still references the same Circle object as before the method was called.</p><h2>4.7 Objects</h2><p>A typical Java program creates many objects, which as you know, interact by invoking methods. Through these object interactions, a program can carry out various tasks, such as implementing a GUI, running an animation, or sending and receiving information over a network. Once an object has completed the work for which it was created, its resources are recycled for use by other objects.</p><p>Here&#x27;s a small program, called <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/CreateObjectDemo.java">CreateObjectDemo</a>, that creates three objects: one <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Point.java">Point</a> object and two <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Rectangle.java">Rectangle</a> objects. You will need all three source files to compile this program.</p><ol><li><strong>public</strong> <strong>class</strong> CreateObjectDemo {  </li><li>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) { // Declare and create a point object and two rectangle objects.  </li><li>        Point originOne = <strong>new</strong> Point(23, 94);  </li><li>        Rectangle rectOne = <strong>new</strong> Rectangle(originOne, 100, 200);  </li><li>        Rectangle rectTwo = <strong>new</strong> Rectangle(50, 100); // display rectOne&#x27;s width, height, and area  </li><li>        System.out.println(&quot;Width of rectOne: &quot; + rectOne.width);  </li><li>        System.out.println(&quot;Height of rectOne: &quot; + rectOne.height);  </li><li>        System.out.println(&quot;Area of rectOne: &quot; + rectOne.getArea()); // set rectTwo&#x27;s position  </li><li>        rectTwo.origin = originOne; // display rectTwo&#x27;s position  </li><li>        System.out.println(&quot;X Position of rectTwo: &quot; + rectTwo.origin.x);  </li><li>        System.out.println(&quot;Y Position of rectTwo: &quot; + rectTwo.origin.y); // move rectTwo and display its new position  </li><li>        rectTwo.move(40, 72);  </li><li>        System.out.println(&quot;X Position of rectTwo: &quot; + rectTwo.origin.x);  </li><li>        System.out.println(&quot;Y Position of rectTwo: &quot; + rectTwo.origin.y);  </li><li>    }  </li><li>}  </li><li>This program creates, manipulates, and displays information about various objects.Here &#x27;s the output:  </li><li>Width of rectOne: 100 </li><li>Height of rectOne: 200 </li><li>Area of rectOne: 20000 </li><li>X Position of rectTwo: 23 </li><li>Y Position of rectTwo: 94 </li><li>X Position of rectTwo: 40 </li><li>Y Position of rectTwo: 72  </li></ol><h2>4.8 Creating Objects</h2><p>As you know, a class provides the blueprint for objects; you create an object from a class. Each of the following statements taken from the <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/CreateObjectDemo.java">CreateObjectDemo</a> program creates an object and assigns it to a variable:</p><ol><li>Point originOne = <strong>new</strong> Point(23, 94);  </li><li>Rectangle rectOne = <strong>new</strong> Rectangle(originOne, 100, 200);  </li><li>Rectangle rectTwo = <strong>new</strong> Rectangle(50, 100);  </li></ol><p>The first line creates an object of the <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Point.java">Point</a> class, and the second and third lines each create an object of the <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Rectangle.java">Rectangle</a> class.</p><p>Each of these statements has three parts (discussed in detail below):</p><ul><li><strong>Declaration</strong>: The code set in <strong>bold</strong> are all variable declarations that associate a variable name with an object type.</li><li><strong>Instantiation</strong>: The new keyword is a Java operator that creates the object.</li><li><strong>Initialization</strong>: The new operator is followed by a call to a constructor, which initializes the new object.</li></ul><h3>4.8.1 Declaring a Variable to Refer to an Object</h3><p>Previously, you learned that to declare a variable, you write:</p><ol><li>type name;  </li></ol><p>This notifies the compiler that you will use <em>name</em> to refer to data whose type is <em>type</em>. With a primitive variable, this declaration also reserves the proper amount of memory for the variable.</p><p>You can also declare a reference variable on its own line. For example:</p><ol><li>Point originOne;  </li></ol><p>If you declare originOne like this, its value will be undetermined until an object is actually created and assigned to it. <strong>Simply declaring a reference variable does not create an object</strong>. For that, you need to use the new operator, as described in the next section. You must assign an object to originOne before you use it in your code. Otherwise, you will get a compiler error.</p><p>A variable in this state, which currently references no object, can be illustrated as follows (the variable name, originOne, plus a reference pointing to nothing):</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8NAwAI1gLrHz8hFgAAAABJRU5ErkJggg==" alt="originOne is null."/></p><h3>4.8.2 Instantiating a Class</h3><p>The new operator instantiates a class by allocating memory for a new object and returning a reference to that memory. The <strong>new</strong> operator also invokes the object constructor.</p><p><strong>Note:</strong> The phrase &quot;instantiating a class&quot; means the same thing as &quot;creating an object.&quot; When you create an object, you are creating an &quot;instance&quot; of a class, therefore &quot;instantiating&quot; a class.</p><p>The new operator requires a single, postfix argument: a call to a constructor. The name of the constructor provides the name of the class to instantiate.</p><p>The new operator returns a reference to the object it created. This reference is usually assigned to a variable of the appropriate type, like:</p><ol><li>Point originOne = <strong>new</strong> Point(23, 94);  </li></ol><p>The reference returned by the new operator does not have to be assigned to a variable. It can also be used directly in an expression. For example:</p><ol><li><strong>int</strong> height = <strong>new</strong> Rectangle().height;  </li></ol><h3>4.8.3 Initializing an Object</h3><p>Here&#x27;s the code for the Point class:</p><ol><li><strong>public</strong> <strong>class</strong> Point {  </li><li>    <strong>public</strong> <strong>int</strong> x = 0;  </li><li>    <strong>public</strong> <strong>int</strong> y = 0; //constructor  </li><li>    <strong>public</strong> Point(<strong>int</strong> a, <strong>int</strong> b) {  </li><li>        x = a;  </li><li>        y = b;  </li><li>    }  </li><li>}  </li></ol><p>This class contains a single constructor. You can recognize a constructor because its declaration uses the same name as the class and it has no return type. The constructor in the Point class takes two integer arguments, as declared by the code (int a, int b). The following statement provides 23 and 94 as values for those arguments:</p><ol><li>Point originOne = <strong>new</strong> Point(23, 94);  </li></ol><p>The result of executing this statement can be illustrated in the next figure:</p><p>Here&#x27;s the code for the Rectangle class, which contains four constructors:<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8tAwAI2ALsRHigIwAAAABJRU5ErkJggg==" alt="originOne now points to a Point object."/></p><ol><li><strong>public</strong> <strong>class</strong> Rectangle {  </li><li>    <strong>public</strong> <strong>int</strong> width = 0;  </li><li>    <strong>public</strong> <strong>int</strong> height = 0;  </li><li>    <strong>public</strong> Point origin; // four constructors  </li><li>    <strong>public</strong> Rectangle() {  </li><li>        origin = <strong>new</strong> Point(0, 0);  </li><li>    }  </li><li>    <strong>public</strong> Rectangle(Point p) {  </li><li>        origin = p;  </li><li>    }  </li><li>    <strong>public</strong> Rectangle(<strong>int</strong> w, <strong>int</strong> h) {  </li><li>        origin = <strong>new</strong> Point(0, 0);  </li><li>        width = w;  </li><li>        height = h;  </li><li>    }  </li><li>    <strong>public</strong> Rectangle(Point p, <strong>int</strong> w, <strong>int</strong> h) {  </li><li>            origin = p;  </li><li>            width = w;  </li><li>            height = h;  </li><li>        } // a method for moving the rectangle  </li><li>    <strong>public</strong> <strong>void</strong> move(<strong>int</strong> x, <strong>int</strong> y) {  </li><li>            origin.x = x;  </li><li>            origin.y = y;  </li><li>        } // a method for computing the area of the rectangle  </li><li>    <strong>public</strong> <strong>int</strong> getArea() {  </li><li>        <strong>return</strong> width <!-- -->*<!-- --> height;  </li><li>    }  </li><li>}  </li></ol><p>Each constructor lets you provide initial values for the rectangle&#x27;s origin, width, and height, using both primitive and reference types. If a class has multiple constructors, they must have different signatures. The Java compiler differentiates the constructors based on the number and the type of the arguments. When the Java compiler encounters the following code, it knows to call the constructor in the Rectangle class that requires a Point argument followed by two integer arguments:</p><ol><li>Rectangle rectOne = <strong>new</strong> Rectangle(originOne, 100, 200);  </li></ol><p>This calls one of Rectangle&#x27;s constructors that initializes origin to originOne. Also, the constructor sets width to 100 and height to 200. Now there are two references to the same Point object---an object can have multiple references to it, as shown in the next figure:</p><p>The following line of code calls the Rectangle constructor that requires two integer arguments, which provide the initial values for width and height. If you inspect the code within the constructor, you will see that it creates a new Point object whose x and y values are initialized to 0:<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8OAwAItgLbQNnABwAAAABJRU5ErkJggg==" alt="Now the rectangle&#x27;s origin variable also points to the Point."/></p><ol><li>Rectangle rectTwo = <strong>new</strong> Rectangle(50, 100);  </li></ol><p>The Rectangle constructor used in the following statement doesn&#x27;t take any arguments, so it&#x27;s called a <em>no-argument constructor</em>:</p><ol><li>Rectangle rect = <strong>new</strong> Rectangle();  </li></ol><p>All classes have at least one constructor. <strong>If a class does not explicitly declare any, the Java compiler automatically provides a no-argument constructor, called the <em>default constructor</em></strong>. This default constructor <strong>calls the class parent&#x27;s no-argument constructor, or the Object constructor if the class has no other parent</strong>. If the parent has no constructor (Object does have one), the compiler will reject the program.</p><h2>4.9 Using Objects</h2><p>Once you&#x27;ve created an object, you probably want to use it for something. You may need to use the value of one of its fields, change one of its fields, or call one of its methods to perform an action.</p><h3>4.9.1 Referencing an Object&#x27;s Fields</h3><p>Object fields are accessed by their name. You must use a name that is unambiguous.</p><p>You may use a simple name for a field within its own class. For example, we can add a statement <em>within</em> the Rectangle class that prints the width and height:</p><ol><li>System.out.println(&quot;Width and height are: &quot; + width + &quot;, &quot; + height);  </li></ol><p>In this case, width and height are simple names.</p><p>Code that is outside the object&#x27;s class must use an object reference or expression, followed by the dot (.) operator, followed by a simple field name, as in:</p><ol><li>objectReference.fieldName  </li></ol><p>For example, the code in the CreateObjectDemo class is outside the code for the Rectangle class. So to refer to the origin, width, and height fields within the Rectangle object named rectOne, the CreateObjectDemo class must use the names rectOne.origin, rectOne.width, and rectOne.height, respectively. The program uses two of these names to display the width and the height of rectOne:</p><ol><li>System.out.println(&quot;Width of rectOne: &quot; + rectOne.width);  </li><li>System.out.println(&quot;Height of rectOne: &quot; + rectOne.height);  </li></ol><p>Attempting to use the simple names width and height from the code in the CreateObjectDemo class doesn&#x27;t make sense --- those fields exist only within an object --- and results in a compiler error.</p><p>Later, the program uses similar code to display information about rectTwo. Objects of the same type have their own copy of the same instance fields. Thus, each Rectangle object has fields named origin, width, and height. When you access an instance field through an object reference, you reference that particular object&#x27;s field. The two objects rectOne and rectTwo in the CreateObjectDemoprogram have different origin, width, and height fields.</p><p>To <strong>access a field, you can use a named reference to an object</strong>, as in the previous examples, or you can use any expression that returns an object reference. Recall that the new operator returns a reference to an object. So you could use the value returned from new to access a new object&#x27;s fields:</p><ol><li><strong>int</strong> height = <strong>new</strong> Rectangle().height;  </li></ol><p>This statement creates a new Rectangle object and immediately gets its height. In essence, the statement calculates the default height of a Rectangle. Note that after this statement has been executed, the program no longer has a reference to the created Rectangle, because the program never stored the reference anywhere. The object is unreferenced, and its resources are free to be recycled by the Java Virtual Machine.[]{#bookmark=id.upglbi}</p><h3>4.9.2 Calling an Object&#x27;s Methods</h3><p>You also use an object reference to invoke an object&#x27;s method. You append the method&#x27;s simple name to the object reference, with an intervening dot operator (.). Also, you provide, within enclosing parentheses, any arguments to the method. If the method does not require any arguments, use empty parentheses.</p><ol><li>objectReference.methodName(argumentList);  </li><li>objectReference.methodName();  </li></ol><p>The Rectangle class has two methods: getArea() to compute the rectangle&#x27;s area and move() to change the rectangle&#x27;s origin. Here&#x27;s the CreateObjectDemo code that invokes these two methods:</p><ol><li>System.out.println(&quot;Area of rectOne: &quot; + rectOne.getArea());<!-- -->.<!-- -->..rectTwo.move(40, 72);  </li></ol><p>The first statement invokes rectOne&#x27;s getArea() method and displays the results. The second line moves rectTwo because the move() method assigns new values to the object&#x27;s origin.x and origin.y.</p><p>As with instance fields, <em>objectReference</em> must be a reference to an object. You can use a variable name, but you also can use any expression that returns an object reference. The new operator returns an object reference, so you can use the value returned from new to invoke a new object&#x27;s methods:</p><ol><li><strong>new</strong> Rectangle(100, 50).getArea()  </li></ol><p>The expression new Rectangle(100, 50) returns an object reference that refers to a Rectangle object. As shown, you can use the dot notation to invoke the new Rectangle&#x27;s getArea() method to compute the area of the new rectangle.</p><p>Some methods, such as getArea(), return a value. For methods that return a value, you can use the method invocation in expressions. You can assign the return value to a variable, use it to make decisions, or control a loop. This code assigns the value returned by getArea() to the variable areaOfRectangle:</p><ol><li><strong>int</strong> areaOfRectangle = <strong>new</strong> Rectangle(100, 50).getArea();  </li></ol><p>Remember, invoking a method on a particular object is the same as sending a message to that object. In this case, the object that getArea() is invoked on is the rectangle returned by the constructor.</p><h3>4.9.3 The Garbage Collector</h3><p>Some object-oriented languages require that you keep track of all the objects you create and that you explicitly destroy them when they are no longer needed. Managing memory explicitly is tedious and error-prone. The Java platform allows you to create as many objects as you want (limited, of course, by what your system can handle), and you don&#x27;t have to worry about destroying them. The Java runtime environment deletes objects when it determines that they are no longer being used. This process is called <em>garbage collection</em>.</p><p>An object is eligible for garbage collection when there are no more references to that object. References that are held in a variable are usually dropped when the variable goes out of scope. Or, you can explicitly drop an object reference by setting the variable to the special value null. Remember that a program can have multiple references to the same object; all references to an object must be dropped before the object is eligible for garbage collection.</p><p>The Java runtime environment has a garbage collector that periodically frees the memory used by objects that are no longer referenced. The garbage collector does its job automatically when it determines that the time is right.</p><h2>4.10 The finalize( ) Method</h2><p>Sometimes an object will need to perform some action when it is destroyed. For example, if an object is holding some non-Java resource such as a file handle or character font, then you might want to make sure these resources are freed before an object is destroyed. To handle such situations, Java provides a mechanism called <em>finalization</em>. By using finalization, you can define specific actions that will occur when an object is just about to be reclaimed by the garbage collector. To add a finalizer to a class, you simply define the <strong>finalize( )</strong> method. The Java run time calls that method whenever it is about to recycle an object of that class. Inside the <strong>finalize( )</strong> method, you will specify those actions that must be performed before an object is destroyed. The garbage collector runs periodically, checking for objects that are no longer referenced by any running state or indirectly through other referenced objects. Right before an asset is freed, the Java run time calls the <strong>finalize( )</strong> method on the object. The <strong>finalize( )</strong> method has this general form:</p><ol><li><strong>protected</strong> <strong>void</strong> finalize() { // finalization code here  </li><li>}  </li></ol><p>Here, the keyword <strong>protected</strong> is a specifier that limits access to <strong>finalize( )</strong>. It is important to understand that <strong>finalize( ) is only called just prior to garbage collection. It is not called when an object goes out-of-scope</strong>, for example. This means that you cannot know when---or even if---<strong>finalize( )</strong> will be executed. Therefore, <strong>your program should provide other means of releasing system resources, etc., used by the object. It must not rely on finalize( )</strong> for normal program operation.</p><h2>4.11 Returning a Value from a Method</h2><p>A method returns to the code that invoked it when it</p><ul><li>completes all the statements in the method,</li><li>reaches a return statement, or</li><li>throws an exception (covered later),</li></ul><p>whichever occurs first.</p><p>You declare a method&#x27;s return type in its method declaration. Within the body of the method, you use the return statement to return the value.</p><p>Any method declared void doesn&#x27;t return a value. It does not need to contain a return statement, but it may do so. In such a case, a return statement can be used to branch out of a control flow block and exit the method and is simply used like this:</p><ol><li><strong>return</strong>;  </li></ol><p>If you try to return a value from a method that is declared void, you will get a compiler error.</p><p>Any method that is not declared void must contain a return statement with a corresponding return value, like this:</p><ol><li><strong>return</strong> returnValue;  </li></ol><p>The data type of the return value must match the method&#x27;s declared return type; you can&#x27;t return an integer value from a method declared to return a boolean.</p><p>The getArea() method in the Rectangle <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Rectangle.java">Rectangle</a> class that was discussed in the sections on objects returns an integer:</p><ol><li>// a method for computing the area of the rectangle  </li><li><strong>public</strong> <strong>int</strong> getArea() {  </li><li>    <strong>return</strong> width <!-- -->*<!-- --> height;  </li><li>}  </li></ol><p>This method returns the integer that the expression width<!-- -->*<!-- -->height evaluates to.</p><p>The getArea method returns a primitive type. A method can also return a reference type. For example, in a program to manipulate Bicycle objects, we might have a method like this:</p><ol><li><strong>public</strong> Bicycle seeWhosFastest(Bicycle myBike, Bicycle yourBike, Environment env) {  </li><li>    Bicycle fastest; // code to calculate which bike is  // faster, given each bike&#x27;s gear  // and cadence and given the  // environment (terrain and wind)  </li><li>    <strong>return</strong> fastest;  </li><li>}  </li></ol><h3>4.11.1 Returning a Class or Interface</h3><p>If this section confuses you, skip it and return to it after you have finished the lesson on interfaces and inheritance.</p><p>When a method uses a class name as its return type, such as whosFastest does, the class of the type of the returned object must be either a subclass of, or the exact class of, the return type. Suppose that you have a class hierarchy in which ImaginaryNumber is a subclass of java.lang.Number, which is in turn a subclass of Object, as illustrated in the following figure.</p><p>Now suppose that you have a method declared to return a Number:<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8LAwAI5gLzS+hp6gAAAABJRU5ErkJggg==" alt="The class hierarchy for ImaginaryNumber"/></p><ol><li><strong>public</strong> Number returnANumber() {<!-- -->.<!-- -->..  </li><li>}  </li></ol><p>The returnANumber method can return an ImaginaryNumber but not an Object. ImaginaryNumber is a Number because it&#x27;s a subclass of Number. However, an Object is not necessarily a Number --- it could be a String or another type.</p><p>You can override a method and define it to return a subclass of the original method, like this:</p><ol><li><strong>public</strong> ImaginaryNumber returnANumber() {<!-- -->.<!-- -->..  </li><li>}  </li></ol><p>This technique, called <strong><em>covariant return type</em>, means that the return type is allowed to vary in the same direction as the subclass</strong>.</p><p><strong>Note:</strong> You also can use interface names as return types. In this case, the object returned must implement the specified interface.</p><h2>4.12 Using the this Keyword</h2><p>Within an instance method or a constructor, this is a reference to the <em>current object</em> --- the object whose method or constructor is being called. You can refer to any member of the current object from within an instance method or a constructor by using this.</p><h3>4.12.1 Using this with a Field</h3><p>The most common reason for using the this keyword is because a field is shadowed by a method or constructor parameter.</p><p>For example, the Point class was written like this</p><ol><li><strong>public</strong> <strong>class</strong> Point {  </li><li>    <strong>public</strong> <strong>int</strong> x = 0;  </li><li>    <strong>public</strong> <strong>int</strong> y = 0; //constructor  </li><li>    <strong>public</strong> Point(<strong>int</strong> a, <strong>int</strong> b) {  </li><li>        x = a;  </li><li>        y = b;  </li><li>    }  </li><li>}  </li></ol><p>but it could have been written like this:</p><ol><li><strong>public</strong> <strong>class</strong> Point {  </li><li>    <strong>public</strong> <strong>int</strong> x = 0;  </li><li>    <strong>public</strong> <strong>int</strong> y = 0; //constructor  </li><li>    <strong>public</strong> Point(<strong>int</strong> x, <strong>int</strong> y) {  </li><li>        <strong>this</strong>.x = x;  </li><li>        <strong>this</strong>.y = y;  </li><li>    }  </li><li>}  </li></ol><p>Each argument to the constructor shadows one of the object&#x27;s fields --- inside the constructor <strong>x</strong> is a local copy of the constructor&#x27;s first argument. To refer to the Point field <strong>x</strong>, the constructor must use <strong>this.x</strong>.</p><h3>4.12.2 Using this with a Constructor</h3><p>From within a constructor, you can also use the this keyword to call another constructor in the same class. Doing so is called an <strong><em>explicit constructor invocation</em></strong>. Here&#x27;s another Rectangle class, with a different implementation from the one in the <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/objects.html">Objects</a> section.</p><ol><li><strong>public</strong> <strong>class</strong> Rectangle {  </li><li>    <strong>private</strong> <strong>int</strong> x, y;  </li><li>    <strong>private</strong> <strong>int</strong> width, height;  </li><li>    <strong>public</strong> Rectangle() {  </li><li>        <strong>this</strong>(0, 0, 1, 1);  </li><li>    }  </li><li>    <strong>public</strong> Rectangle(<strong>int</strong> width, <strong>int</strong> height) {  </li><li>        <strong>this</strong>(0, 0, width, height);  </li><li>    }  </li><li>    <strong>public</strong> Rectangle(<strong>int</strong> x, <strong>int</strong> y, <strong>int</strong> width, <strong>int</strong> height) {  </li><li>        <strong>this</strong>.x = x;  </li><li>        <strong>this</strong>.y = y;  </li><li>        <strong>this</strong>.width = width;  </li><li>        <strong>this</strong>.height = height;  </li><li>    }<!-- -->.<!-- -->..  </li><li>}  </li></ol><p>This class contains a set of constructors. Each constructor initializes some or all of the rectangle&#x27;s member variables. The constructors provide a default value for any member variable whose initial value is not provided by an argument. For example, the no-argument constructor creates a 1x1 Rectangle at coordinates 0,0. The two-argument constructor calls the four-argument constructor, passing in the width and height but always using the 0,0 coordinates. As before, the compiler determines which constructor to call, based on the number and the type of arguments.</p><p>If present, the invocation of another constructor must be the first line in the constructor.</p><h2>4.13 Controlling Access to Members of a Class</h2><p>Access level modifiers determine whether other classes can use a particular field or invoke a particular method. There are two levels of access control:</p><ul><li>At the top level---public, or <em>package-private</em> (no explicit modifier).</li><li>At the member level---public, private, protected, or <em>package-private</em> (no explicit modifier).</li></ul><p><a href="https://stackoverflow.com/questions/1913863/java-why-can-we-define-a-top-level-class-as-private">https://stackoverflow.com/questions/1913863/java-why-can-we-define-a-top-level-class-as-private</a></p><p>A class may be declared with the modifier public, in which case that class is visible to all classes everywhere. If a class has no modifier (the default, also known as <em>package-private</em>), it is visible only within its own package (packages are named groups of related classes)</p><p>At the member level, you can also use the public modifier or no modifier (<em>package-private</em>) just as with top-level classes, and with the same meaning. For members, there are two additional access modifiers: private and protected. The private modifier specifies that the member can only be accessed in its own class. The protected modifier specifies that the member can only be accessed within its own package (as with <em>package-private</em>) and, in addition, by a subclass of its class in another package.</p><p>The following table shows the access to members permitted by each modifier.</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Access Levels</td><td></td><td></td><td></td><td></td></tr><tr><td>Modifier</td><td><strong>Class</strong></td><td><strong>Package</strong></td><td><strong>Subclass</strong></td><td><strong>World</strong></td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td><em>no modifier</em></td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>private</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><p>The first data column indicates whether the class itself has access to the member defined by the access level. As you can see, a class always has access to its own members. The second column indicates whether classes in the same package as the class (regardless of their parentage) have access to the member. The third column indicates whether subclasses of the class declared outside this package have access to the member. The fourth column indicates whether all classes have access to the member.</p><p>Access levels affect you in two ways. First, when you use classes that come from another source, such as the classes in the Java platform, access levels determine which members of those classes your own classes can use. Second, when you write a class, you need to decide what access level every member variable and every method in your class should have.</p><p>Let&#x27;s look at a collection of classes and see how access levels affect visibility. The following figure shows the four classes in this example and how they are related.</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Visibility</td><td></td><td></td><td></td><td></td></tr><tr><td>Modifier</td><td><strong>Alpha</strong></td><td><strong>Beta</strong></td><td><strong>Alphasub</strong></td><td><strong>Gamma</strong></td></tr><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td><em>no modifier</em></td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>private</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//81AwAI1ALq8DAu2wAAAABJRU5ErkJggg==" alt="Classes and Packages of the Example Used to Illustrate Access Levels"/></p><p><strong>Tips on Choosing an Access Level:</strong> </p><p>If other programmers use your class, you want to ensure that errors from misuse cannot happen. Access levels can help you do this.</p><ul><li>Use the most restrictive access level that makes sense for a particular member. Use private unless you have a good reason not to.</li><li>Avoid public fields except for constants. Public fields tend to link you to a particular implementation and limit your flexibility in changing your code.</li></ul><h2>4.14 Understanding Class Members</h2><p>In this section, we discuss the use of the static keyword to create fields and methods that belong to the class, rather than to an instance of the class.</p><h3>4.14.1 Class Variables</h3><p>When a number of objects are created from the same class blueprint, they each have their own distinct copies of <em>instance variables</em>. In the case of the Bicycle class, the instance variables are cadence, gear, and speed. Each Bicycle object has its own values for these variables, stored in different memory locations.</p><p>Sometimes, you want to have variables that are common to all objects. This is accomplished with the static modifier. Fields that have the static modifier in their declaration are called <em>static fields</em> or <em>class variables</em>. They are associated with the class, rather than with any object. Every instance of the class shares a class variable, which is in one fixed location in memory. Any object can change the value of a class variable, but class variables can also be manipulated without creating an instance of the class.</p><p>For example, suppose you want to create a number of Bicycle objects and assign each a serial number, beginning with 1 for the first object. This ID number is unique to each object and is therefore an instance variable. At the same time, you need a field to keep track of how many Bicycle objects have been created so that you know what ID to assign to the next one. Such a field is not related to any individual object, but to the class as a whole. For this you need a class variable, numberOfBicycles, as follows:</p><ol><li><strong>public</strong> <strong>class</strong> Bicycle {  </li><li>    <strong>private</strong> <strong>int</strong> cadence;  </li><li>    <strong>private</strong> <strong>int</strong> gear;  </li><li>    <strong>private</strong> <strong>int</strong> speed; // add an instance variable for the object ID  </li><li>    <strong>private</strong> <strong>int</strong> id; // add a class variable for the // number of Bicycle objects instantiated  </li><li>    <strong>private</strong> <strong>static</strong> <strong>int</strong> numberOfBicycles = 0;<!-- -->.<!-- -->..  </li><li>}  </li></ol><p>Class variables are referenced by the class name itself, as in</p><ol><li>Bicycle.numberOfBicycles  </li></ol><p>This makes it clear that they are class variables.</p><p><strong>Note:</strong> You can also refer to static fields with an object reference like myBike.numberOfBicycles but this is discouraged because it does not make it clear that they are class variables.</p><p>You can use the Bicycle constructor to set the id instance variable and increment the numberOfBicycles class variable:</p><ol><li><strong>public</strong> <strong>class</strong> Bicycle {  </li><li>    <strong>private</strong> <strong>int</strong> cadence;  </li><li>    <strong>private</strong> <strong>int</strong> gear;  </li><li>    <strong>private</strong> <strong>int</strong> speed;  </li><li>    <strong>private</strong> <strong>int</strong> id;  </li><li>    <strong>private</strong> <strong>static</strong> <strong>int</strong> numberOfBicycles = 0;  </li><li>    <strong>public</strong> Bicycle(<strong>int</strong> startCadence, <strong>int</strong> startSpeed, <strong>int</strong> startGear) {  </li><li>            gear = startGear;  </li><li>            cadence = startCadence;  </li><li>            speed = startSpeed; // increment number of Bicycles // and assign ID number  </li><li>            id = ++numberOfBicycles;  </li><li>        } // new method to return the ID instance variable  </li><li>    <strong>public</strong> <strong>int</strong> getID() {  </li><li>        <strong>return</strong> id;  </li><li>    }<!-- -->.<!-- -->..  </li><li>}  </li></ol><h3>4.14.2 Class Methods</h3><p>The Java programming language supports static methods as well as static variables. Static methods, which have the static modifier in their declarations, should be invoked with the class name, without the need for creating an instance of the class, as in</p><ol><li>ClassName.methodName(args)  </li></ol><p><strong>Note:</strong> You can also refer to static methods with an object reference like instanceName.methodName(args) but this is discouraged because it does not make it clear that they are class methods.</p><p>A common use for static methods is to access static fields. For example, we could add a static method to the Bicycle class to access the numberOfBicycles static field:</p><ol><li><strong>public</strong> <strong>static</strong> <strong>int</strong> getNumberOfBicycles() {  </li><li>    <strong>return</strong> numberOfBicycles;  </li><li>}  </li></ol><p>Not all combinations of instance and class variables and methods are allowed:</p><ul><li>Instance methods can access instance variables and instance methods directly.</li><li>Instance methods can access class variables and class methods directly.</li><li>Class methods can access class variables and class methods directly.</li><li>Class methods <strong><em>cannot</em></strong> access instance variables or instance methods directly---they must use an object reference. Also, class methods cannot use the this keyword as there is no instance for this to refer to.</li></ul><h3>4.14.3 Constants</h3><p>The <strong>static modifier, in combination with the final modifier, is also used to define constants</strong>. The final modifier indicates that the value of this field cannot change.</p><p>For example, the following variable declaration defines a constant named PI, whose value is an approximation of pi (the ratio of the circumference of a circle to its diameter):</p><ol><li><strong>static</strong> <strong>final</strong> <strong>double</strong> PI = 3.141592653589793;  </li></ol><p>Constants defined in this way cannot be reassigned, and it is a compile-time error if your program tries to do so. By convention, the names of constant values are spelled in uppercase letters. If the name is composed of more than one word, the words are separated by an underscore (<!-- -->_<!-- -->).</p><p><strong>Note:</strong> If a primitive type or a string is defined as a constant and the value is known at compile time, the compiler replaces the constant name everywhere in the code with its value. This is called a <em>compile-time constant</em>. If the value of the constant in the outside world changes (for example, if it is legislated that pi actually should be 3.975), you will need to recompile any classes that use this constant to get the current value.</p><h3>4.14.4 The Bicycle Class</h3><p>After all the modifications made in this section, the Bicycle class is now:</p><ol><li><strong>public</strong> <strong>class</strong> Bicycle {  </li><li>    <strong>private</strong> <strong>int</strong> cadence;  </li><li>    <strong>private</strong> <strong>int</strong> gear;  </li><li>    <strong>private</strong> <strong>int</strong> speed;  </li><li>    <strong>private</strong> <strong>int</strong> id;  </li><li>    <strong>private</strong> <strong>static</strong> <strong>int</strong> numberOfBicycles = 0;  </li><li>    <strong>public</strong> Bicycle(<strong>int</strong> startCadence, <strong>int</strong> startSpeed, <strong>int</strong> startGear) {  </li><li>        gear = startGear;  </li><li>        cadence = startCadence;  </li><li>        speed = startSpeed;  </li><li>        id = ++numberOfBicycles;  </li><li>    }  </li><li>    <strong>public</strong> <strong>int</strong> getID() {  </li><li>        <strong>return</strong> id;  </li><li>    }  </li><li>    <strong>public</strong> <strong>static</strong> <strong>int</strong> getNumberOfBicycles() {  </li><li>        <strong>return</strong> numberOfBicycles;  </li><li>    }  </li><li>    <strong>public</strong> <strong>int</strong> getCadence() {  </li><li>        <strong>return</strong> cadence;  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> setCadence(<strong>int</strong> newValue) {  </li><li>        cadence = newValue;  </li><li>    }  </li><li>    <strong>public</strong> <strong>int</strong> getGear() {  </li><li>        <strong>return</strong> gear;  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> setGear(<strong>int</strong> newValue) {  </li><li>        gear = newValue;  </li><li>    }  </li><li>    <strong>public</strong> <strong>int</strong> getSpeed() {  </li><li>        <strong>return</strong> speed;  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> applyBrake(<strong>int</strong> decrement) {  </li><li>        speed -= decrement;  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> speedUp(<strong>int</strong> increment) {  </li><li>        speed += increment;  </li><li>    }  </li><li>}  </li></ol><h2>4.15 Initializing Fields</h2><p>As you have seen, you can often provide an initial value for a field in its declaration:</p><ol><li><strong>public</strong> <strong>class</strong> BedAndBreakfast { // initialize to 10  </li><li>    <strong>public</strong> <strong>static</strong> <strong>int</strong> capacity = 10; // initialize to false  </li><li>    <strong>private</strong> <strong>boolean</strong> full = <strong>false</strong>;  </li><li>}  </li></ol><p>This works well when the initialization value is available and the initialization can be put on one line. However, this form of initialization has limitations because of its simplicity. If initialization requires some logic (for example, error handling or a for loop to fill a complex array), simple assignment is inadequate. Instance variables can be initialized in constructors, where error handling or other logic can be used. To provide the same capability for class variables, the Java programming language includes <em>static initialization blocks</em>.</p><p><strong>Note:</strong> It is not necessary to declare fields at the beginning of the class definition, although this is the most common practice. It is only necessary that they be declared and initialized before they are used.</p><h3>4.15.1 Static Initialization Blocks</h3><p>A <em>static initialization block</em> is a normal block of code enclosed in braces, { }, and preceded by the static keyword. Here is an example:</p><ol><li><strong>static</strong> { // whatever code is needed for initialization goes here  </li><li>}  </li></ol><p>A class can have any number of static initialization blocks, and they can appear anywhere in the class body. The runtime system guarantees that static initialization blocks are called in the order that they appear in the source code.</p><p>There is an alternative to static blocks --- you can write a private static method:</p><ol><li><strong>class</strong> Whatever {  </li><li>    <strong>public</strong> <strong>static</strong> varType myVar = initializeClassVariable();  </li><li>    <strong>private</strong> <strong>static</strong> varType initializeClassVariable() { // initialization code goes here  </li><li>    }  </li><li>}  </li></ol><p>The advantage of private static methods is that they can be reused later if you need to reinitialize the class variable.</p><h3>4.15.2 Initializing Instance Members</h3><p>Normally, you would put code to initialize an instance variable in a constructor. There are two alternatives to using a constructor to initialize instance variables: initializer blocks and final methods.</p><p>Initializer blocks for instance variables look just like static initializer blocks, but without the static keyword:</p><ol><li>{ // whatever code is needed for initialization goes here  </li><li>}  </li></ol><p>The Java compiler copies initializer blocks into every constructor. Therefore, this approach can be used to share a block of code between multiple constructors.</p><p><strong>A <em>final method</em> cannot be overridden in a subclass</strong>. Here is an example of using a final method for initializing an instance variable:</p><ol><li><strong>class</strong> Whatever {  </li><li>    <strong>private</strong> varType myVar = initializeInstanceVariable();  </li><li>    <strong>protected</strong> <strong>final</strong> varType initializeInstanceVariable() { // initialization code goes here  </li><li>    }  </li><li>}  </li></ol><p>This is especially useful if <strong>subclasses might want to reuse the initialization method</strong>. The method is final because calling non-final methods during instance initialization can cause problems.</p><h2>4.16 Nested Classes</h2><p>The Java programming language allows you to define a class within another class. Such a class is called a <em>nested class</em> and is illustrated here:</p><ol><li><strong>class</strong> OuterClass {<!-- -->.<!-- -->..</li><li><strong>class</strong> NestedClass {<!-- -->.<!-- -->..  </li><li>    }  </li><li>}  </li></ol><p><strong>Terminology:</strong> Nested classes are divided into two categories: static and non-static. Nested classes that are declared static are called <em>static nested classes</em>. Non-static nested classes are called <em>inner classes</em>.</p><ol><li><strong>class</strong> OuterClass {<!-- -->.<!-- -->..<strong>static</strong> <strong>class</strong> StaticNestedClass {<!-- -->.<!-- -->..  </li><li>    }  </li><li>    <strong>class</strong> InnerClass {<!-- -->.<!-- -->..  </li><li>    }  </li><li>}  </li></ol><p>A nested class is a member of its enclosing class. <strong>Non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private. Static nested classes do not have access to other members of the enclosing class.</strong> As a member of the OuterClass, a nested class can be declared private, public, protected, or <em>package private</em>. (Recall that outer classes can only be declared public or <em>package private</em>.)</p><h3>4.16.1 Why Use Nested Classes?</h3><p>Compelling reasons for using nested classes include the following:</p><ul><li><strong>It is a way of logically grouping classes that are only used in one place</strong>: If a class is useful to only one other class, then it is logical to embed it in that class and keep the two together. Nesting such &quot;helper classes&quot; makes their package more streamlined.</li><li><strong>It increases encapsulation</strong>: Consider two top-level classes, A and B, where B needs access to members of A that would otherwise be declared private. By hiding class B within class A, A&#x27;s members can be declared private and B can access them. In addition, B itself can be hidden from the outside world.</li><li><strong>It can lead to more readable and maintainable code</strong>: Nesting small classes within top-level classes places the code closer to where it is used.</li></ul><h3>4.16.2 Static Nested Classes</h3><p>As with class methods and variables, a static nested class is associated with its outer class. And like static class methods, a static nested class cannot refer directly to instance variables or methods defined in its enclosing class: it can use them only through an object reference.</p><p><strong>Note:</strong> A static nested class interacts with the instance members of its outer class (and other classes) just like any other top-level class. In effect, a static nested class is behaviorally a top-level class that has been nested in another top-level class for packaging convenience.</p><p>Static nested classes are accessed using the enclosing class name:</p><ol><li>OuterClass.StaticNestedClass  </li></ol><p>For example, to create an object for the static nested class, use this syntax:</p><ol><li>OuterClass.StaticNestedClass nestedObject = <strong>new</strong> OuterClass.StaticNestedClass();  </li></ol><h3>4.16.3 Inner Classes</h3><p>As with instance methods and variables, an inner class is associated with an instance of its enclosing class and has direct access to that object&#x27;s methods and fields. Also, because an inner class is associated with an instance, it cannot define any static members itself.</p><p>Objects that are instances of an inner class exist <em>within</em> an instance of the outer class. Consider the following classes:</p><ol><li><strong>class</strong> OuterClass {</li><li>.<!-- -->..<strong>class</strong> InnerClass {<!-- -->.<!-- -->..  </li><li>    }  </li><li>}  </li></ol><p>An instance of InnerClass can exist only within an instance of OuterClass and has direct access to the methods and fields of its enclosing instance. To instantiate an inner class, you must first instantiate the outer class. Then, create the inner object within the outer object with this syntax:</p><ol><li>OuterClass.InnerClass innerObject = outerObject.<strong>new</strong> InnerClass();  </li></ol><p>There are two special kinds of inner classes: <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html">local classes</a> and <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">anonymous classes</a>.</p><h3>4.16.4 Shadowing</h3><p>If a declaration of a type (such as a member variable or a parameter name) in a particular scope (such as an inner class or a method definition) has the same name as another declaration in the enclosing scope, then the declaration <em>shadows</em> the declaration of the enclosing scope. You cannot refer to a shadowed declaration by its name alone. The following example, <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/ShadowTest.java">ShadowTest</a>, demonstrates this:</p><ol><li><strong>public</strong> <strong>class</strong> ShadowTest {  </li><li>    <strong>public</strong> <strong>int</strong> x = 0;  </li><li>    <strong>class</strong> FirstLevel {  </li><li>        <strong>public</strong> <strong>int</strong> x = 1;  </li><li>        <strong>void</strong> methodInFirstLevel(<strong>int</strong> x) {  </li><li>            System.out.println(&quot;x = &quot; + x);  </li><li>            System.out.println(&quot;this.x = &quot; + <strong>this</strong>.x);  </li><li>            System.out.println(&quot;ShadowTest.this.x = &quot; + ShadowTest.<strong>this</strong>.x);  </li><li>        }  </li><li>    }  </li><li>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String<!-- -->.<!-- -->..args) {  </li><li>        ShadowTest st = <strong>new</strong> ShadowTest();  </li><li>        ShadowTest.FirstLevel fl = st.<strong>new</strong> FirstLevel();  </li><li>        fl.methodInFirstLevel(23);  </li><li>    }  </li><li>}  </li></ol><p>The following is the output of this example:</p><ol><li>x = 23 <strong>this</strong>.x = 1 ShadowTest.<strong>this</strong>.x = 0  </li></ol><p>This example defines three variables named x: the member variable of the class ShadowTest, the member variable of the inner class FirstLevel, and the parameter in the method methodInFirstLevel. The variable x defined as a parameter of the method methodInFirstLevel shadows the variable of the inner class FirstLevel. Consequently, when you use the variable x in the method methodInFirstLevel, it refers to the method parameter. To refer to the member variable of the inner class FirstLevel, use the keyword this to represent the enclosing scope:</p><ol><li>System.out.println(&quot;this.x = &quot; + <strong>this</strong>.x);  </li></ol><p>Refer to member variables that enclose larger scopes by the class name to which they belong. For example, the following statement accesses the member variable of the class ShadowTest from the method methodInFirstLevel:</p><ol><li>System.out.println(&quot;ShadowTest.this.x = &quot; + ShadowTest.<strong>this</strong>.x);  </li></ol><h3>4.16.5 Serialization</h3><p><a href="https://docs.oracle.com/javase/tutorial/jndi/objects/serial.html">Serialization</a> of inner classes, including <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html">local</a> and <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">anonymous</a> classes, is strongly discouraged. When the Java compiler compiles certain constructs, such as inner classes, it creates <em>synthetic constructs</em>; these are classes, methods, fields, and other constructs that do not have a corresponding construct in the source code. Synthetic constructs enable Java compilers to implement new Java language features without changes to the JVM. However, synthetic constructs can vary among different Java compiler implementations, which means that .class files can vary among different implementations as well. Consequently, you may have compatibility issues if you serialize an inner class and then deserialize it with a different JRE implementation. See the section<a href="https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html#implcit_and_synthetic">Implicit and Synthetic Parameters</a> in the section <a href="https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html">Obtaining Names of Method Parameters</a> for more information about the synthetic constructs generated when an inner class is compiled.</p><h3>4.16.6 Inner Class Example</h3><p>To see an inner class in use, first consider an array. In the following example, you create an array, fill it with integer values, and then output only values of even indices of the array in ascending order.</p><p>The <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/DataStructure.java">DataStructure.java</a> example that follows consists of:</p><ul><li>The DataStructure outer class, which includes a constructor to create an instance of DataStructure containing an array filled with consecutive integer values (0, 1, 2, 3, and so on) and a method that prints elements of the array that have an even index value.</li><li>The EvenIterator inner class, which implements the DataStructureIterator interface, which extends the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">Iterator</a>&lt; <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html">Integer</a>&gt; interface. Iterators are used to step through a data structure and typically have methods to test for the last element, retrieve the current element, and move to the next element.</li><li>A main method that instantiates a DataStructure object (ds), then invokes the printEven method to print elements of the array arrayOfInts that have an even index value.</li></ul><pre><code class="language-java">1.  **public** **class** DataStructure { // Create an array  
2.      **private** **final** **static** **int** SIZE = 15;  
3.      **private** **int**[] arrayOfInts = **new** **int**[SIZE];  
4.      **public** DataStructure() { // fill the array with ascending integer values  
5.          **for** (**int** i = 0; i &lt; SIZE; i++) {  
6.              arrayOfInts[i] = i;  
7.          }  
8.      }  
9.      **public** **void** printEven() { // Print out values of even indices of the array  
10.         DataStructureIterator iterator = **this**.**new** EvenIterator();  
11.         **while** (iterator.hasNext()) {  
12.             System.out.print(iterator.next() + &quot; &quot;);  
13.         }  
14.         System.out.println();  
15.     }  
16.     **interface** DataStructureIterator **extends** java.util.Iterator &lt; Integer &gt; {} // Inner class implements the DataStructureIterator interface, // which extends the Iterator&lt;Integer&gt; interface  
17.     **private** **class** EvenIterator **implements** DataStructureIterator { // Start stepping through the array from the beginning  
18.         **private** **int** nextIndex = 0;  
19.         **public** **boolean** hasNext() { // Check if the current element is the last in the array  
20.             **return** (nextIndex &lt;= SIZE - 1);  
21.         }  
22.         **public** Integer next() { // Record a value of an even index of the array  
23.             Integer retValue = Integer.valueOf(arrayOfInts[nextIndex]); // Get the next even element  
24.             nextIndex += 2;  
25.             **return** retValue;  
26.         }  
27.     }  
28.     **public** **static** **void** main(String s[]) { // Fill the array with integer values and print out only // values of even indices  
29.         DataStructure ds = **new** DataStructure();  
30.         ds.printEven();  
31.     }  
32. }  
33. The output is: 0 2 4 6 8 10 12 14  
</code></pre><p>Note that the EvenIterator class refers directly to the arrayOfInts instance variable of the DataStructure object.</p><p>You can use inner classes to implement helper classes such as the one shown in this example. To handle user interface events, you must know how to use inner classes, because the event-handling mechanism makes extensive use of them.</p><h4>4.16.6.1 Local and Anonymous Classes</h4><p>There are two additional types of inner classes. You can declare an inner class within the body of a method. These classes are known as <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html">local classes</a>. You can also declare an inner class within the body of a method without naming the class. These classes are known as <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">anonymous classes</a>.</p><h4>4.16.6.2 Modifiers</h4><p>You can use the same modifiers for inner classes that you use for other members of the outer class. For example, you can use the access specifiers private, public, and protected to restrict access to inner classes, just as you use them to restrict access do to other class members.</p><h2>4.17 Local Classes</h2><p>Local classes are classes that are defined in a <em>block</em>, which is a group of zero or more statements between balanced braces. You typically find local classes defined in the body of a method.</p><h3>4.17.1 Declaring Local Classes</h3><p>You can define a local class inside any block (see <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/expressions.html">Expressions, Statements, and Blocks</a> for more information). For example, you can define a local class in a method body, a for loop, or an if clause.</p><p>The following example, <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/LocalClassExample.java">LocalClassExample</a>, validates two phone numbers. It defines the local class PhoneNumber in the method validatePhoneNumber:</p><pre><code class="language-java">1.  **public** **class** LocalClassExample {  
2.      **static** String regularExpression = &quot;[\^0-9]&quot;;  
3.      **public** **static** **void** validatePhoneNumber(String phoneNumber1, String phoneNumber2) {  
4.          **final** **int** numberLength = 10; // Valid in JDK 8 and later: // int numberLength = 10;  
5.          **class** PhoneNumber {  
6.              String formattedPhoneNumber = **null**;  
7.              PhoneNumber(String phoneNumber) { // numberLength = 7;  
8.                  String currentNumber = phoneNumber.replaceAll(regularExpression, &quot;&quot;);  
9.                  **if** (currentNumber.length() == numberLength) formattedPhoneNumber = currentNumber;  
10.                 **else** formattedPhoneNumber = **null**;  
11.             }  
12.             **public** String getNumber() {  
13.                     **return** formattedPhoneNumber;  
14.                 } // Valid in JDK 8 and later: //            public void printOriginalNumbers() { //                System.out.println(&quot;Original numbers are &quot; + phoneNumber1 + //                    &quot; and &quot; + phoneNumber2); //            }  
15.         }  
16.         PhoneNumber myNumber1 = **new** PhoneNumber(phoneNumber1);  
17.         PhoneNumber myNumber2 = **new** PhoneNumber(phoneNumber2); // Valid in JDK 8 and later: //        myNumber1.printOriginalNumbers();  
18.         **if** (myNumber1.getNumber() == **null**) System.out.println(&quot;First number is invalid&quot;);  
19.         **else** System.out.println(&quot;First number is &quot; + myNumber1.getNumber());  
20.         **if** (myNumber2.getNumber() == **null**) System.out.println(&quot;Second number is invalid&quot;);  
21.         **else** System.out.println(&quot;Second number is &quot; + myNumber2.getNumber());  
22.     }  
23.     **public** **static** **void** main(String\...args) {  
24.         validatePhoneNumber(&quot;123-456-7890&quot;, &quot;456-7890&quot;);  
25.     }  
26. }  
</code></pre><p>The example validates a phone number by first removing all characters from the phone number except the digits 0 through 9. After, it checks whether the phone number contains exactly ten digits (the length of a phone number in North America). This example prints the following:</p><p>First number is 1234567890</p><p>Second number is invalid</p><h3>4.17.2 Accessing Members of an Enclosing Class</h3><p>A local class has access to the members of its enclosing class. In the previous example, the PhoneNumber constructor accesses the member LocalClassExample.regularExpression.</p><p>In addition, a local class has access to local variables. However, a local class can only access local variables that are declared final. When a local class accesses a local variable or parameter of the enclosing block, it <em>captures</em> that variable or parameter. For example, the PhoneNumber constructor can access the local variable numberLength because it is declared final; numberLengthis a <em>captured variable</em>.</p><p>However, starting in Java SE 8, a local class can access local variables and parameters of the enclosing block that are final or <em>effectively final</em>. A variable or parameter whose value is never changed after it is initialized is effectively final. For example, suppose that the variable numberLength is not declared final, and you add the highlighted assignment statement in the PhoneNumber constructor to change the length of a valid phone number to 7 digits:</p><pre><code class="language-java">1.  PhoneNumber(String phoneNumber) {  
2.      numberLength = 7;  
3.      String currentNumber = phoneNumber.replaceAll(regularExpression, &quot;&quot;);  
4.      **if** (currentNumber.length() == numberLength) formattedPhoneNumber = currentNumber;  
5.      **else** formattedPhoneNumber = **null**;  
6.  }  
</code></pre><p>Because of this assignment statement, the variable numberLength is not effectively final anymore. As a result, the Java compiler generates an error message similar to &quot;local variables referenced from an inner class must be final or effectively final&quot; where the inner class PhoneNumber tries to access the numberLength variable:</p><pre><code class="language-java">1.  **if** (currentNumber.length() == numberLength)  
</code></pre><p>Starting in Java SE 8, if you declare the local class in a method, it can access the method&#x27;s parameters. For example, you can define the following method in the PhoneNumber local class:</p><pre><code class="language-java">1.  **public** **void** printOriginalNumbers() {  
2.      System.out.println(&quot;Original numbers are &quot; + phoneNumber1 + &quot; and &quot; + phoneNumber2);  
3.  }  
</code></pre><p>The method printOriginalNumbers accesses the parameters phoneNumber1 and phoneNumber2 of the method validatePhoneNumber.</p><h4>4.17.2.1 Shadowing and Local Classes</h4><p>Declarations of a type (such as a variable) in a local class shadow declaration in the enclosing scope that have the same name.</p><h3>4.17.3 Local Classes Are Similar To Inner Classes</h3><p>Local classes are similar to inner classes because they cannot define or declare any static members. Local classes in static methods, such as the class PhoneNumber, which is defined in the static method validatePhoneNumber, can only refer to static members of the enclosing class. For example, if you do not define the member variable regularExpression as static, then the Java compiler generates an error similar to &quot;non-static variable regularExpression cannot be referenced from a static context.&quot;</p><p>Local classes are non-static because they have access to instance members of the enclosing block. Consequently, they cannot contain most kinds of static declarations.</p><p>You cannot declare an interface inside a block; interfaces are inherently static. For example, the following code excerpt does not compile because the interface HelloThere is defined inside the body of the method greetInEnglish:</p><pre><code class="language-java">1.  **public** **void** greetInEnglish() {  
2.      **interface** HelloThere {  
3.          **public** **void** greet();  
4.      }  
5.      **class** EnglishHelloThere **implements** HelloThere {  
6.          **public** **void** greet() {  
7.              System.out.println(&quot;Hello &quot; + name);  
8.          }  
9.      }  
10.     HelloThere myGreeting = **new** EnglishHelloThere();  
11.     myGreeting.greet();  
12. }  
</code></pre><p>You cannot declare static initializers or member interfaces in a local class. The following code excerpt does not compile because the method EnglishGoodbye.sayGoodbye is declared static. The compiler generates an error similar to &quot;modifier &#x27;static&#x27; is only allowed in constant variable declaration&quot; when it encounters this method definition:</p><pre><code class="language-java">1.  **public** **void** sayGoodbyeInEnglish() {  
2.      **class** EnglishGoodbye {  
3.          **public** **static** **void** sayGoodbye() {  
4.              System.out.println(&quot;Bye bye&quot;);  
5.          }  
6.      }  
7.      EnglishGoodbye.sayGoodbye();  
8.  }  
</code></pre><p>A local class can have static members provided that they are constant variables. (A <em>constant variable</em> is a variable of primitive type or type String that is declared final and initialized with a compile-time constant expression. A compile-time constant expression is typically a string or an arithmetic expression that can be evaluated at compile time. See <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html">Understanding Class Members</a>for more information.) The following code excerpt compiles because the static member EnglishGoodbye.farewell is a constant variable:</p><pre><code class="language-java">1.  **public** **void** sayGoodbyeInEnglish() {  
2.      **class** EnglishGoodbye {  
3.          **public** **static** **final** String farewell = &quot;Bye bye&quot;;  
4.          **public** **void** sayGoodbye() {  
5.              System.out.println(farewell);  
6.          }  
7.      }  
8.      EnglishGoodbye myEnglishGoodbye = **new** EnglishGoodbye();  
9.      myEnglishGoodbye.sayGoodbye();  
10. }  
</code></pre><h2>4.18 Anonymous Classes</h2><p>Anonymous classes enable you to make your code more concise. They enable you to declare and instantiate a class at the same time. They are like local classes except that they do not have a name. Use them if you need to use a local class only once.</p><h3>4.18.1 Declaring Anonymous Classes</h3><p>While local classes are class declarations, anonymous classes are expressions, which means that you define the class in another expression. The following example,<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/HelloWorldAnonymousClasses.java">HelloWorldAnonymousClasses</a>, uses anonymous classes in the initialization statements of the local variables frenchGreeting and spanishGreeting, but uses a local class for the initialization of the variable englishGreeting:</p><pre><code class="language-java">1.  **public** **class** HelloWorldAnonymousClasses {  
2.      **interface** HelloWorld {  
3.          **public** **void** greet();  
4.          **public** **void** greetSomeone(String someone);  
5.      }  
6.      **public** **void** sayHello() {  
7.          **class** EnglishGreeting **implements** HelloWorld {  
8.              String name = &quot;world&quot;;  
9.              **public** **void** greet() {  
10.                 greetSomeone(&quot;world&quot;);  
11.             }  
12.             **public** **void** greetSomeone(String someone) {  
13.                 name = someone;  
14.                 System.out.println(&quot;Hello &quot; + name);  
15.             }  
16.         }  
17.         HelloWorld englishGreeting = **new** EnglishGreeting();  
18.         HelloWorld frenchGreeting = **new** HelloWorld() {  
19.             String name = &quot;tout le monde&quot;;  
20.             **public** **void** greet() {  
21.                 greetSomeone(&quot;tout le monde&quot;);  
22.             }  
23.             **public** **void** greetSomeone(String someone) {  
24.                 name = someone;  
25.                 System.out.println(&quot;Salut &quot; + name);  
26.             }  
27.         };  
28.         HelloWorld spanishGreeting = **new** HelloWorld() {  
29.             String name = &quot;mundo&quot;;  
30.             **public** **void** greet() {  
31.                 greetSomeone(&quot;mundo&quot;);  
32.             }  
33.             **public** **void** greetSomeone(String someone) {  
34.                 name = someone;  
35.                 System.out.println(&quot;Hola, &quot; + name);  
36.             }  
37.         };  
38.         englishGreeting.greet();  
39.         frenchGreeting.greetSomeone(&quot;Fred&quot;);  
40.         spanishGreeting.greet();  
41.     }  
42.     **public** **static** **void** main(String\...args) {  
43.         HelloWorldAnonymousClasses myApp = **new** HelloWorldAnonymousClasses();  
44.         myApp.sayHello();  
45.     }  
46. }  
</code></pre><h3>4.18.2 Syntax of Anonymous Classes</h3><p>As mentioned previously, an anonymous class is an expression. The syntax of an anonymous class expression is like the invocation of a constructor, except that there is a class definition contained in a block of code.</p><p>Consider the instantiation of the frenchGreeting object:</p><pre><code class="language-java">1.  HelloWorld frenchGreeting = **new** HelloWorld() {  
2.      String name = &quot;tout le monde&quot;;  
3.      **public** **void** greet() {  
4.          greetSomeone(&quot;tout le monde&quot;);  
5.      }  
6.      **public** **void** greetSomeone(String someone) {  
7.          name = someone;  
8.          System.out.println(&quot;Salut &quot; + name);  
9.      }  
10. };  
</code></pre><p>The anonymous class expression consists of the following:</p><ul><li>The new operator</li><li>The name of an interface to implement or a class to extend. In this example, the anonymous class is implementing the interface HelloWorld.</li><li>Parentheses that contain the arguments to a constructor, just like a normal class instance creation expression. <strong>Note</strong>: When you implement an interface, there is no constructor, so you use an empty pair of parentheses, as in this example.</li><li>A body, which is a class declaration body. More specifically, in the body, method declarations are allowed but statements are not.</li></ul><p>Because an anonymous class definition is an expression, it must be part of a statement. In this example, the anonymous class expression is part of the statement that instantiates the frenchGreeting object. (This explains why there is a semicolon after the closing brace.)</p><h3>4.18.3 Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous Class</h3><p>Like local classes, anonymous classes can <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#accessing-members-of-an-enclosing-class">capture variables</a>; they have the same access to local variables of the enclosing scope:</p><ul><li>An anonymous class has access to the members of its enclosing class.</li><li>An anonymous class cannot access local variables in its enclosing scope that are not declared as final or effectively final.</li><li>Like a nested class, a declaration of a type (such as a variable) in an anonymous class shadows any other declarations in the enclosing scope that have the same name. See <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing">Shadowing</a> for more information.</li></ul><p>Anonymous classes also have the same restrictions as local classes with respect to their members:</p><ul><li>You cannot declare static initializers or member interfaces in an anonymous class.</li><li>An anonymous class can have static members provided that they are constant variables.</li></ul><p>Note that you can declare the following in anonymous classes:</p><ul><li>Fields</li><li>Extra methods (even if they do not implement any methods of the supertype)</li><li>Instance initializers</li><li>Local classes</li></ul><p>However, you cannot declare constructors in an anonymous class.</p><h3>4.18.4 Examples of Anonymous Classes</h3><p>Anonymous classes are often used in graphical user interface (GUI) applications.</p><p>Consider the JavaFX example <a href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm">HelloWorld.java</a> (from the section <a href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm">Hello World, JavaFX Style</a> from <a href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/javafx_get_started.htm">Getting Started with JavaFX</a>). This sample creates a frame that contains a <strong>Say &#x27;Hello World&#x27;</strong>button. The anonymous class expression is highlighted:</p><pre><code class="language-java">1.  **import** javafx.event.ActionEvent;  
2.  **import** javafx.event.EventHandler;  
3.  **import** javafx.scene.Scene;  
4.  **import** javafx.scene.control.Button;  
5.  **import** javafx.scene.layout.StackPane;  
6.  **import** javafx.stage.Stage;  
7.  **public** **class** HelloWorld **extends** Application {  
8.      **public** **static** **void** main(String[] args) {  
9.          launch(args);  
10.     }@  
11.     Override **public** **void** start(Stage primaryStage) {  
12.         primaryStage.setTitle(&quot;Hello World!&quot;);  
13.         Button btn = **new** Button();  
14.         btn.setText(&quot;Say &#x27;Hello World&#x27;&quot;);  
15.         btn.setOnAction(**new** EventHandler &lt; ActionEvent &gt; () {@  
16.             Override **public** **void** handle(ActionEvent event) {  
17.                 System.out.println(&quot;Hello World!&quot;);  
18.             }  
19.         });  
20.         StackPane root = **new** StackPane();  
21.         root.getChildren().add(btn);  
22.         primaryStage.setScene(**new** Scene(root, 300, 250));  
23.         primaryStage.show();  
24.     }  
25. }  
</code></pre><p>In this example, the method invocation btn.setOnAction specifies what happens when you select the <strong>Say &#x27;Hello World&#x27;</strong> button. This method requires an object of type <code>EventHandler&lt;ActionEvent&gt;</code>{.java}. The <code>EventHandler&lt;ActionEvent&gt;</code>{.java} interface contains only one method, handle. Instead of implementing this method with a new class, the example uses an anonymous class expression. Notice that this expression is the argument passed to the btn.setOnAction method.</p><p>Because the <code>EventHandler&lt;ActionEvent&gt;</code>{.java} interface contains only one method, you can use a lambda expression instead of an anonymous class expression.</p><p>Anonymous classes are ideal for implementing an interface that contains two or more methods. The following JavaFX example is from the section <a href="https://docs.oracle.com/javase/8/javafx/user-interface-tutorial/custom.htm">Customization of UI Controls</a>. The highlighted code creates a text field that only accepts numeric values. It redefines the default implementation of the TextField class with an anonymous class by overriding the replaceText and replaceSelection methods inherited from the TextInputControl class.</p><ol><li><strong>import</strong> javafx.application.Application;  </li><li><strong>import</strong> javafx.event.ActionEvent;  </li><li><strong>import</strong> javafx.event.EventHandler;  </li><li><strong>import</strong> javafx.geometry.Insets;  </li><li><strong>import</strong> javafx.scene.Group;  </li><li><strong>import</strong> javafx.scene.Scene;  </li><li><strong>import</strong> javafx.scene.control.*;  </li><li><strong>import</strong> javafx.scene.layout.GridPane;  </li><li><strong>import</strong> javafx.scene.layout.HBox;  </li><li><strong>import</strong> javafx.stage.Stage;  </li><li><strong>public</strong> <strong>class</strong> CustomTextFieldSample <strong>extends</strong> Application {  </li><li>    <strong>final</strong> <strong>static</strong> Label label = <strong>new</strong> Label();@  </li><li>    Override <strong>public</strong> <strong>void</strong> start(Stage stage) {  </li><li>        Group root = <strong>new</strong> Group();  </li><li>        Scene scene = <strong>new</strong> Scene(root, 300, 150);  </li><li>        stage.setScene(scene);  </li><li>        stage.setTitle(&quot;Text Field Sample&quot;);  </li><li>        GridPane grid = <strong>new</strong> GridPane();  </li><li>        grid.setPadding(<strong>new</strong> Insets(10, 10, 10, 10));  </li><li>        grid.setVgap(5);  </li><li>        grid.setHgap(5);  </li><li>        scene.setRoot(grid);  </li><li>        <strong>final</strong> Label dollar = <strong>new</strong> Label(&quot;\$&quot;);  </li><li>        GridPane.setConstraints(dollar, 0, 0);  </li><li>        grid.getChildren().add(dollar);  </li><li>        <strong>final</strong> TextField sum = <strong>new</strong> TextField() {@  </li><li>            Override <strong>public</strong> <strong>void</strong> replaceText(<strong>int</strong> start, <strong>int</strong> end, String text) {  </li><li>                <strong>if</strong> (!text.matches(&quot;<!-- -->[a-z, A-Z]<!-- -->&quot;)) {  </li><li>                    <strong>super</strong>.replaceText(start, end, text);  </li><li>                }  </li><li>                label.setText(&quot;Enter a numeric value&quot;);  </li><li>            }@  </li><li>            Override <strong>public</strong> <strong>void</strong> replaceSelection(String text) {  </li><li>                <strong>if</strong> (!text.matches(&quot;<!-- -->[a-z, A-Z]<!-- -->&quot;)) {  </li><li>                    <strong>super</strong>.replaceSelection(text);  </li><li>                }  </li><li>            }  </li><li>        };  </li><li>        sum.setPromptText(&quot;Enter the total&quot;);  </li><li>        sum.setPrefColumnCount(10);  </li><li>        GridPane.setConstraints(sum, 1, 0);  </li><li>        grid.getChildren().add(sum);  </li><li>        Button submit = <strong>new</strong> Button(&quot;Submit&quot;);  </li><li>        GridPane.setConstraints(submit, 2, 0);  </li><li>        grid.getChildren().add(submit);  </li><li>        submit.setOnAction(<strong>new</strong> EventHandler &lt; ActionEvent &gt; () {@  </li><li>            Override <strong>public</strong> <strong>void</strong> handle(ActionEvent e) {  </li><li>                label.setText(<strong>null</strong>);  </li><li>            }  </li><li>        });  </li><li>        GridPane.setConstraints(label, 0, 1);  </li><li>        GridPane.setColumnSpan(label, 3);  </li><li>        grid.getChildren().add(label);  </li><li>        scene.setRoot(grid);  </li><li>        stage.show();  </li><li>    }  </li><li>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li><li>        launch(args);  </li><li>    }  </li><li>}  </li></ol><h2>4.19 Lambda Expressions</h2><p>One issue with anonymous classes is that if the implementation of your anonymous class is very simple, such as an <strong>interface that contains only one method, then the syntax of anonymous classes may seem unwieldy and unclear</strong>. In these cases, you&#x27;re usually trying to pass functionality as an argument to another method, such as what action should be taken when someone clicks a button. <strong>Lambda expressions enable you to do this, to treat functionality as method argument, or code as data.</strong></p><p>The previous section, <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">Anonymous Classes</a>, shows you how to implement a base class without giving it a name. Although this is often more concise than a named class, for classes with only one method, even an anonymous class seems a bit excessive and cumbersome. Lambda expressions let you express instances of single-method classes more compactly.</p><h3>4.19.1 Ideal Use Case for Lambda Expressions</h3><p>Suppose that you are creating a social networking application. You want to create a feature that enables an administrator to perform any kind of action, such as sending a message, on members of the social networking application that satisfy certain criteria. The following table describes this use case in detail:</p><p>+-----------------------------------+-----------------------------------+
| Field                             | Description                       |
+-----------------------------------+-----------------------------------+
| Name                              | Perform action on selected        |
|                                   | members                           |
+-----------------------------------+-----------------------------------+
| Primary Actor                     | Administrator                     |
+-----------------------------------+-----------------------------------+
| Preconditions                     | Administrator is logged in to the |
|                                   | system.                           |
+-----------------------------------+-----------------------------------+
| Postconditions                    | Action is performed only on       |
|                                   | members that fit the specified    |
|                                   | criteria.                         |
+-----------------------------------+-----------------------------------+
| Main Success Scenario             | 1.  Administrator specifies       |
|                                   |     criteria of members on which  |
|                                   |     to perform a certain action.  |
|                                   | 2.  Administrator specifies an    |
|                                   |     action to perform on those    |
|                                   |     selected members.             |
|                                   | 3.  Administrator selects         |
|                                   |     the <strong>Submit</strong> button.        |
|                                   | 4.  The system finds all members  |
|                                   |     that match the specified      |
|                                   |     criteria.                     |
|                                   | 5.  The system performs the       |
|                                   |     specified action on all       |
|                                   |     matching members.             |
+-----------------------------------+-----------------------------------+
| Extensions                        | 1a. Administrator has an option   |
|                                   | to preview those members who      |
|                                   | match the specified criteria      |
|                                   | before he or she specifies the    |
|                                   | action to be performed or before  |
|                                   | selecting the <strong>Submit</strong> button.  |
+-----------------------------------+-----------------------------------+
| Frequency of Occurrence           | Many times during the day.        |
+-----------------------------------+-----------------------------------+</p><p>Suppose that members of this social networking application are represented by the following <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Person.java">Person</a> class:</p><ol><li><strong>public</strong> <strong>class</strong> Person {  </li><li>    <strong>public</strong> <strong>enum</strong> Sex {  </li><li>        MALE, FEMALE  </li><li>    }  </li><li>    String name;  </li><li>    LocalDate birthday;  </li><li>    Sex gender;  </li><li>    String emailAddress;  </li><li>    <strong>public</strong> <strong>int</strong> getAge() { // <!-- -->.<!-- -->..  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> printPerson() { // <!-- -->.<!-- -->..  </li><li>    }  </li><li>}  </li></ol><p>Suppose that the members of your social networking application are stored in a <code>List&lt;Person&gt;</code> instance.</p><p>This section begins with a naive approach to this use case. It improves upon this approach with local and anonymous classes, and then finishes with an efficient and concise approach using lambda expressions. Find the code excerpts described in this section in the example <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/RosterTest.java">RosterTest</a>.</p><h4>4.19.1.1 Approach 1: Create Methods That Search for Members That Match One Characteristic</h4><p>One simplistic approach is to create several methods; each method searches for members that match one characteristic, such as gender or age. The following method prints members that are older than a specified age:</p><ol><li><strong>public</strong> <strong>static</strong> <strong>void</strong> printPersonsOlderThan(List &lt; Person &gt; roster, <strong>int</strong> age) {  </li><li>    <strong>for</strong> (Person p: roster) {  </li><li>        <strong>if</strong> (p.getAge() &gt;= age) {  </li><li>            p.printPerson();  </li><li>        }  </li><li>    }  </li><li>}  </li></ol><p>This approach can potentially make your application <em>brittle</em>, which is the likelihood of an application not working because of the introduction of updates (such as newer data types). Suppose that you upgrade your application and change the structure of the Person class such that it contains different member variables; perhaps the class records and measures ages with a different data type or algorithm. You would have to rewrite a lot of your API to accommodate this change. In addition, this approach is unnecessarily restrictive; what if you wanted to print members younger than a certain age, for example?</p><h4>4.19.1.2 Approach 2: Create More Generalized Search Methods</h4><p>The following method is more generic than printPersonsOlderThan; it prints members within a specified range of ages:</p><ol><li><strong>public</strong> <strong>static</strong> <strong>void</strong> printPersonsWithinAgeRange(List &lt; Person &gt; roster, <strong>int</strong> low, <strong>int</strong> high) {  </li><li>    <strong>for</strong> (Person p: roster) {  </li><li>        <strong>if</strong> (low &lt;= p.getAge() &amp;&amp; p.getAge() &lt; high) {  </li><li>            p.printPerson();  </li><li>        }  </li><li>    }  </li><li>}  </li></ol><p>What if you want to print members of a specified sex, or a combination of a specified gender and age range? What if you decide to change the Person class and add other attributes such as relationship status or geographical location? Although this method is more generic than printPersonsOlderThan, trying to create a separate method for each possible search query can still lead to brittle code. You can instead separate the code that specifies the criteria for which you want to search in a different class.</p><h4>4.19.1.3 Approach 3: Specify Search Criteria Code in a Local Class</h4><p>The following method prints members that match search criteria that you specify:</p><ol><li><strong>public</strong> <strong>static</strong> <strong>void</strong> printPersons(List &lt; Person &gt; roster, CheckPerson tester) {  </li><li>    <strong>for</strong> (Person p: roster) {  </li><li>        <strong>if</strong> (tester.test(p)) {  </li><li>            p.printPerson();  </li><li>        }  </li><li>    }  </li><li>}  </li></ol><p>This method checks each Person instance contained in the List parameter roster whether it satisfies the search criteria specified in the CheckPerson parameter tester by invoking the method tester.test. If the method tester.test returns a true value, then the method printPersons is invoked on the Person instance.</p><p>To specify the search criteria, you implement the CheckPerson interface:</p><ol><li><strong>interface</strong> CheckPerson {  </li><li>    <strong>boolean</strong> test(Person p);  </li><li>}  </li></ol><p>The following class implements the CheckPerson interface by specifying an implementation for the method test. This method filters members that are eligible for Selective Service in the United States: it returns a true value if its Person parameter is male and between the ages of 18 and 25:</p><ol><li><strong>class</strong> CheckPersonEligibleForSelectiveService <strong>implements</strong> CheckPerson {  </li><li>    <strong>public</strong> <strong>boolean</strong> test(Person p) {  </li><li>        <strong>return</strong> p.gender == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25;  </li><li>    }  </li><li>}  </li></ol><p>To use this class, you create a new instance of it and invoke the printPersons method:</p><ol><li>printPersons(roster, <strong>new</strong> CheckPersonEligibleForSelectiveService());  </li></ol><p>Although this approach is less brittle---you don&#x27;t have to rewrite methods if you change the structure of the Person---you still have additional code: a new interface and a local class for each search you plan to perform in your application. Because CheckPersonEligibleForSelectiveService implements an interface, you can use an anonymous class instead of a local class and bypass the need to declare a new class for each search.</p><h4>4.19.1.4 Approach 4: Specify Search Criteria Code in an Anonymous Class</h4><p>One of the arguments of the following invocation of the method printPersons is an anonymous class that filters members that are eligible for Selective Service in the United States: those who are male and between the ages of 18 and 25:</p><ol><li>printPersons(roster, <strong>new</strong> CheckPerson() {  </li><li>    <strong>public</strong> <strong>boolean</strong> test(Person p) {  </li><li>        <strong>return</strong> p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25;  </li><li>    }  </li><li>});  </li></ol><p>This approach reduces the amount of code required because you don&#x27;t have to create a new class for each search that you want to perform. However, the syntax of anonymous classes is bulky considering that the CheckPerson interface contains only one method. In this case, you can use a lambda expression instead of an anonymous class, as described in the next section.</p><h4>4.19.1.5 Approach 5: Specify Search Criteria Code with a Lambda Expression</h4><p>The CheckPerson interface is a <em>functional interface</em>. A functional interface is any interface that contains only one <a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">abstract method</a>. (A functional interface may contain one or more <a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">default methods</a> or <a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html#static">static methods</a>.) Because a functional interface contains only one abstract method, you can omit the name of that method when you implement it. To do this, instead of using an anonymous class expression, you use a <em>lambda expression</em>, which is highlighted in the following method invocation:</p><ol><li>printPersons(roster, (Person p) - &gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25);  </li></ol><p>You can use a standard functional interface in place of the interface CheckPerson, which reduces even further the amount of code required.</p><h4>4.19.1.6 Approach 6: Use Standard Functional Interfaces with Lambda Expressions</h4><p>Reconsider the CheckPerson interface:</p><ol><li><strong>interface</strong> CheckPerson {  </li><li>    <strong>boolean</strong> test(Person p);  </li><li>}  </li></ol><p>This is a very simple interface. It&#x27;s a functional interface because it contains only one abstract method. This method takes one parameter and returns a boolean value. The method is so simple that it might not be worth it to define one in your application. Consequently, <strong>the JDK defines several standard functional interfaces, which you can find in the package java.util.function.</strong></p><p>For example, you can use the <code>Predicate&lt;T&gt;</code> interface in place of CheckPerson. This interface contains the method boolean test(T t):</p><pre><code class="language-java">1.  **interface** Predicate &lt; T &gt; {  
2.      **boolean** test(T t);  
3.  }  
</code></pre><p>The interface <code>Predicate&lt;T&gt;</code> is an example of a generic interface. (For more information about generics, see the <a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">Generics (Updated)</a> lesson.) Generic types (such as generic interfaces) specify one or more type parameters within angle brackets (<code>&lt;&gt;</code>). This interface contains only one type parameter, T. When you declare or instantiate a generic type with actual type arguments, you have a parameterized type. For example, the parameterized type <code>Predicate&lt;Person&gt;</code> is the following:</p><pre><code class="language-java">1.  **interface** Predicate &lt; Person &gt; {  
2.      **boolean** test(Person t);  
3.  }  
</code></pre><p>This parameterized type contains a method that has the same return type and parameters as CheckPerson.boolean test(Person p). Consequently, you can use <code>Predicate&lt;T&gt;</code> in place of CheckPerson as the following method demonstrates:</p><pre><code class="language-java">1.  **public** **static** **void** printPersonsWithPredicate(List &lt; Person &gt; roster, Predicate &lt; Person &gt; tester) {  
2.      **for** (Person p: roster) {  
3.          **if** (tester.test(p)) {  
4.              p.printPerson();  
5.          }  
6.      }  
7.  }  
</code></pre><p>As a result, the following method invocation is the same as when you invoked printPersons in <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach3">Approach 3: Specify Search Criteria Code in a Local Class</a> to obtain members who are eligible for Selective Service:</p><ol><li>printPersonsWithPredicate(roster, p - &gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25);  </li></ol><p>This is not the only possible place in this method to use a lambda expression. The following approach suggests other ways to use lambda expressions.</p><h4>4.19.1.7 Approach 7: Use Lambda Expressions Throughout Your Application</h4><p>Reconsider the method printPersonsWithPredicate to see where else you could use lambda expressions:</p><ol><li><strong>public</strong> <strong>static</strong> <strong>void</strong> printPersonsWithPredicate(List &lt; Person &gt; roster, Predicate &lt; Person &gt; tester) {  </li><li>    <strong>for</strong> (Person p: roster) {  </li><li>        <strong>if</strong> (tester.test(p)) {  </li><li>            p.printPerson();  </li><li>        }  </li><li>    }  </li><li>}  </li></ol><p>This method checks each Person instance contained in the List parameter roster whether it satisfies the criteria specified in the Predicate parameter tester. If the Person instance does satisfy the criteria specified by tester, the method printPersron is invoked on the Person instance.</p><p>Instead of invoking the method printPerson, you can specify a different action to perform on those Person instances that satisfy the criteria specified by tester. You can specify this action with a lambda expression. Suppose you want a lambda expression similar to printPerson, one that takes one argument (an object of type Person) and returns void. Remember, to use a lambda expression, you need to implement a functional interface. In this case, you need a functional interface that contains an abstract method that can take one argument of type Person and returns void. The <code>Consumer&lt;T&gt;</code> interface contains the method void accept(T t), which has these characteristics. The following method replaces the invocation p.printPerson() with an instance of <code>Consumer&lt;Person&gt;</code> that invokes the method accept:</p><ol><li><strong>public</strong> <strong>static</strong> <strong>void</strong> processPersons(List &lt; Person &gt; roster, Predicate &lt; Person &gt; tester, Consumer &lt; Person &gt; block) {  </li><li>    <strong>for</strong> (Person p: roster) {  </li><li>        <strong>if</strong> (tester.test(p)) {  </li><li>            block.accept(p);  </li><li>        }  </li><li>    }  </li><li>}  </li></ol><p>As a result, the following method invocation is the same as when you invoked printPersons in <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach3">Approach 3: Specify Search Criteria Code in a Local Class</a> to obtain members who are eligible for Selective Service. The lambda expression used to print members is highlighted:</p><ol><li>processPersons(roster, p - &gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25, p - &gt; p.printPerson());  </li></ol><p>What if you want to do more with your members&#x27; profiles than printing them out. Suppose that you want to validate the members&#x27; profiles or retrieve their contact information? In this case, you need a functional interface that contains an abstract method that returns a value. The Function&lt;T,R&gt; interface contains the method R apply(T t). The following method retrieves the data specified by the parameter mapper, and then performs an action on it specified by the parameter block:</p><ol><li><strong>public</strong> <strong>static</strong> <strong>void</strong> processPersonsWithFunction(List &lt; Person &gt; roster, Predicate &lt; Person &gt; tester, Function &lt; Person, String &gt; mapper, Consumer &lt; String &gt; block) {  </li><li>    <strong>for</strong> (Person p: roster) {  </li><li>        <strong>if</strong> (tester.test(p)) {  </li><li>            String data = mapper.apply(p);  </li><li>            block.accept(data);  </li><li>        }  </li><li>    }  </li><li>}  </li></ol><p>The following method retrieves the email address from each member contained in roster who is eligible for Selective Service and then prints it:</p><p>[]{#bookmark=id.38czs75}</p><ol><li>processPersonsWithFunction(roster, p - &gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25, p - &gt; p.getEmailAddress(), email - &gt; System.out.println(email));  </li></ol><h4>4.19.1.8 Approach 8: Use Generics More Extensively</h4><p>Reconsider the method processPersonsWithFunction. The following is a generic version of it that accepts, as a parameter, a collection that contains elements of any data type:</p><ol><li><strong>public</strong> <strong>static</strong> &lt; X, Y &gt; <strong>void</strong> processElements(Iterable &lt; X &gt; source, Predicate &lt; X &gt; tester, Function &lt; X, Y &gt; mapper, Consumer &lt; Y &gt; block) {  </li><li>    <strong>for</strong> (X p: source) {  </li><li>        <strong>if</strong> (tester.test(p)) {  </li><li>            Y data = mapper.apply(p);  </li><li>            block.accept(data);  </li><li>        }  </li><li>    }  </li><li>}  </li></ol><p>To print the e-mail address of members who are eligible for Selective Service, invoke the processElements method as follows:</p><ol><li>processElements(roster, p - &gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25, p - &gt; p.getEmailAddress(), email - &gt; System.out.println(email));  </li></ol><p>This method invocation performs the following actions:</p><ul><li>Obtains a source of objects from the collection source. In this example, it obtains a source of Person objects from the collection roster. Notice that the collection roster, which is a collection of type List, is also an object of type Iterable.</li><li>Filters objects that match the Predicate object tester. In this example, the Predicate object is a lambda expression that specifies which members would be eligible for Selective Service.</li><li>Maps each filtered object to a value as specified by the Function object mapper. In this example, the Function object is a lambda expression that returns the e-mail address of a member.</li><li>Performs an action on each mapped object as specified by the Consumer object block. In this example, the Consumer object is a lambda expression that prints a string, which is the e-mail address returned by the Function object.</li></ul><p>You can replace each of these actions with an aggregate operation.</p><h4>4.19.1.9 Approach 9: Use Aggregate Operations That Accept Lambda Expressions as Parameters</h4><p>The following example uses aggregate operations to print the e-mail addresses of those members contained in the collection roster who are eligible for Selective Service:</p><pre><code class="language-java">1.  roster.stream().filter(p - &gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25).map(p - &gt; p.getEmailAddress()).forEach(email - &gt; System.out.println(email));  
</code></pre><p>The following table maps each of the operations the method processElements performs with the corresponding aggregate operation:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>processElements Action</td><td>Aggregate Operation</td></tr><tr><td>Obtain a source of objects</td><td>`<code>Stream&lt;E&gt; **stream**()</code></td></tr><tr><td>Filter objects that match a Predicate object</td><td><code>Stream&lt;T&gt; **filter**(Predicate&lt;? super T&gt; predicate)</code></td></tr><tr><td>Map objects to another value as specified by a Function object</td><td><code>&lt;R&gt; Stream&lt;R&gt; **map**(Function&lt;? super T,? extends R&gt; mapper)</code></td></tr><tr><td>Perform an action as specified by a Consumer object</td><td><code>void **forEach**(Consumer&lt;? super T&gt; action)</code></td></tr></tbody></table><p>The operations filter, map, and forEach are <em>aggregate operations</em>. Aggregate operations process elements from a stream, not directly from a collection (which is the reason why the first method invoked in this example is stream). A <em>stream</em> is a sequence of elements. Unlike a collection, it is not a data structure that stores elements. Instead, a stream carries values from a source, such as collection, through a pipeline. A <em>pipeline</em> is a sequence of stream operations, which in this example is filter- map-forEach. In addition, aggregate operations typically accept lambda expressions as parameters, enabling you to customize how they behave.</p><p>For a more thorough discussion of aggregate operations, see the <a href="https://docs.oracle.com/javase/tutorial/collections/streams/index.html">Aggregate Operations</a> lesson.</p><h3>4.19.2 Lambda Expressions in GUI Applications</h3><p>To process events in a graphical user interface (GUI) application, such as keyboard actions, mouse actions, and scroll actions, you typically create event handlers, which usually involves implementing a particular interface. Often, event handler interfaces are functional interfaces; they tend to have only one method.</p><p>In the JavaFX example <a href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm">HelloWorld.java</a> (discussed in the previous section <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">Anonymous Classes</a>), you can replace the highlighted anonymous class with a lambda expression in this statement:</p><pre><code class="language-java">1.  btn.setOnAction(**new** EventHandler &lt; ActionEvent &gt; () {@  
2.      Override **public** **void** handle(ActionEvent event) {  
3.          System.out.println(&quot;Hello World!&quot;);  
4.      }  
5.  });  
</code></pre><p>The method invocation btn.setOnAction specifies what happens when you select the button represented by the btn object. This method requires an object of type <code>EventHandler&lt;ActionEvent&gt;</code>. The <code>EventHandler&lt;ActionEvent&gt;</code> interface contains only one method, void handle(T event). This interface is a functional interface, so you could use the following highlighted lambda expression to replace it:</p><pre><code class="language-java">1.  btn.setOnAction(event - &gt; System.out.println(&quot;Hello World!&quot;));  
</code></pre><h3>4.19.3 Syntax of Lambda Expressions</h3><p>A lambda expression consists of the following:</p><p>A comma-separated list of formal parameters enclosed in parentheses. The CheckPerson.test method contains one parameter, p, which represents an instance of the Person class.</p><p><strong>Note</strong>: You can omit the data type of the parameters in a lambda expression. In addition, you can omit the parentheses if there is only one parameter. For example, the following lambda expression is also valid:</p><pre><code class="language-java">1.  p - &gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25  
</code></pre><p>The arrow token, -&gt;</p><p>A body, which consists of a single expression or a statement block. This example uses the following expression:</p><pre><code class="language-java">1.  p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25  
</code></pre><p>If you specify a single expression, then the Java runtime evaluates the expression and then returns its value. Alternatively, you can use a return statement:</p><pre><code class="language-java">1.  p - &gt; {  
2.      **return** p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25;  
3.  }  
</code></pre><p>A return statement is not an expression; in a lambda expression, you must enclose statements in braces ({}). However, you do not have to enclose a void method invocation in braces. For example, the following is a valid lambda expression:</p><pre><code class="language-java">1.  email - &gt; System.out.println(email)  
</code></pre><p>Note that a lambda expression looks a lot like a method declaration; you can consider lambda expressions as anonymous methods---methods without a name.</p><p>The following example, <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Calculator.java">Calculator</a>, is an example of lambda expressions that take more than one formal parameter:</p><pre><code class="language-java">1.  **public** **class** Calculator {  
2.      **interface** IntegerMath {  
3.          **int** operation(**int** a, **int** b);  
4.      }  
5.      **public** **int** operateBinary(**int** a, **int** b, IntegerMath op) {  
6.          **return** op.operation(a, b);  
7.      }  
8.      **public** **static** **void** main(String\...args) {  
9.          Calculator myApp = **new** Calculator();  
10.         IntegerMath addition = (a, b) - &gt; a + b;  
11.         IntegerMath subtraction = (a, b) - &gt; a - b;  
12.         System.out.println(&quot;40 + 2 = &quot; + myApp.operateBinary(40, 2, addition));  
13.         System.out.println(&quot;20 - 10 = &quot; + myApp.operateBinary(20, 10, subtraction));  
14.     }  
15. }  
</code></pre><p>The method operateBinary performs a mathematical operation on two integer operands. The operation itself is specified by an instance of IntegerMath. The example defines two operations with lambda expressions, addition and subtraction. The example prints the following:</p><p>40 + 2 = 42
20 - 10 = 10</p><h3>4.19.4 Accessing Local Variables of the Enclosing Scope</h3><p>Like local and anonymous classes, lambda expressions can <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#accessing-members-of-an-enclosing-class">capture variables</a>; they have the same access to local variables of the enclosing scope. However, unlike local and anonymous classes, lambda expressions do not have any shadowing issues (see <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing">Shadowing</a> for more information). Lambda expressions are lexically scoped. This means that they do not inherit any names from a supertype or introduce a new level of scoping. Declarations in a lambda expression are interpreted just as they are in the enclosing environment. The following example,<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/LambdaScopeTest.java">LambdaScopeTest</a>, demonstrates this:</p><pre><code class="language-java">1.  **import** java.util.**function**.Consumer;  
2.  **public** **class** LambdaScopeTest {  
3.      **public** **int** x = 0;  
4.      **class** FirstLevel {  
5.          **public** **int** x = 1;  
6.          **void** methodInFirstLevel(**int** x) { // The following statement causes the compiler to generate // the error &quot;local variables referenced from a lambda expression // must be final or effectively final&quot; in statement A: // // x = 99;  
7.              Consumer &lt; Integer &gt; myConsumer = (y) - &gt; {  
8.                  System.out.println(&quot;x = &quot; + x); // Statement A  
9.                  System.out.println(&quot;y = &quot; + y);  
10.                 System.out.println(&quot;this.x = &quot; + **this**.x);  
11.                 System.out.println(&quot;LambdaScopeTest.this.x = &quot; + LambdaScopeTest.**this**.x);  
12.             };  
13.             myConsumer.accept(x);  
14.         }  
15.     }  
16.     **public** **static** **void** main(String\...args) {  
17.         LambdaScopeTest st = **new** LambdaScopeTest();  
18.         LambdaScopeTest.FirstLevel fl = st.**new** FirstLevel();  
19.         fl.methodInFirstLevel(23);  
20.     }  
21. }  
</code></pre><ol start="22"><li>This example generates the following output: x = 23 y = 23 <strong>this</strong>.x = 1 LambdaScopeTest.<strong>this</strong>.x = 0  </li></ol><p>If you substitute the parameter x in place of y in the declaration of the lambda expression myConsumer, then the compiler generates an error:</p><pre><code class="language-java">1.  Consumer &lt; Integer &gt; myConsumer = (x) - &gt; { // \...  
2.  }  
</code></pre><p>The compiler generates the error &quot;variable x is already defined in method methodInFirstLevel(int)&quot; because the lambda expression does not introduce a new level of scoping. Consequently, you can directly access fields, methods, and local variables of the enclosing scope. For example, the lambda expression directly accesses the parameter x of the method methodInFirstLevel. To access variables in the enclosing class, use the keyword this. In this example, this.x refers to the member variable FirstLevel.x.</p><p>However, like local and anonymous classes, a lambda expression can only access local variables and parameters of the enclosing block that are final or effectively final. For example, suppose that you add the following assignment statement immediately after the methodInFirstLevel definition statement:</p><pre><code class="language-java">1.  **void** methodInFirstLevel(**int** x) {  
2.      x = 99; // \...  
3.  }  
</code></pre><p>Because of this assignment statement, the variable FirstLevel.x is not effectively final anymore. As a result, the Java compiler generates an error message similar to &quot;local variables referenced from a lambda expression must be final or effectively final&quot; where the lambda expression myConsumer tries to access the FirstLevel.x variable:</p><p>[]{#bookmark=id.20xfydz}</p><pre><code class="language-java">1.  System.out.println(&quot;x = &quot; + x);  
</code></pre><h3>4.19.5 Target Typing</h3><p>How do you determine the type of a lambda expression? Recall the lambda expression that selected members who are male and between the ages 18 and 25 years:</p><pre><code class="language-java">1.  p - &gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25  
</code></pre><p>This lambda expression was used in the following two methods:</p><ul><li><code>public static void printPersons(List&lt;Person&gt; roster, CheckPerson tester)</code> in <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach3">Approach 3: Specify Search Criteria Code in a Local Class</a></li><li><code>public void printPersonsWithPredicate(List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester)</code> in <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach6">Approach 6: Use Standard Functional Interfaces with Lambda Expressions</a></li></ul><p>When the Java runtime invokes the method printPersons, it&#x27;s expecting a data type of CheckPerson, so the lambda expression is of this type. However, when the Java runtime invokes the method printPersonsWithPredicate, it&#x27;s expecting a data type of <code>Predicate&lt;Person&gt;</code>, so the lambda expression is of this type. The data type that these methods expect is called the <em>target type</em>. To determine the type of a lambda expression, the Java compiler uses the target type of the context or situation in which the lambda expression was found. It follows that you can only use lambda expressions in situations in which the Java compiler can determine a target type:</p><ul><li>Variable declarations</li><li>Assignments</li><li>Return statements</li><li>Array initializers</li><li>Method or constructor arguments</li><li>Lambda expression bodies</li><li>Conditional expressions, ?:</li><li>Cast expressions</li></ul><h4>4.19.5.1 Target Types and Method Arguments</h4><p>For method arguments, the Java compiler determines the target type with two other language features: overload resolution and type argument inference.</p><p>Consider the following two functional interfaces ( <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">java.lang.Runnable</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html"><code>java.util.concurrent.Callable&lt;V&gt;</code></a>):</p><pre><code class="language-java">1.  **public** **interface** Runnable {  
2.      **void** run();  
3.  }  
4.  **public** **interface** Callable &lt; V &gt; {  
5.      V call();  
6.  }  
</code></pre><p>The method Runnable.run does not return a value, whereas <code>Callable&lt;V&gt;</code>.call does.</p><p>Suppose that you have overloaded the method invoke as follows:</p><pre><code class="language-java">1.  **void** invoke(Runnable r) {  
2.      r.run();  
3.  }  
4.  &lt; T &gt; T invoke(Callable &lt; T &gt; c) {  
5.      **return** c.call();  
6.  }  
</code></pre><p>Which method will be invoked in the following statement?</p><pre><code class="language-java">1.  String s = invoke(() - &gt; &quot;done&quot;);  
</code></pre><p>The method <code>invoke(Callable&lt;T&gt;)</code> will be invoked because that method returns a value; the method <code>invoke(Runnable)</code> does not. In this case, the type of the lambda expression () -&gt; &quot;done&quot; is <code>Callable&lt;T&gt;</code>.</p><h3>4.19.6 Serialization</h3><p>You can <a href="https://docs.oracle.com/javase/tutorial/jndi/objects/serial.html">serialize</a> a lambda expression if its target type and its captured arguments are serializable. However, like <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#serialization">inner classes</a>, the serialization of lambda expressions is strongly discouraged.</p><h2>4.20 Method References</h2><p>You use <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">lambda expressions</a> to create anonymous methods. Sometimes, however, a lambda expression does nothing but call an existing method. In those cases, it&#x27;s often clearer to refer to the existing method by name. Method references enable you to do this; they are compact, easy-to-read lambda expressions for methods that already have a name.</p><p>Consider again the <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Person.java">Person</a> class discussed in the section <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Lambda Expressions</a>:</p><pre><code class="language-java">1.  **public** **class** Person {  
2.      **public** **enum** Sex {  
3.          MALE, FEMALE  
4.      }  
5.      String name;  
6.      LocalDate birthday;  
7.      Sex gender;  
8.      String emailAddress;  
9.      **public** **int** getAge() { // \...  
10.     }  
11.     **public** Calendar getBirthday() {  
12.         **return** birthday;  
13.     }  
14.     **public** **static** **int** compareByAge(Person a, Person b) {  
15.         **return** a.birthday.compareTo(b.birthday);  
16.     }  
17. }  
</code></pre><p>Suppose that the members of your social networking application are contained in an array, and you want to sort the array by age. You could use the following code (find the code excerpts described in this section in the example <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/MethodReferencesTest.java">MethodReferencesTest</a>):</p><pre><code class="language-java">1.  Person[] rosterAsArray = roster.toArray(**new** Person[roster.size()]);  
2.  **class** PersonAgeComparator **implements** Comparator &lt; Person &gt; {  
3.      **public** **int** compare(Person a, Person b) {  
4.          **return** a.getBirthday().compareTo(b.getBirthday());  
5.      }  
6.  }  
7.  Arrays.sort(rosterAsArray, **new** PersonAgeComparator());  
</code></pre><p>The method signature of this invocation of sort is the following:</p><pre><code class="language-java">1.  static &lt; T &gt; **void** sort(T[] a, Comparator &lt;? **super** T &gt; c)  
</code></pre><p>Notice that the interface Comparator is a functional interface. Therefore, you could use a lambda expression instead of defining and then creating a new instance of a class that implements Comparator:</p><pre><code class="language-java">1.  Arrays.sort(rosterAsArray, (Person a, Person b) - &gt; {  
2.      **return** a.getBirthday().compareTo(b.getBirthday());  
3.  });  
</code></pre><p>However, this method to compare the birth dates of two Person instances already exists as Person.compareByAge. You can invoke this method instead in the body of the lambda expression:</p><pre><code class="language-java">1.  Arrays.sort(rosterAsArray, (a, b) - &gt; Person.compareByAge(a, b));  
</code></pre><p>Because this lambda expression invokes an existing method, you can use a method reference instead of a lambda expression:</p><pre><code class="language-java">1.  Arrays.sort(rosterAsArray, Person::compareByAge);  
</code></pre><p>The method reference Person::compareByAge is semantically the same as the lambda expression (a, b) -&gt; Person.compareByAge(a, b). Each has the following characteristics:</p><ul><li>Its formal parameter list is copied from <code>Comparator&lt;Person&gt;</code>.compare, which is (Person, Person).</li><li>Its body calls the method Person.compareByAge.</li></ul><h3>4.20.1 Kinds of Method References</h3><p>There are four kinds of method references:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Kind</td><td>Example</td></tr><tr><td>Reference to a static method</td><td>ContainingClass::staticMethodName</td></tr><tr><td>Reference to an instance method of a particular object</td><td>containingObject::instanceMethodName</td></tr><tr><td>Reference to an instance method of an arbitrary object of a particular type</td><td>ContainingType::methodName</td></tr><tr><td>Reference to a constructor</td><td>ClassName::new</td></tr></tbody></table><h4>4.20.1.1 Reference to a Static Method</h4><p>The method reference Person::compareByAge is a reference to a static method.</p><h4>4.20.1.2 Reference to an Instance Method of a Particular Object</h4><p>The following is an example of a reference to an instance method of a particular object:</p><pre><code class="language-java">1.  **class** ComparisonProvider {  
2.      **public** **int** compareByName(Person a, Person b) {  
3.          **return** a.getName().compareTo(b.getName());  
4.      }  
5.      **public** **int** compareByAge(Person a, Person b) {  
6.          **return** a.getBirthday().compareTo(b.getBirthday());  
7.      }  
8.  }  
9.  ComparisonProvider myComparisonProvider = **new** ComparisonProvider();  
10. Arrays.sort(rosterAsArray, myComparisonProvider::compareByName);  
</code></pre><p>The method reference myComparisonProvider::compareByName invokes the method compareByName that is part of the object myComparisonProvider. The JRE infers the method type arguments, which in this case are (Person, Person).</p><h4>4.20.1.3 Reference to an Instance Method of an Arbitrary Object of a Particular Type</h4><p>The following is an example of a reference to an instance method of an arbitrary object of a particular type:</p><pre><code class="language-java">1.  String[] stringArray = {  
2.      &quot;Barbara&quot;, &quot;James&quot;, &quot;Mary&quot;, &quot;John&quot;, &quot;Patricia&quot;, &quot;Robert&quot;, &quot;Michael&quot;, &quot;Linda&quot;  
3.  };  
4.  Arrays.sort(stringArray, String::compareToIgnoreCase);  
</code></pre><p>The equivalent lambda expression for the method reference String::compareToIgnoreCase would have the formal parameter list (String a, String b), where a and b are arbitrary names used to better describe this example. The method reference would invoke the method a.compareToIgnoreCase(b).</p><h4>4.20.1.4 Reference to a Constructor</h4><p>You can reference a constructor in the same way as a static method by using the name new. The following method copies elements from one collection to another:</p><pre><code class="language-java">1.  **public** **static** &lt; T, SOURCE **extends** Collection &lt; T &gt; , DEST **extends** Collection &lt; T &gt;&gt; DEST transferElements(SOURCE sourceCollection, Supplier &lt; DEST &gt; collectionFactory) {  
2.      DEST result = collectionFactory.get();  
3.      **for** (T t: sourceCollection) {  
4.          result.add(t);  
5.      }  
6.      **return** result;  
7.  }  
</code></pre><p>The functional interface Supplier contains one method get that takes no arguments and returns an object. Consequently, you can invoke the method transferElements with a lambda expression as follows:</p><pre><code class="language-java">1.  Set &lt; Person &gt; rosterSetLambda = transferElements(roster, () - &gt; {  
2.      **return** **new** HashSet &lt; &gt; ();  
3.  });  
</code></pre><p>You can use a constructor reference in place of the lambda expression as follows:</p><pre><code class="language-java">1.  Set &lt; Person &gt; rosterSet = transferElements(roster, HashSet::**new**);  
</code></pre><p>The Java compiler infers that you want to create a HashSet collection that contains elements of type Person. Alternatively, you can specify this as follows:</p><pre><code class="language-java">1.  Set &lt; Person &gt; rosterSet = transferElements(roster, HashSet &lt; Person &gt; ::**new**);  
</code></pre><h2>4.21 When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions</h2><p>As mentioned in the section <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html">Nested Classes</a>, nested classes enable you to logically group classes that are only used in one place, increase the use of encapsulation, and create more readable and maintainable code. Local classes, anonymous classes, and lambda expressions also impart these advantages; however, they are intended to be used for more specific situations:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html">Local class</a>: Use it if you need to create more than one instance of a class, access its constructor, or introduce a new, named type (because, for example, you need to invoke additional methods later).</li><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">Anonymous class</a>: Use it if you need to declare fields or additional methods.</li><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Lambda expression</a>:<ul><li>Use it if you are encapsulating a single unit of behavior that you want to pass to other code. For example, you would use a lambda expression if you want a certain action performed on each element of a collection, when a process is completed, or when a process encounters an error.</li><li>Use it if you need a simple instance of a functional interface and none of the preceding criteria apply (for example, you do not need a constructor, a named type, fields, or additional methods).</li></ul></li><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html">Nested class</a>: Use it if your requirements are similar to those of a local class, you want to make the type more widely available, and you don&#x27;t require access to local variables or method parameters.<ul><li>Use a non-static nested class (or inner class) if you require access to an enclosing instance&#x27;s non-public fields and methods. Use a static nested class if you don&#x27;t require this access.</li></ul></li></ul><h2>4.22 Enum Types</h2><p>An <em>enum type</em> is a special data type that enables for a variable to be a set of predefined constants. The variable must be equal to one of the values that have been predefined for it. Common examples include compass directions (values of NORTH, SOUTH, EAST, and WEST) and the days of the week. Because they are constants, the names of an enum type&#x27;s fields are in uppercase letters. In the Java programming language, you define an enum type by using the enum keyword. For example, you would specify a days-of-the-week enum type as:</p><pre><code class="language-java">1.  **public** **enum** Day {  
2.      SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY  
3.  }  
```java
You should use enum types any time you need to represent a fixed set of constants. That includes natural enum types such as the planets in our solar system and data sets where you know all possible values at compile time---for example, the choices on a menu, command line flags, and so on.

Here is some code that shows you how to use the Day enum defined above:
```java
1.  **public** **class** EnumTest {  
2.      Day day;  
3.      **public** EnumTest(Day day) {  
4.          **this**.day = day;  
5.      }  
6.      **public** **void** tellItLikeItIs() {  
7.          **switch** (day) {  
8.              **case** MONDAY:  
9.                  System.out.println(&quot;Mondays are bad.&quot;);  
10.                 **break**;  
11.             **case** FRIDAY:  
12.                 System.out.println(&quot;Fridays are better.&quot;);  
13.                 **break**;  
14.             **case** SATURDAY:  
15.             **case** SUNDAY:  
16.                 System.out.println(&quot;Weekends are best.&quot;);  
17.                 **break**;  
18.             **default**:  
19.                 System.out.println(&quot;Midweek days are so-so.&quot;);  
20.                 **break**;  
21.         }  
22.     }  
23.     **public** **static** **void** main(String[] args) {  
24.         EnumTest firstDay = **new** EnumTest(Day.MONDAY);  
25.         firstDay.tellItLikeItIs();  
26.         EnumTest thirdDay = **new** EnumTest(Day.WEDNESDAY);  
27.         thirdDay.tellItLikeItIs();  
28.         EnumTest fifthDay = **new** EnumTest(Day.FRIDAY);  
29.         fifthDay.tellItLikeItIs();  
30.         EnumTest sixthDay = **new** EnumTest(Day.SATURDAY);  
31.         sixthDay.tellItLikeItIs();  
32.         EnumTest seventhDay = **new** EnumTest(Day.SUNDAY);  
33.         seventhDay.tellItLikeItIs();  
34.     }  
35. }
```  
36. The output is: Mondays are bad.Midweek days are so - so.Fridays are better.Weekends are best.Weekends are best.  

Java programming language enum types are much more powerful than their counterparts in other languages. The enum declaration defines a *class* (called an *enum type*). The enum class body can include methods and other fields. The compiler automatically adds some special methods when it creates an enum. For example, they have a static values method that returns an array containing all of the values of the enum in the order they are declared. This method is commonly used in combination with the for-each construct to iterate over the values of an enum type. For example, this code from the Planet class example below iterates over all the planets in the solar system.
```java
1.  **for** (Planet p: Planet.values()) {  
2.      System.out.printf(&quot;Your weight on %s is %f%n&quot;, p, p.surfaceWeight(mass));  
3.  }  
</code></pre><p><strong>Note:</strong> <em>All</em> enums implicitly extend java.lang.Enum. Because a class can only extend one parent (see <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classdecl.html">Declaring Classes</a>), the Java language does not support multiple inheritance of state (see <a href="https://docs.oracle.com/javase/tutorial/java/IandI/multipleinheritance.html">Multiple Inheritance of State, Implementation, and Type</a>), and therefore an enum cannot extend anything else.</p><p>In the following example, Planet is an enum type that represents the planets in the solar system. They are defined with constant mass and radius properties.</p><p>Each enum constant is declared with values for the mass and radius parameters. These values are passed to the constructor when the constant is created. Java requires that the constants be defined first, prior to any fields or methods. Also, when there are fields and methods, the list of enum constants must end with a semicolon.</p><p><strong>Note:</strong> The constructor for an enum type must be package-private or private access. It automatically creates the constants that are defined at the beginning of the enum body. You cannot invoke an enum constructor yourself.</p><p>In addition to its properties and constructor, Planet has methods that allow you to retrieve the surface gravity and weight of an object on each planet. Here is a sample program that takes your weight on earth (in any unit) and calculates and prints your weight on all of the planets (in the same unit):</p><pre><code class="language-java">1.  **public** **enum** Planet {  
2.      MERCURY(3.303e+23, 2.4397e6), VENUS(4.869e+24, 6.0518e6), EARTH(5.976e+24, 6.37814e6), MARS(6.421e+23, 3.3972e6), JUPITER(1.9e+27, 7.1492e7), SATURN(5.688e+26, 6.0268e7), URANUS(8.686e+25, 2.5559e7), NEPTUNE(1.024e+26, 2.4746e7);  
3.      **private** **final** **double** mass; // in kilograms  
4.      **private** **final** **double** radius; // in meters  
5.      Planet(**double** mass, **double** radius) {  
6.          **this**.mass = mass;  
7.          **this**.radius = radius;  
8.      }  
9.      **private** **double** mass() {  
10.         **return** mass;  
11.     }  
12.     **private** **double** radius() {  
13.             **return** radius;  
14.         } // universal gravitational constant  (m3 kg-1 s-2)  
15.     **public** **static** **final** **double** G = 6.67300E-11;  
16.     **double** surfaceGravity() {  
17.         **return** G \* mass / (radius \* radius);  
18.     }  
19.     **double** surfaceWeight(**double** otherMass) {  
20.         **return** otherMass \* surfaceGravity();  
21.     }  
22.     **public** **static** **void** main(String[] args) {  
23.         **if** (args.length != 1) {  
24.             System.err.println(&quot;Usage: java Planet &lt;earth_weight&gt;&quot;);  
25.             System.exit(-1);  
26.         }  
27.         **double** earthWeight = Double.parseDouble(args[0]);  
28.         **double** mass = earthWeight / EARTH.surfaceGravity();  
29.         **for** (Planet p: Planet.values()) System.out.printf(&quot;Your weight on %s is %f%n&quot;, p, p.surfaceWeight(mass));  
30.     }  
31. }  
</code></pre><ol start="32"><li>If you run  Planet.<strong>class</strong>  from the command line <strong>with</strong> an argument of 175, you get <strong>this</strong> output: %code%nbsp;java Planet 175 Your weight on MERCURY is 66.107583 Your weight on VENUS is 158.374842 Your weight on EARTH is 175.000000 Your weight on MARS is 66.279007 Your weight on JUPITER is 442.847567 Your weight on SATURN is 186.552719 Your weight on URANUS is 158.397260 Your weight on NEPTUNE is 199.207413  </li></ol><h1>5 Interfaces and Inheritance</h1><h2>5.1 Interfaces</h2><p>There are a number of situations in software engineering when it is important for disparate groups of programmers to agree to a &quot;contract&quot; that spells out how their software interacts. Each group should be able to write their code without any knowledge of how the other group&#x27;s code is written. Generally speaking, <em>interfaces</em> are such contracts.</p><h3>5.1.1 Interfaces in Java</h3><p>In the Java programming language, an <em>interface</em> is a reference type, similar to a class, that can contain <em>only</em> constants, method signatures, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods. Interfaces cannot be instantiated---they can only be <em>implemented</em> by classes or <em>extended</em> by other interfaces.</p><ol><li>Defining an <strong>interface</strong> is similar to creating a <strong>new</strong> <strong>class</strong>: </li><li><strong>public</strong> <strong>interface</strong> OperateCar { // constant declarations, if any // method signatures // An enum with values RIGHT, LEFT  </li><li>    <strong>int</strong> turn(Direction direction, <strong>double</strong> radius, <strong>double</strong> startSpeed, <strong>double</strong> endSpeed);  </li><li>    <strong>int</strong> changeLanes(Direction direction, <strong>double</strong> startSpeed, <strong>double</strong> endSpeed);  </li><li>    <strong>int</strong> signalTurn(Direction direction, <strong>boolean</strong> signalOn);  </li><li>    <strong>int</strong> getRadarFront(<strong>double</strong> distanceToCar, <strong>double</strong> speedOfCar);  </li><li>    <strong>int</strong> getRadarRear(<strong>double</strong> distanceToCar, <strong>double</strong> speedOfCar);<!-- -->.<!-- -->..<!-- -->.<!-- -->.. // more method signatures  </li><li>}  </li></ol><p><strong>Note that the method signatures have no braces and are terminated with a semicolon</strong>.</p><p>To use an interface, you write a class that <em>implements</em> the interface. When an instantiable class implements an interface, it provides a method body for each of the methods declared in the interface. For example,</p><ol><li><strong>public</strong> <strong>class</strong> OperateBMW760i <strong>implements</strong> OperateCar { // the OperateCar method signatures, with implementation -- // for example:  </li><li>    <strong>int</strong> signalTurn(Direction direction, <strong>boolean</strong> signalOn) { // code to turn BMW&#x27;s LEFT turn indicator lights on // code to turn BMW&#x27;s LEFT turn indicator lights off // code to turn BMW&#x27;s RIGHT turn indicator lights on // code to turn BMW&#x27;s RIGHT turn indicator lights off  </li><li>        } // other members, as needed -- for example, helper classes not  // visible to clients of the interface  </li><li>}  </li></ol><p>In the robotic car example above, it is the automobile manufacturers who will implement the interface. Chevrolet&#x27;s implementation will be substantially different from that of Toyota, of course, but both manufacturers will adhere to the same interface. The guidance manufacturers, who are the clients of the interface, will build systems that use GPS data on a car&#x27;s location, digital street maps, and traffic data to drive the car. In so doing, the guidance systems will invoke the interface methods: turn, change lanes, brake, accelerate, and so forth.</p><h3>5.1.2 Interfaces as APIs</h3><p>The robotic car example shows an interface being used as an industry standard <em>Application Programming Interface (API)</em>. APIs are also common in commercial software products. Typically, a company sells a software package that contains complex methods that another company wants to use in its own software product. An example would be a package of digital image processing methods that are sold to companies making end-user graphics programs. The image processing company writes its classes to implement an interface, which it makes public to its customers. The graphics company then invokes the image processing methods using the signatures and return types defined in the interface. While the image processing company&#x27;s API is made public (to its customers), its implementation of the API is kept as a closely guarded secret---in fact, it may revise the implementation at a later date as long as it continues to implement the original interface that its customers have relied on.</p><h2>5.2 Defining an Interface</h2><p>An interface declaration consists of modifiers, the keyword interface, the interface name, a comma-separated list of parent interfaces (if any), and the interface body. For example:</p><ol><li><strong>public</strong> <strong>interface</strong> GroupedInterface <strong>extends</strong> Interface1, Interface2, Interface3 { // constant declarations // base of natural logarithms  </li><li>    <strong>double</strong> E = 2.718282; // method signatures  </li><li>    <strong>void</strong> doSomething(<strong>int</strong> i, <strong>double</strong> x);  </li><li>    <strong>int</strong> doSomethingElse(String s);  </li><li>}  </li></ol><p>The public access specifier indicates that the interface can be used by any class in any package. If you do not specify that the interface is public, then your interface is accessible only to classes defined in the same package as the interface.</p><p>An interface can extend other interfaces, just as a class subclass or extend another class. However, whereas a class can extend only one other class, an interface can extend any number of interfaces. The interface declaration includes a comma-separated list of all the interfaces that it extends.</p><h3>5.2.1 The Interface Body</h3><p>The interface body can contain <a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">abstract methods</a>, <a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">default methods</a>, and <a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html#static">static methods</a>. An abstract method within an interface is followed by a semicolon, but no braces (an abstract method does not contain an implementation). Default methods are defined with the default modifier, and static methods with the static keyword. All abstract, default, and static methods in an interface are implicitly public, so you can omit the public modifier.</p><p>In addition, an interface can contain constant declarations. All constant values defined in an interface are implicitly public, static, and final. Once again, you can omit these modifiers.</p><h2>5.3 Implementing an Interface</h2><p>To declare a class that implements an interface, you include an implements clause in the class declaration. Your class can implement more than one interface, so the implements keyword is followed by a comma-separated list of the interfaces implemented by the class. By convention, the implements clause follows the extends clause, if there is one.</p><h3>5.3.1 A Sample Interface, Relatable</h3><p>Consider an interface that defines how to compare the size of objects.</p><ol><li><strong>public</strong> <strong>interface</strong> Relatable { // this (object calling isLargerThan) // and other must be instances of  // the same class returns 1, 0, -1  // if this is greater than,  // equal to, or less than other  </li><li>    <strong>public</strong> <strong>int</strong> isLargerThan(Relatable other);  </li><li>}  </li></ol><p>If you want to be able to compare the size of similar objects, no matter what they are, the class that instantiates them should implement Relatable.</p><p>Any class can implement Relatable if there is some way to compare the relative &quot;size&quot; of objects instantiated from the class. For strings, it could be number of characters; can implement the isLargerThan() method.</p><p>If you know that a class implements Relatable, then you know that you can compare the size of the objects instantiated from that class.</p><h3>5.3.2 Implementing the Relatable Interface</h3><p>Here is the Rectangle class that was presented in the <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/objectcreation.html">Creating Objects</a> section, rewritten to implement Relatable.</p><ol><li><strong>public</strong> <strong>class</strong> RectanglePlus <strong>implements</strong> Relatable {  </li><li>    <strong>public</strong> <strong>int</strong> width = 0;  </li><li>    <strong>public</strong> <strong>int</strong> height = 0;  </li><li>    <strong>public</strong> Point origin; // four constructors  </li><li>    <strong>public</strong> RectanglePlus() {  </li><li>        origin = <strong>new</strong> Point(0, 0);  </li><li>    }  </li><li>    <strong>public</strong> RectanglePlus(Point p) {  </li><li>        origin = p;  </li><li>    }  </li><li>    <strong>public</strong> RectanglePlus(<strong>int</strong> w, <strong>int</strong> h) {  </li><li>        origin = <strong>new</strong> Point(0, 0);  </li><li>        width = w;  </li><li>        height = h;  </li><li>    }  </li><li>    <strong>public</strong> RectanglePlus(Point p, <strong>int</strong> w, <strong>int</strong> h) {  </li><li>            origin = p;  </li><li>            width = w;  </li><li>            height = h;  </li><li>        } // a method for moving the rectangle  </li><li>    <strong>public</strong> <strong>void</strong> move(<strong>int</strong> x, <strong>int</strong> y) {  </li><li>            origin.x = x;  </li><li>            origin.y = y;  </li><li>        } // a method for computing // the area of the rectangle  </li><li>    <strong>public</strong> <strong>int</strong> getArea() {  </li><li>            <strong>return</strong> width <!-- -->*<!-- --> height;  </li><li>        } // a method required to implement // the Relatable interface  </li><li>    <strong>public</strong> <strong>int</strong> isLargerThan(Relatable other) {  </li><li>        RectanglePlus otherRect = (RectanglePlus) other;  </li><li>        <strong>if</strong> (<strong>this</strong>.getArea() &lt; otherRect.getArea()) <strong>return</strong> -1;  </li><li>        <strong>else</strong> <strong>if</strong> (<strong>this</strong>.getArea() &gt; otherRect.getArea()) <strong>return</strong> 1;  </li><li>        <strong>else</strong> <strong>return</strong> 0;  </li><li>    }  </li><li>}  </li></ol><p>Because RectanglePlus implements Relatable, the size of any two RectanglePlus objects can be compared.</p><p><strong>Note:</strong> The isLargerThan method, as defined in the Relatable interface, takes an object of type Relatable. The line of code, shown in bold in the previous example, casts otherto a RectanglePlus instance. <strong>Type casting tells the compiler what the object really is. Invoking getArea directly on the other instance (other.getArea()) would fail to compile because the compiler does not understand that other is actually an instance of RectanglePlus.</strong></p><h2>5.4 Using an Interface as a Type</h2><p>When you define a new interface, you are defining a new reference data type. You can use interface names anywhere you can use any other data type name. If you define a reference variable whose type is an interface, any object you assign to it <em>must</em> be an instance of a class that implements the interface.</p><p>As an example, here is a method for finding the largest object in a pair of objects, for <em>any</em> objects that are instantiated from a class that implements Relatable:</p><ol><li><strong>public</strong> Object findLargest(Object object1, Object object2) {  </li><li>    Relatable obj1 = (Relatable) object1;  </li><li>    Relatable obj2 = (Relatable) object2;  </li><li>    <strong>if</strong> ((obj1).isLargerThan(obj2) &gt; 0) <strong>return</strong> object1;  </li><li>    <strong>else</strong> <strong>return</strong> object2;  </li><li>}  </li></ol><p>By casting object1 to a Relatable type, it can invoke the isLargerThan method.</p><p>If you make a point of implementing Relatable in a wide variety of classes, the objects instantiated from <em>any</em> of those classes can be compared with the findLargest() method---provided that both objects are of the same class. Similarly, they can all be compared with the following methods:</p><ol><li><strong>public</strong> Object findSmallest(Object object1, Object object2) {  </li><li>    Relatable obj1 = (Relatable) object1;  </li><li>    Relatable obj2 = (Relatable) object2;  </li><li>    <strong>if</strong> ((obj1).isLargerThan(obj2) &lt; 0) <strong>return</strong> object1;  </li><li>    <strong>else</strong> <strong>return</strong> object2;  </li><li>}  </li><li><strong>public</strong> <strong>boolean</strong> isEqual(Object object1, Object object2) {  </li><li>    Relatable obj1 = (Relatable) object1;  </li><li>    Relatable obj2 = (Relatable) object2;  </li><li>    <strong>if</strong> ((obj1).isLargerThan(obj2) == 0) <strong>return</strong> <strong>true</strong>;  </li><li>    <strong>else</strong> <strong>return</strong> <strong>false</strong>;  </li><li>}  </li></ol><p>These methods work for any &quot;relatable&quot; objects, no matter what their class inheritance is. When they implement Relatable, they can be of both their own class (or superclass) type and a Relatable type. This gives them some of the advantages of multiple inheritance, where they can have behavior from both a superclass and an interface.</p><h2>5.5 Evolving Interfaces</h2><p>Consider an interface that you have developed called DoIt:</p><ol><li><strong>public</strong> <strong>interface</strong> DoIt {  </li><li>    <strong>void</strong> doSomething(<strong>int</strong> i, <strong>double</strong> x);  </li><li>    <strong>int</strong> doSomethingElse(String s);  </li><li>}  </li></ol><p>Suppose that, at a later time, you want to add a third method to DoIt, so that the interface now becomes:</p><ol><li><strong>public</strong> <strong>interface</strong> DoIt {  </li><li>    <strong>void</strong> doSomething(<strong>int</strong> i, <strong>double</strong> x);  </li><li>    <strong>int</strong> doSomethingElse(String s);  </li><li>    <strong>boolean</strong> didItWork(<strong>int</strong> i, <strong>double</strong> x, String s);  </li><li>}  </li></ol><p>If you make this change, then all classes that implement the old DoIt interface will break because they no longer implement the old interface. Programmers relying on this interface will protest loudly.</p><p>Try to anticipate all uses for your interface and specify it completely from the beginning. If you want to add additional methods to an interface, you have several options. You could create a DoItPlus interface that extends DoIt:</p><ol><li><strong>public</strong> <strong>interface</strong> DoItPlus <strong>extends</strong> DoIt {  </li><li>    <strong>boolean</strong> didItWork(<strong>int</strong> i, <strong>double</strong> x, String s);  </li><li>}  </li></ol><p>Now users of your code can choose to continue to use the old interface or to upgrade to the new interface.</p><p>Alternatively, you can define your new methods as <a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">default methods</a>. The following example defines a default method named didItWork:</p><ol><li><strong>public</strong> <strong>interface</strong> DoIt {  </li><li>    <strong>void</strong> doSomething(<strong>int</strong> i, <strong>double</strong> x);  </li><li>    <strong>int</strong> doSomethingElse(String s);  </li><li>    <strong>default</strong> <strong>boolean</strong> didItWork(<strong>int</strong> i, <strong>double</strong> x, String s) { // Method body   </li><li>    }  </li><li>}  </li></ol><p>Note that you must provide an implementation for default methods. You could also define new <a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html#static">static methods</a> to existing interfaces. Users who have classes that implement interfaces enhanced with new default or static methods do not have to modify or recompile them to accommodate the additional methods.</p><h2>5.6 Default Methods</h2><p>The section <a href="https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html">Interfaces</a> describes an example that involves manufacturers of computer-controlled cars who publish industry-standard interfaces that describe which methods can be invoked to operate their cars. What if those computer-controlled car manufacturers add new functionality, such as flight, to their cars? These manufacturers would need to specify new methods to enable other companies (such as electronic guidance instrument manufacturers) to adapt their software to flying cars. Where would these car manufacturers declare these new flight-related methods? If they add them to their original interfaces, then programmers who have implemented those interfaces would have to rewrite their implementations. If they add them as static methods, then programmers would regard them as utility methods, not as essential, core methods.</p><p><strong>Default methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older versions of those interfaces.</strong></p><p>Consider the following interface, <a href="https://docs.oracle.com/javase/tutorial/java/IandI/examples/TimeClient.java">TimeClient</a>,</p><ol><li><strong>import</strong> java.time.*;  </li><li><strong>public</strong> <strong>interface</strong> TimeClient {  </li><li>    <strong>void</strong> setTime(<strong>int</strong> hour, <strong>int</strong> minute, <strong>int</strong> second);  </li><li>    <strong>void</strong> setDate(<strong>int</strong> day, <strong>int</strong> month, <strong>int</strong> year);  </li><li>    <strong>void</strong> setDateAndTime(<strong>int</strong> day, <strong>int</strong> month, <strong>int</strong> year, <strong>int</strong> hour, <strong>int</strong> minute, <strong>int</strong> second);  </li><li>    LocalDateTime getLocalDateTime();  </li><li>}  </li></ol><p>The following class, <a href="https://docs.oracle.com/javase/tutorial/java/IandI/examples/defaultmethods/SimpleTimeClient.java">SimpleTimeClient</a>, implements TimeClient:</p><ol><li><strong>package</strong> defaultmethods;  </li><li><strong>import</strong> java.time.*;  </li><li><strong>import</strong> java.lang.*;  </li><li><strong>import</strong> java.util.*;  </li><li><strong>public</strong> <strong>class</strong> SimpleTimeClient <strong>implements</strong> TimeClient {  </li><li>    <strong>private</strong> LocalDateTime dateAndTime;  </li><li>    <strong>public</strong> SimpleTimeClient() {  </li><li>        dateAndTime = LocalDateTime.now();  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> setTime(<strong>int</strong> hour, <strong>int</strong> minute, <strong>int</strong> second) {  </li><li>        LocalDate currentDate = LocalDate.from(dateAndTime);  </li><li>        LocalTime timeToSet = LocalTime.of(hour, minute, second);  </li><li>        dateAndTime = LocalDateTime.of(currentDate, timeToSet);  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> setDate(<strong>int</strong> day, <strong>int</strong> month, <strong>int</strong> year) {  </li><li>        LocalDate dateToSet = LocalDate.of(day, month, year);  </li><li>        LocalTime currentTime = LocalTime.from(dateAndTime);  </li><li>        dateAndTime = LocalDateTime.of(dateToSet, currentTime);  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> setDateAndTime(<strong>int</strong> day, <strong>int</strong> month, <strong>int</strong> year, <strong>int</strong> hour, <strong>int</strong> minute, <strong>int</strong> second) {  </li><li>        LocalDate dateToSet = LocalDate.of(day, month, year);  </li><li>        LocalTime timeToSet = LocalTime.of(hour, minute, second);  </li><li>        dateAndTime = LocalDateTime.of(dateToSet, timeToSet);  </li><li>    }  </li><li>    <strong>public</strong> LocalDateTime getLocalDateTime() {  </li><li>        <strong>return</strong> dateAndTime;  </li><li>    }  </li><li>    <strong>public</strong> String toString() {  </li><li>        <strong>return</strong> dateAndTime.toString();  </li><li>    }  </li><li>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String<!-- -->.<!-- -->..args) {  </li><li>        TimeClient myTimeClient = <strong>new</strong> SimpleTimeClient();  </li><li>        System.out.println(myTimeClient.toString());  </li><li>    }  </li><li>}  </li></ol><p>Suppose that you want to add new functionality to the TimeClient interface, such as the ability to specify a time zone through a <a href="https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html">ZonedDateTime</a> object (which is like a <a href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html">LocalDateTime</a> object except that it stores time zone information):</p><ol><li><strong>public</strong> <strong>interface</strong> TimeClient {  </li><li>    <strong>void</strong> setTime(<strong>int</strong> hour, <strong>int</strong> minute, <strong>int</strong> second);  </li><li>    <strong>void</strong> setDate(<strong>int</strong> day, <strong>int</strong> month, <strong>int</strong> year);  </li><li>    <strong>void</strong> setDateAndTime(<strong>int</strong> day, <strong>int</strong> month, <strong>int</strong> year, <strong>int</strong> hour, <strong>int</strong> minute, <strong>int</strong> second);  </li><li>    LocalDateTime getLocalDateTime();  </li><li>    ZonedDateTime getZonedDateTime(String zoneString);  </li><li>}  </li></ol><p>Following this modification to the TimeClient interface, you would also have to modify the class SimpleTimeClient and implement the method getZonedDateTime. However, rather than leaving getZonedDateTime as abstract (as in the previous example), you can instead define a <em>default implementation</em>. (Remember that an <a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">abstract method</a> is a method declared without an implementation.)</p><p><strong>package</strong> defaultmethods;  </p><p><strong>import</strong> java.time.*;  </p><p><strong>public</strong> <strong>interface</strong> TimeClient {  </p><p>    <strong>void</strong> setTime(<strong>int</strong> hour, <strong>int</strong> minute, <strong>int</strong> second);  </p><p>    <strong>void</strong> setDate(<strong>int</strong> day, <strong>int</strong> month, <strong>int</strong> year);  </p><p>    <strong>void</strong> setDateAndTime(<strong>int</strong> day, <strong>int</strong> month, <strong>int</strong> year, <strong>int</strong> hour, <strong>int</strong> minute, <strong>int</strong> second);  </p><p>    LocalDateTime getLocalDateTime();  </p><p>    <strong>static</strong> ZoneId getZoneId(String zoneString) {  </p><p>        <strong>try</strong> {  </p><p>            <strong>return</strong> ZoneId.of(zoneString);  </p><p>        } <strong>catch</strong> (DateTimeException e) {  </p><p>            System.err.println(&quot;Invalid time zone: &quot; + zoneString + &quot;; using default time zone instead.&quot;);  </p><p>            <strong>return</strong> ZoneId.systemDefault();  </p><p>        }  </p><p>    }  </p><p>    <strong>default</strong> ZonedDateTime getZonedDateTime(String zoneString) {  </p><p>        <strong>return</strong> ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString));  </p><p>    }  </p><p>}  </p><p>You specify that a method definition in an interface is a default method with the default keyword at the beginning of the method signature. All method declarations in an interface, including default methods, are implicitly public, so you can omit the public modifier.</p><p>With this interface, you do not have to modify the class SimpleTimeClient, and this class (and any class that implements the interface TimeClient), will have the method getZonedDateTime already defined. The following example, <a href="https://docs.oracle.com/javase/tutorial/java/IandI/examples/defaultmethods/TestSimpleTimeClient.java">TestSimpleTimeClient</a>, invokes the method getZonedDateTime from an instance of SimpleTimeClient:</p><p>[]{#bookmark=id.3im3ia3}</p><p><strong>package</strong> defaultmethods;  </p><p><strong>import</strong> java.time.*;  </p><p><strong>import</strong> java.lang.*;  </p><p><strong>import</strong> java.util.*;  </p><p><strong>public</strong> <strong>class</strong> TestSimpleTimeClient {  </p><p>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String<!-- -->.<!-- -->..args) {  </p><p>        TimeClient myTimeClient = <strong>new</strong> SimpleTimeClient();  </p><p>        System.out.println(&quot;Current time: &quot; + myTimeClient.toString());  </p><p>        System.out.println(&quot;Time in California: &quot; + myTimeClient.getZonedDateTime(&quot;Blah blah&quot;).toString());  </p><p>    }  </p><p>}  </p><h3>5.6.1 Extending Interfaces That Contain Default Methods</h3><p>When you extend an interface that contains a default method, you can do the following:</p><ul><li>Not mention the default method at all, which lets your extended interface inherit the default method.</li><li>Redeclare the default method, which makes it abstract.</li><li>Redefine the default method, which overrides it.</li></ul><p>Suppose that you extend the interface TimeClient as follows:</p><ol><li><strong>public</strong> <strong>interface</strong> AnotherTimeClient <strong>extends</strong> TimeClient {}  </li></ol><p>Any class that implements the interface AnotherTimeClient will have the implementation specified by the default method TimeClient.getZonedDateTime.</p><p>Suppose that you extend the interface TimeClient as follows:</p><ol><li><strong>public</strong> <strong>interface</strong> AbstractZoneTimeClient <strong>extends</strong> TimeClient {  </li><li>    <strong>public</strong> ZonedDateTime getZonedDateTime(String zoneString);  </li><li>}  </li></ol><p>Any class that implements the interface AbstractZoneTimeClient will have to implement the method getZonedDateTime; this method is an abstract method like all other nondefault (and nonstatic) methods in an interface.</p><p>Suppose that you extend the interface TimeClient as follows:</p><ol><li><strong>public</strong> <strong>interface</strong> HandleInvalidTimeZoneClient <strong>extends</strong> TimeClient {  </li><li>    <strong>default</strong> <strong>public</strong> ZonedDateTime getZonedDateTime(String zoneString) {  </li><li>        <strong>try</strong> {  </li><li>            <strong>return</strong> ZonedDateTime.of(getLocalDateTime(), ZoneId.of(zoneString));  </li><li>        } <strong>catch</strong> (DateTimeException e) {  </li><li>            System.err.println(&quot;Invalid zone ID: &quot; + zoneString + &quot;; using the default time zone instead.&quot;);  </li><li>            <strong>return</strong> ZonedDateTime.of(getLocalDateTime(), ZoneId.systemDefault());  </li><li>        }  </li><li>    }  </li><li>}  </li></ol><p>Any class that implements the interface HandleInvalidTimeZoneClient will use the implementation of getZonedDateTime specified by this interface instead of the one specified by the interface TimeClient.</p><h3>5.6.2 Static Methods</h3><p>In addition to default methods, you can define <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html">static methods </a>in interfaces. (A static method is a method that is associated with the class in which it is defined rather than with any object. Every instance of the class shares its static methods.) This makes it easier for you to organize helper methods in your libraries; you can keep static methods specific to an interface in the same interface rather than in a separate class. The following example defines a static method that retrieves a <a href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html">ZoneId</a> object corresponding to a time zone identifier; it uses the system default time zone if there is no ZoneId object corresponding to the given identifier. (As a result, you can simplify the method getZonedDateTime):</p><ol><li><strong>public</strong> <strong>interface</strong> TimeClient { // <!-- -->.<!-- -->..  </li><li>    <strong>static</strong> <strong>public</strong> ZoneId getZoneId(String zoneString) {  </li><li>        <strong>try</strong> {  </li><li>            <strong>return</strong> ZoneId.of(zoneString);  </li><li>        } <strong>catch</strong> (DateTimeException e) {  </li><li>            System.err.println(&quot;Invalid time zone: &quot; + zoneString + &quot;; using default time zone instead.&quot;);  </li><li>            <strong>return</strong> ZoneId.systemDefault();  </li><li>        }  </li><li>    }  </li><li>    <strong>default</strong> <strong>public</strong> ZonedDateTime getZonedDateTime(String zoneString) {  </li><li>        <strong>return</strong> ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString));  </li><li>    }  </li><li>}  </li></ol><p>Like static methods in classes, you specify that a method definition in an interface is a static method with the static keyword at the beginning of the method signature. All method declarations in an interface, including static methods, are implicitly public, so you can omit the public modifier.</p><h3>5.6.3 Integrating Default Methods into Existing Libraries</h3><p>Default methods enable you to add new functionality to existing interfaces and ensure binary compatibility with code written for older versions of those interfaces. In particular, default methods enable you to add methods that accept lambda expressions as parameters to existing interfaces. This section demonstrates how the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html">Comparator</a> interface has been enhanced with default and static methods.</p><p>Consider the Card and Deck classes as described in <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/creating-questions.html">Questions and Exercises: Classes</a>. This example rewrites the <a href="https://docs.oracle.com/javase/tutorial/java/IandI/examples/defaultmethods/Card.java">Card</a> and <a href="https://docs.oracle.com/javase/tutorial/java/IandI/examples/defaultmethods/Deck.java">Deck</a> classes as interfaces. The Card interface contains two enumtypes (Suit and Rank) and two abstract methods (getSuit and getRank):</p><ol><li><strong>package</strong> defaultmethods;  </li><li><strong>public</strong> <strong>interface</strong> Card <strong>extends</strong> Comparable &lt; Card &gt; {  </li><li>    <strong>public</strong> <strong>enum</strong> Suit {  </li><li>        DIAMONDS(1, &quot;Diamonds&quot;), CLUBS(2, &quot;Clubs&quot;), HEARTS(3, &quot;Hearts&quot;), SPADES(4, &quot;Spades&quot;);  </li><li>        <strong>private</strong> <strong>final</strong> <strong>int</strong> value;  </li><li>        <strong>private</strong> <strong>final</strong> String text;  </li><li>        Suit(<strong>int</strong> value, String text) {  </li><li>            <strong>this</strong>.value = value;  </li><li>            <strong>this</strong>.text = text;  </li><li>        }  </li><li>        <strong>public</strong> <strong>int</strong> value() {  </li><li>            <strong>return</strong> value;  </li><li>        }  </li><li>        <strong>public</strong> String text() {  </li><li>            <strong>return</strong> text;  </li><li>        }  </li><li>    }  </li><li>    <strong>public</strong> <strong>enum</strong> Rank {  </li><li>        DEUCE(2, &quot;Two&quot;), THREE(3, &quot;Three&quot;), FOUR(4, &quot;Four&quot;), FIVE(5, &quot;Five&quot;), SIX(6, &quot;Six&quot;), SEVEN(7, &quot;Seven&quot;), EIGHT(8, &quot;Eight&quot;), NINE(9, &quot;Nine&quot;), TEN(10, &quot;Ten&quot;), JACK(11, &quot;Jack&quot;), QUEEN(12, &quot;Queen&quot;), KING(13, &quot;King&quot;), ACE(14, &quot;Ace&quot;);  </li><li>        <strong>private</strong> <strong>final</strong> <strong>int</strong> value;  </li><li>        <strong>private</strong> <strong>final</strong> String text;  </li><li>        Rank(<strong>int</strong> value, String text) {  </li><li>            <strong>this</strong>.value = value;  </li><li>            <strong>this</strong>.text = text;  </li><li>        }  </li><li>        <strong>public</strong> <strong>int</strong> value() {  </li><li>            <strong>return</strong> value;  </li><li>        }  </li><li>        <strong>public</strong> String text() {  </li><li>            <strong>return</strong> text;  </li><li>        }  </li><li>    }  </li><li>    <strong>public</strong> Card.Suit getSuit();  </li><li>    <strong>public</strong> Card.Rank getRank();  </li><li>}  </li></ol><p>The Deck interface contains various methods that manipulate cards in a deck:</p><ol><li><strong>package</strong> defaultmethods;  </li><li><strong>import</strong> java.util.*;  </li><li><strong>import</strong> java.util.stream.*;  </li><li><strong>import</strong> java.lang.*;  </li><li><strong>public</strong> <strong>interface</strong> Deck {  </li><li>    List &lt; Card &gt; getCards();  </li><li>    Deck deckFactory();  </li><li>    <strong>int</strong> size();  </li><li>    <strong>void</strong> addCard(Card card);  </li><li>    <strong>void</strong> addCards(List &lt; Card &gt; cards);  </li><li>    <strong>void</strong> addDeck(Deck deck);  </li><li>    <strong>void</strong> shuffle();  </li><li>    <strong>void</strong> sort();  </li><li>    <strong>void</strong> sort(Comparator &lt; Card &gt; c);  </li><li>    String deckToString();  </li><li>    Map &lt; Integer, Deck &gt; deal(<strong>int</strong> players, <strong>int</strong> numberOfCards) <strong>throws</strong> IllegalArgumentException;  </li><li>}  </li></ol><p>The class <a href="https://docs.oracle.com/javase/tutorial/java/IandI/examples/defaultmethods/PlayingCard.java">PlayingCard</a> implements the interface Card, and the class <a href="https://docs.oracle.com/javase/tutorial/java/IandI/examples/defaultmethods/StandardDeck.java">StandardDeck</a> implements the interface Deck.</p><p>The class StandardDeck implements the abstract method Deck.sort as follows:</p><ol><li><strong>public</strong> <strong>class</strong> StandardDeck <strong>implements</strong> Deck {  </li><li>    <strong>private</strong> List &lt; Card &gt; entireDeck; // <!-- -->.<!-- -->..  </li><li>    <strong>public</strong> <strong>void</strong> sort() {  </li><li>            Collections.sort(entireDeck);  </li><li>        } // <!-- -->.<!-- -->..  </li><li>}  </li></ol><p>The method Collections.sort sorts an instance of List whose element type implements the interface <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">Comparable</a>. The member entireDeck is an instance of List whose elements are of the type Card, which extends Comparable. The class PlayingCard implements the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html#compareTo-T-">Comparable.compareTo</a> method as follows:</p><ol><li><strong>public</strong> <strong>int</strong> hashCode() {  </li><li>    <strong>return</strong> ((suit.value() - 1) <!-- -->*<!-- --> 13) + rank.value();  </li><li>}  </li><li><strong>public</strong> <strong>int</strong> compareTo(Card o) {  </li><li>    <strong>return</strong> <strong>this</strong>.hashCode() - o.hashCode();  </li><li>}  </li></ol><p>The method compareTo causes the method StandardDeck.sort() to sort the deck of cards first by suit, and then by rank.</p><p>What if you want to sort the deck first by rank, then by suit? You would need to implement the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html">Comparator</a> interface to specify new sorting criteria, and use the method <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-java.util.Comparator-"><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code></a> (the version of the sort method that includes a Comparator parameter). You can define the following method in the class StandardDeck:</p><ol><li><strong>public</strong> <strong>void</strong> sort(Comparator &lt; Card &gt; c) {  </li><li>    Collections.sort(entireDeck, c);  </li><li>}  </li></ol><p>With this method, you can specify how the method Collections.sort sorts instances of the Card class. One way to do this is to implement the Comparator interface to specify how you want the cards sorted. The example <a href="https://docs.oracle.com/javase/tutorial/java/IandI/examples/defaultmethods/SortByRankThenSuit.java">SortByRankThenSuit</a> does this:</p><ol><li><strong>package</strong> defaultmethods;  </li><li><strong>import</strong> java.util.*;  </li><li><strong>import</strong> java.util.stream.*;  </li><li><strong>import</strong> java.lang.*;  </li><li><strong>public</strong> <strong>class</strong> SortByRankThenSuit <strong>implements</strong> Comparator &lt; Card &gt; {  </li><li>    <strong>public</strong> <strong>int</strong> compare(Card firstCard, Card secondCard) {  </li><li>        <strong>int</strong> compVal = firstCard.getRank().value() - secondCard.getRank().value();  </li><li>        <strong>if</strong> (compVal != 0) <strong>return</strong> compVal;  </li><li>        <strong>else</strong> <strong>return</strong> firstCard.getSuit().value() - secondCard.getSuit().value();  </li><li>    }  </li><li>}  </li></ol><p>The following invocation sorts the deck of playing cards first by rank, then by suit:</p><ol><li>StandardDeck myDeck = <strong>new</strong> StandardDeck();  </li><li>myDeck.shuffle();  </li><li>myDeck.sort(<strong>new</strong> SortByRankThenSuit());  </li></ol><p>However, this approach is too verbose; it would be better if you could specify <em>what</em> you want to sort, not <em>how</em> you want to sort. Suppose that you are the developer who wrote the Comparator interface. What default or static methods could you add to the Comparator interface to enable other developers to more easily specify sort criteria?</p><p>To start, suppose that you want to sort the deck of playing cards by rank, regardless of suit. You can invoke the StandardDeck.sort method as follows:</p><ol><li>StandardDeck myDeck = <strong>new</strong> StandardDeck();  </li><li>myDeck.shuffle();  </li><li>myDeck.sort((firstCard, secondCard) - &gt; firstCard.getRank().value() - secondCard.getRank().value());  </li></ol><p>Because the interface Comparator is a <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#approach6">functional interface</a>, you can use a lambda expression as an argument for the sort method. In this example, the lambda expression compares two integer values.</p><p>It would be simpler for your developers if they could create a Comparator instance by invoking the method Card.getRank only. In particular, it would be helpful if your developers could create a Comparator instance that compares any object that can return a numerical value from a method such as getValue or hashCode. The Comparator interface has been enhanced with this ability with the static method <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparing-java.util.function.Function-java.util.Comparator-">comparing</a>:</p><ol><li>myDeck.sort(Comparator.comparing((card) - &gt; card.getRank()));  </li><li>In <strong>this</strong> example, you can use a  method reference  instead: myDeck.sort(Comparator.comparing(Card::getRank));  </li></ol><p>This invocation better demonstrates <em>what</em> to sort rather than <em>how</em> to do it.</p><p>The Comparator interface has been enhanced with other versions of the static method comparing such as <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparingDouble-java.util.function.ToDoubleFunction-java.util.Comparator-">comparingDouble</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparingLong-java.util.function.ToLongFunction-">comparingLong</a> that enable you to create Comparatorinstances that compare other data types.</p><p>Suppose that your developers would like to create a Comparator instance that could compare objects with more than one criteria. For example, how would you sort the deck of playing cards first by rank, and then by suit? As before, you could use a lambda expression to specify these sort criteria:</p><ol><li>StandardDeck myDeck = <strong>new</strong> StandardDeck();  </li><li>myDeck.shuffle();  </li><li>myDeck.sort((firstCard, secondCard) - &gt; {  </li><li>    <strong>int</strong> compare = firstCard.getRank().value() - secondCard.getRank().value();  </li><li>    <strong>if</strong> (compare != 0) <strong>return</strong> compare;  </li><li>    <strong>else</strong> <strong>return</strong> firstCard.getSuit().value() - secondCard.getSuit().value();  </li><li>});  </li></ol><p>It would be simpler for your developers if they could build a Comparator instance from a series of Comparator instances. The Comparator interface has been enhanced with this ability with the default method <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#thenComparing-java.util.Comparator-">thenComparing</a>:</p><ol><li>myDeck.sort(Comparator.comparing(Card::getRank).thenComparing(Comparator.comparing(Card::getSuit)));  </li></ol><p>The Comparator interface has been enhanced with other versions of the default method thenComparing (such as <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#thenComparingDouble-java.util.function.ToDoubleFunction-">thenComparingDouble</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#thenComparingLong-java.util.function.ToLongFunction-">thenComparingLong</a>) that enable you to build Comparator instances that compare other data types.</p><p>Suppose that your developers would like to create a Comparator instance that enables them to sort a collection of objects in reverse order. For example, how would you sort the deck of playing cards first by descending order of rank, from Ace to Two (instead of from Two to Ace)? As before, you could specify another lambda expression. However, it would be simpler for your developers if they could reverse an existing Comparator by invoking a method. The Comparator interface has been enhanced with this ability with the default method <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#reversed--">reversed</a>:</p><ol><li>myDeck.sort(Comparator.comparing(Card::getRank).reversed().thenComparing(Comparator.comparing(Card::getSuit)));  </li></ol><p>This example demonstrates how the Comparator interface has been enhanced with default methods, static methods, lambda expressions, and method references to create more expressive library methods whose functionality programmers can quickly deduce by looking at how they are invoked. Use these constructs to enhance the interfaces in your libraries.</p><h2>5.7 Inheritance</h2><p>In the preceding lessons, you have seen <em>inheritance</em> mentioned several times. In the Java language, classes can be <em>derived</em> from other classes, thereby <em>inheriting</em> fields and methods from those classes.</p><p><strong>A class that is derived from another class is called a <em>subclass</em> (also a <em>derived class</em>, <em>extended class</em>, or <em>child class</em>). The class from which the subclass is derived is called a <em>superclass</em> (also a <em>base class</em> or a <em>parent class</em>).</strong></p><p>Excepting Object, which has no superclass, every class has one and only one direct superclass (single inheritance). In the absence of any other explicit superclass, every class is implicitly a subclass of Object.</p><p>Classes can be derived from classes that are derived from classes that are derived from classes, and so on, and ultimately derived from the topmost class, Object. Such a class is said to be <em>descended</em> from all the classes in the inheritance chain stretching back to Object.</p><p>The idea of inheritance is simple but powerful: When you want to create a new class and there is already a class that includes some of the code that you want, you can derive your new class from the existing class. In doing this, you can reuse the fields and methods of the existing class without having to write (and debug!) them yourself.</p><p>A subclass inherits all the <em>members</em> (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.</p><h3>5.7.1 The Java Platform Class Hierarchy</h3><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">Object</a> class, defined in the java.lang package, defines and implements behavior common to all classes---including the ones that you write. In the Java platform, many classes derive directly from Object, other classes derive from some of those classes, and so on, forming a hierarchy of classes. At the top of the hierarchy, Object is the most general of all classes. Classes near the bottom of the hierarchy provide more specialized behavior.</p><h3>5.7.2 An Example of Inheritance</h3><p>Here is the sample code for a possible implementation of a Bicycle class that was presented in the Classes and Objects lesson:</p><ol><li><strong>public</strong> <strong>class</strong> Bicycle { // the Bicycle class has three fields  </li><li>    <strong>public</strong> <strong>int</strong> cadence;  </li><li>    <strong>public</strong> <strong>int</strong> gear;  </li><li>    <strong>public</strong> <strong>int</strong> speed; // the Bicycle class has one constructor  </li><li>    <strong>public</strong> Bicycle(<strong>int</strong> startCadence, <strong>int</strong> startSpeed, <strong>int</strong> startGear) {  </li><li>            gear = startGear;  </li><li>            cadence = startCadence;  </li><li>            speed = startSpeed;  </li><li>        } // the Bicycle class has four methods  </li><li>    <strong>public</strong> <strong>void</strong> setCadence(<strong>int</strong> newValue) {  </li><li>        cadence = newValue;  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> setGear(<strong>int</strong> newValue) {  </li><li>        gear = newValue;  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> applyBrake(<strong>int</strong> decrement) {  </li><li>        speed -= decrement;  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> speedUp(<strong>int</strong> increment) {  </li><li>        speed += increment;  </li><li>    }  </li><li>}  </li></ol><p>A class declaration for a MountainBike class that is a subclass of Bicycle might look like this:</p><ol><li><strong>public</strong> <strong>class</strong> MountainBike <strong>extends</strong> Bicycle { // the MountainBike subclass adds one field  </li><li>    <strong>public</strong> <strong>int</strong> seatHeight; // the MountainBike subclass has one constructor  </li><li>    <strong>public</strong> MountainBike(<strong>int</strong> startHeight, <strong>int</strong> startCadence, <strong>int</strong> startSpeed, <strong>int</strong> startGear) {  </li><li>            <strong>super</strong>(startCadence, startSpeed, startGear);  </li><li>            seatHeight = startHeight;  </li><li>        } // the MountainBike subclass adds one method  </li><li>    <strong>public</strong> <strong>void</strong> setHeight(<strong>int</strong> newValue) {  </li><li>        seatHeight = newValue;  </li><li>    }  </li><li>}  </li></ol><p>MountainBike inherits all the fields and methods of Bicycle and adds the field seatHeight and a method to set it. Except for the constructor, it is as if you had written a new MountainBikeclass entirely from scratch, with four fields and five methods. However, you didn&#x27;t have to do all the work. This would be especially valuable if the methods in the Bicycle class were complex and had taken substantial time to debug.</p><h3>5.7.3 What You Can Do in a Subclass</h3><p>A subclass inherits all of the <em>public</em> and <em>protected</em> members of its parent, no matter what package the subclass is in. If the subclass is in the same package as its parent, it also inherits the <em>package-private</em> members of the parent. You can use the inherited members as is, replace them, hide them, or supplement them with new members:</p><ul><li>The inherited fields can be used directly, just like any other fields.</li><li>You can declare a field in the subclass with the same name as the one in the superclass, thus <em>hiding</em> it (not recommended).</li><li>You can declare new fields in the subclass that are not in the superclass.</li><li>The inherited methods can be used directly as they are.</li><li>You can write a new <em>instance</em> method in the subclass that has the same signature as the one in the superclass, thus <em>overriding</em> it.</li><li>You can write a new <em>static</em> method in the subclass that has the same signature as the one in the superclass, thus <em>hiding</em> it.</li><li>You can declare new methods in the subclass that are not in the superclass.</li><li>You can write a subclass constructor that invokes the constructor of the superclass, either implicitly or by using the keyword super.</li></ul><p>The following sections in this lesson will expand on these topics.</p><h3>5.7.4 Private Members in a Superclass</h3><p>A subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass.</p><p>A nested class has access to all the private members of its enclosing class---both fields and methods. Therefore, a public or protected nested class inherited by a subclass has indirect access to all of the private members of the superclass.</p><h3>5.7.5 Casting Objects</h3><p>We have seen that an object is of the data type of the class from which it was instantiated. For example, if we write</p><ol><li><strong>public</strong> MountainBike myBike = <strong>new</strong> MountainBike();  </li><li>then  myBike  is of type  MountainBike.  </li></ol><p>MountainBike is descended from Bicycle and Object. Therefore, a MountainBike is a Bicycle and is also an Object, and it can be used wherever Bicycle or Object objects are called for.</p><p>The reverse is not necessarily true: a Bicycle <em>may be</em> a MountainBike, but it isn&#x27;t necessarily. Similarly, an Object <em>may be</em> a Bicycle or a MountainBike, but it isn&#x27;t necessarily.</p><p><em>Casting</em> shows the use of an object of one type in place of another type, among the objects permitted by inheritance and implementations. For example, if we write</p><ol><li>Object obj = <strong>new</strong> MountainBike();  </li></ol><p>then obj is both an Object and a MountainBike (until such time as obj is assigned another object that is <em>not</em> a MountainBike). This is called <em>implicit casting</em>.</p><p>If, on the other hand, we write</p><ol><li>MountainBike myBike = obj;  </li></ol><p>we would get a compile-time error because obj is not known to the compiler to be a MountainBike. However, we can <em>tell</em> the compiler that we promise to assign a MountainBike to obj by <em>explicit casting:</em></p><p>MountainBike myBike = (MountainBike)obj;</p><p>This cast inserts a runtime check that obj is assigned a MountainBike so that the compiler can safely assume that obj is a MountainBike. If obj is not a MountainBike at runtime, an exception will be thrown.</p><p>Note:<strong> You can make a logical test as to the type of a particular object using the instanceof operator. This can save you from a runtime error owing to an improper cast. For example:</strong></p><ol><li><strong>if</strong> (obj <strong>instanceof</strong> MountainBike) {  </li><li>    MountainBike myBike = (MountainBike) obj;  </li><li>}  </li></ol><p><strong>Here the instanceof operator verifies that obj refers to a MountainBike so that we can make the cast with knowledge that there will be no runtime exception thrown.</strong></p><h2>5.8 Multiple Inheritance of State, Implementation, and Type</h2><p>One significant difference between classes and interfaces is that classes can have fields whereas interfaces cannot. In addition, you can instantiate a class to create an object, which you cannot do with interfaces. As explained in the section <a href="https://docs.oracle.com/javase/tutorial/java/concepts/object.html">What Is an Object?</a>, an object stores its state in fields, which are defined in classes. One reason why the Java programming language does not permit you to extend more than one class is to avoid the issues of <em>multiple inheritance of state</em>, which is the ability to inherit fields from multiple classes. For example, suppose that you are able to define a new class that extends multiple classes. When you create an object by instantiating that class, that object will inherit fields from all of the class&#x27;s super classes. What if methods or constructors from different super classes instantiate the same field? Which method or constructor will take precedence? Because interfaces do not contain fields, you do not have to worry about problems that result from multiple inheritance of state.</p><p><em>Multiple inheritance of implementation</em> is the ability to inherit method definitions from multiple classes. Problems arise with this type of multiple inheritance, such as name conflicts and ambiguity. When compilers of programming languages that support this type of multiple inheritance encounter super classes that contain methods with the same name, they sometimes cannot determine which member or method to access or invoke. In addition, a programmer can unwittingly introduce a name conflict by adding a new method to a superclass. <a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">Default methods</a> introduce one form of multiple inheritance of implementation. A class can implement more than one interface, which can contain default methods that have the same name. The Java compiler provides some rules to determine which default method a particular class uses.</p><p>The Java programming language supports <em>multiple inheritance of type</em>, which is the ability of a class to implement more than one interface. An object can have multiple types: the type of its own class and the types of all the interfaces that the class implements. This means that if a variable is declared to be the type of an interface, then its value can reference any object that is instantiated from any class that implements the interface. This is discussed in the section <a href="https://docs.oracle.com/javase/tutorial/java/IandI/interfaceAsType.html">Using an Interface as a Type</a>.</p><p>As with multiple inheritance of implementation, a class can inherit different implementations of a method defined (as default or static) in the interfaces that it extends. In this case, the compiler or the user must decide which one to use.</p><h2>5.9 Overriding and Hiding Methods</h2><h3>5.9.1 Instance Methods</h3><p><strong>An instance method in a subclass with the same signature (name, plus the number and the type of its parameters) and return type as an instance method in the superclass <em>overrides</em> the superclass&#x27;s method.</strong></p><p>The ability of a subclass to override a method allows a class to inherit from a superclass whose behavior is &quot;close enough&quot; and then to modify behavior as needed. The overriding method has the same name, number and type of parameters, and return type as the method that it overrides. An overriding method can also return a subtype of the type returned by the overridden method. This subtype is called <strong>a <em>covariant return type</em></strong>.</p><p>When overriding a method, you might want to use the \@Override annotation that instructs the compiler that you intend to override a method in the superclass. If, for some reason, the compiler detects that the method does not exist in one of the superclasses, then it will generate an error.</p><h3>5.9.2 Static Methods</h3><p>If a subclass defines a static method with the same signature as a static method in the superclass, then the method in the subclass <em>hides</em> the one in the superclass.</p><p>The distinction between hiding a static method and overriding an instance method has important implications:</p><p>The version of the overridden instance method that gets invoked is the one in the subclass.</p><p>The version of the hidden static method that gets invoked depends on whether it is invoked from the superclass or the subclass.</p><p>Consider an example that contains two classes. The first is Animal, which contains one instance method and one static method:</p><p><strong>public</strong> <strong>class</strong> Animal {  </p><p>    <strong>public</strong> <strong>static</strong> <strong>void</strong> testClassMethod() {  </p><p>        System.out.println(&quot;The static method in Animal&quot;);  </p><p>    }  </p><p>    <strong>public</strong> <strong>void</strong> testInstanceMethod() {  </p><p>        System.out.println(&quot;The instance method in Animal&quot;);  </p><p>    }  </p><p>}  </p><p>The second class, a subclass of Animal, is called Cat:</p><p><strong>public</strong> <strong>class</strong> Cat <strong>extends</strong> Animal {  </p><p>    <strong>public</strong> <strong>static</strong> <strong>void</strong> testClassMethod() {  </p><p>        System.out.println(&quot;The static method in Cat&quot;);  </p><p>    }  </p><p>    <strong>public</strong> <strong>void</strong> testInstanceMethod() {  </p><p>        System.out.println(&quot;The instance method in Cat&quot;);  </p><p>    }  </p><p>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </p><p>        Cat myCat = <strong>new</strong> Cat();  </p><p>        Animal myAnimal = myCat;  </p><p>        Animal.testClassMethod();  </p><p>        myAnimal.testInstanceMethod();  </p><p>    }  </p><p>}  </p><p>The Cat class overrides the instance method in Animal and hides the static method in Animal. The main method in this class creates an instance of Cat and invokes testClassMethod() on the class and testInstanceMethod() on the instance.</p><p>The output from this program is as follows:</p><p>The static method in Animal</p><p>The instance method in Cat</p><p>As promised, the version of the hidden static method that gets invoked is the one in the superclass, and the version of the overridden instance method that gets invoked is the one in the subclass.</p><h3>5.9.3 Interface Methods</h3><p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">Default methods</a> and <a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">abstract methods</a> in interfaces are inherited like instance methods. However, when the supertypes of a class or interface provide multiple default methods with the same signature, the Java compiler follows inheritance rules to resolve the name conflict. These rules are driven by the following two principles:</p><p>Instance methods are preferred over interface default methods.</p><p>Consider the following classes and interfaces:</p><p><strong>public</strong> <strong>class</strong> Horse {  </p><p>    <strong>public</strong> String identifyMyself() {  </p><p>        <strong>return</strong> &quot;I am a horse.&quot;;  </p><p>    }  </p><p>}  </p><p><strong>public</strong> <strong>interface</strong> Flyer {  </p><p>    <strong>default</strong> <strong>public</strong> String identifyMyself() {  </p><p>        <strong>return</strong> &quot;I am able to fly.&quot;;  </p><p>    }  </p><p>}  </p><p><strong>public</strong> <strong>interface</strong> Mythical {  </p><p>    <strong>default</strong> <strong>public</strong> String identifyMyself() {  </p><p>        <strong>return</strong> &quot;I am a mythical creature.&quot;;  </p><p>    }  </p><p>}  </p><p><strong>public</strong> <strong>class</strong> Pegasus <strong>extends</strong> Horse <strong>implements</strong> Flyer, Mythical {  </p><p>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String<!-- -->.<!-- -->..args) {  </p><p>        Pegasus myApp = <strong>new</strong> Pegasus();  </p><p>        System.out.println(myApp.identifyMyself());  </p><p>    }  </p><p>}  </p><p>The method Pegasus.identifyMyself returns the string I am a horse.</p><p>Methods that are already overridden by other candidates are ignored. This circumstance can arise when supertypes share a common ancestor.</p><p>Consider the following interfaces and classes:</p><p><strong>public</strong> <strong>interface</strong> Animal {  </p><p>    <strong>default</strong> <strong>public</strong> String identifyMyself() {  </p><p>        <strong>return</strong> &quot;I am an animal.&quot;;  </p><p>    }  </p><p>}  </p><p><strong>public</strong> <strong>interface</strong> EggLayer <strong>extends</strong> Animal {  </p><p>    <strong>default</strong> <strong>public</strong> String identifyMyself() {  </p><p>        <strong>return</strong> &quot;I am able to lay eggs.&quot;;  </p><p>    }  </p><p>}  </p><p><strong>public</strong> <strong>interface</strong> FireBreather <strong>extends</strong> Animal {}  </p><p><strong>public</strong> <strong>class</strong> Dragon <strong>implements</strong> EggLayer, FireBreather {  </p><p>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String<!-- -->.<!-- -->..args) {  </p><p>        Dragon myApp = <strong>new</strong> Dragon();  </p><p>        System.out.println(myApp.identifyMyself());  </p><p>    }  </p><p>}  </p><p>The method Dragon.identifyMyself returns the string I am able to lay eggs.</p><p>If two or more independently defined default methods conflict, or a default method conflicts with an abstract method, then the Java compiler produces a compiler error. You must explicitly override the supertype methods.</p><p>Consider the example about computer-controlled cars that can now fly. You have two interfaces (OperateCar and FlyCar) that provide default implementations for the same method, (startEngine):</p><p><strong>public</strong> <strong>interface</strong> OperateCar { // <!-- -->.<!-- -->..  </p><p>    <strong>default</strong> <strong>public</strong> <strong>int</strong> startEngine(EncryptedKey key) { // Implementation  </p><p>    }  </p><p>}  </p><p><strong>public</strong> <strong>interface</strong> FlyCar { // <!-- -->.<!-- -->..  </p><p>    <strong>default</strong> <strong>public</strong> <strong>int</strong> startEngine(EncryptedKey key) { // Implementation  </p><p>    }  </p><p>}  </p><p>A class that implements both OperateCar and FlyCar must override the method startEngine. You could invoke any of the of the default implementations with the super keyword.</p><p><strong>public</strong> <strong>class</strong> FlyingCar <strong>implements</strong> OperateCar, FlyCar { // <!-- -->.<!-- -->..  </p><p>    <strong>public</strong> <strong>int</strong> startEngine(EncryptedKey key) {  </p><p>        FlyCar.<strong>super</strong>.startEngine(key);  </p><p>        OperateCar.<strong>super</strong>.startEngine(key);  </p><p>    }  </p><p>}  </p><p>The name preceding super (in this example, FlyCar or OperateCar) must refer to a direct superinterface that defines or inherits a default for the invoked method. This form of method invocation is not restricted to differentiating between multiple implemented interfaces that contain default methods with the same signature. You can use the super keyword to invoke a default method in both classes and interfaces.</p><p>Inherited instance methods from classes can override abstract interface methods. Consider the following interfaces and classes:</p><p><strong>public</strong>  <strong>interface</strong>  Mammal  {        </p><p>    String  identifyMyself();    </p><p>}    </p><p><strong>public</strong>  <strong>class</strong>  Horse  {        </p><p>    <strong>public</strong>  String  identifyMyself()  {            </p><p>        <strong>return</strong>  &quot;I am a horse.&quot;;        </p><p>    }    </p><p>}    </p><p><strong>public</strong>  <strong>class</strong>  Mustang  <strong>extends</strong>  Horse  <strong>implements</strong>  Mammal  {        </p><p>    <strong>public</strong>  <strong>static</strong>  <strong>void</strong>  main(String<!-- -->.<!-- -->..args)  {            </p><p>        Mustang  myApp  =  <strong>new</strong>  Mustang();            </p><p>        System.out.println(myApp.identifyMyself());        </p><p>    }    </p><p>}    </p><p>The method Mustang.identifyMyself returns the string I am a horse. The class Mustang inherits the method identifyMyself from the class Horse, which overrides the abstract method of the same name in the interface Mammal.</p><p>Note: Static methods in interfaces are never inherited.</p><h3>5.9.4 Modifiers</h3><p>The access specifier for an overriding method can allow more, but not less, access than the overridden method. For example, a protected instance method in the superclass can be made public, but not private, in the subclass.</p><p>You will get a compile-time error if you attempt to change an instance method in the superclass to a static method in the subclass, and vice versa.</p><h3>5.9.5 Summary</h3><p>The following table summarizes what happens when you define a method with the same signature as a method in a superclass.</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Defining a Method with the Same Signature as a Superclass&#x27;s Method</td><td></td><td></td></tr><tr><td> </td><td><strong>Superclass Instance Method</strong></td><td><strong>Superclass Static Method</strong></td></tr><tr><td>Subclass Instance Method</td><td>Overrides</td><td>Generates a compile-time error</td></tr><tr><td>Subclass Static Method</td><td>Generates a compile-time error</td><td>Hides</td></tr></tbody></table><p><strong>Note:</strong> In a subclass, you can overload the methods inherited from the superclass. Such overloaded methods neither hide nor override the superclass instance methods---they are new methods, unique to the subclass.</p><h2>5.10 Polymorphism</h2><p>The dictionary definition of <em>polymorphism</em> refers to a principle in biology in which an organism or species can have many different forms or stages. This principle can also be applied to object-oriented programming and languages like the Java language. Subclasses of a class can define their own unique behaviors and yet share some of the same functionality of the parent class.</p><p>Polymorphism can be demonstrated with a minor modification to the Bicycle class. For example, a printDescription method could be added to the class that displays all the data currently stored in an instance.</p><p><strong>public</strong> <strong>void</strong> printDescription() {  </p><p>    System.out.println(&quot;<!-- -->\<!-- -->nBike is &quot; + &quot;in gear &quot; + <strong>this</strong>.gear + &quot; with a cadence of &quot; + <strong>this</strong>.cadence + &quot; and travelling at a speed of &quot; + <strong>this</strong>.speed + &quot;. &quot;);  </p><p>}  </p><p>To demonstrate polymorphic features in the Java language, extend the Bicycle class with a MountainBike and a RoadBike class. For MountainBike, add a field for suspension, which is a String value that indicates if the bike has a front shock absorber, Front. Or, the bike has a front and back shock absorber, Dual.</p><p>Here is the updated class:</p><p><strong>public</strong> <strong>class</strong> MountainBike <strong>extends</strong> Bicycle {  </p><p>    <strong>private</strong> String suspension;  </p><p>    <strong>public</strong> MountainBike(<strong>int</strong> startCadence, <strong>int</strong> startSpeed, <strong>int</strong> startGear, String suspensionType) {  </p><p>        <strong>super</strong>(startCadence, startSpeed, startGear);  </p><p>        <strong>this</strong>.setSuspension(suspensionType);  </p><p>    }  </p><p>    <strong>public</strong> String getSuspension() {  </p><p>        <strong>return</strong> <strong>this</strong>.suspension;  </p><p>    }  </p><p>    <strong>public</strong> <strong>void</strong> setSuspension(String suspensionType) {  </p><p>        <strong>this</strong>.suspension = suspensionType;  </p><p>    }  </p><p>    <strong>public</strong> <strong>void</strong> printDescription() {  </p><p>        <strong>super</strong>.printDescription();  </p><p>        System.out.println(&quot;The &quot; + &quot;MountainBike has a&quot; + getSuspension() + &quot; suspension.&quot;);  </p><p>    }  </p><p>}  </p><p>Note the overridden printDescription method. In addition to the information provided before, additional data about the suspension is included to the output.</p><p>Next, create the RoadBike class. Because road or racing bikes have skinny tires, add an attribute to track the tire width. Here is the RoadBike class:</p><ol><li><strong>public</strong> <strong>class</strong> RoadBike <strong>extends</strong> Bicycle { // In millimeters (mm)  </li><li>    <strong>private</strong> <strong>int</strong> tireWidth;  </li><li>    <strong>public</strong> RoadBike(<strong>int</strong> startCadence, <strong>int</strong> startSpeed, <strong>int</strong> startGear, <strong>int</strong> newTireWidth) {  </li><li>        <strong>super</strong>(startCadence, startSpeed, startGear);  </li><li>        <strong>this</strong>.setTireWidth(newTireWidth);  </li><li>    }  </li><li>    <strong>public</strong> <strong>int</strong> getTireWidth() {  </li><li>        <strong>return</strong> <strong>this</strong>.tireWidth;  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> setTireWidth(<strong>int</strong> newTireWidth) {  </li><li>        <strong>this</strong>.tireWidth = newTireWidth;  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> printDescription() {  </li><li>        <strong>super</strong>.printDescription();  </li><li>        System.out.println(&quot;The RoadBike&quot; + &quot; has &quot; + getTireWidth() + &quot; MM tires.&quot;);  </li><li>    }  </li><li>}  </li></ol><p>Note that once again, the printDescription method has been overridden. This time, information about the tire width is displayed.</p><p>To summarize, there are three classes: Bicycle, MountainBike, and RoadBike. The two subclasses override the printDescription method and print unique information.</p><p>Here is a test program that creates three Bicycle variables. Each variable is assigned to one of the three bicycle classes. Each variable is then printed.</p><ol><li><strong>public</strong>  <strong>class</strong>  TestBikes  {        </li><li>    <strong>public</strong>  <strong>static</strong>  <strong>void</strong>  main(String[]  args)  {            </li><li>        Bicycle  bike01,  bike02,  bike03;            </li><li>        bike01  =  <strong>new</strong>  Bicycle(20,  10,  1);            </li><li>        bike02  =  <strong>new</strong>  MountainBike(20,  10,  5,  &quot;Dual&quot;);            </li><li>        bike03  =  <strong>new</strong>  RoadBike(40,  20,  8,  23);            </li><li>        bike01.printDescription();            </li><li>        bike02.printDescription();            </li><li>        bike03.printDescription();        </li><li>    }    </li><li>}    </li><li>The following is the output from the test program: </li><li>Bike is <strong>in</strong> gear 1 <strong>with</strong> a cadence of 20 and travelling at a speed of 10. </li><li>Bike is <strong>in</strong> gear 5 <strong>with</strong> a cadence of 20 and travelling at a speed of 10. </li><li>The MountainBike has a Dual suspension.</li><li>Bike is <strong>in</strong> gear 8 <strong>with</strong> a cadence of 40 and travelling at a speed of 20. </li><li>The RoadBike has 23 MM tires.  </li></ol><p><strong>The Java virtual machine (JVM) calls the appropriate method for the object that is referred to in each variable. It does not call the method that is defined by the variable&#x27;s type. This behavior is referred to as <em>virtual method invocation</em> and demonstrates an aspect of the important polymorphism features in the Java language.</strong></p><h2>5.11 Hiding Fields</h2><p><strong>Within a class, a field that has the same name as a field in the superclass hides the superclass&#x27;s field, even if their types are different.</strong> Within the subclass, the field in the superclass cannot be referenced by its simple name. Instead, the field must be accessed through super, which is covered in the next section. Generally speaking, we don&#x27;t recommend hiding fields as it makes code difficult to read.</p><h2>5.12 Using the Keyword super</h2><h3>5.12.1 Accessing Superclass Members</h3><p>If your method overrides one of its superclass&#x27;s methods, you can invoke the overridden method through the use of the keyword super. You can also use super to refer to a hidden field (although hiding fields is discouraged). Consider this class, Superclass:</p><ol><li><strong>public</strong> <strong>class</strong> Superclass {  </li><li>    <strong>public</strong> <strong>void</strong> printMethod() {  </li><li>        System.out.println(&quot;Printed in Superclass.&quot;);  </li><li>    }  </li><li>}  </li></ol><p>Here is a subclass, called Subclass, that overrides printMethod():</p><ol><li><strong>public</strong> <strong>class</strong> Subclass <strong>extends</strong> Superclass { // overrides printMethod in Superclass  </li><li>    <strong>public</strong> <strong>void</strong> printMethod() {  </li><li>        <strong>super</strong>.printMethod();  </li><li>        System.out.println(&quot;Printed in Subclass&quot;);  </li><li>    }  </li><li>    <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {  </li><li>        Subclass s = <strong>new</strong> Subclass();  </li><li>        s.printMethod();  </li><li>    }  </li><li>}  </li></ol><p>Within Subclass, the simple name printMethod() refers to the one declared in Subclass, which overrides the one in Superclass. So, to refer to printMethod() inherited from Superclass, Subclass must use a qualified name, using super as shown. Compiling and executing Subclass prints the following:</p><ol><li>Printed <strong>in</strong> Superclass.Printed <strong>in</strong> Subclass  </li></ol><h3>5.12.2 Subclass Constructors</h3><p>The following example illustrates how to use the super keyword to invoke a superclass&#x27;s constructor. Recall from the <a href="https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html">Bicycle </a>example that MountainBike is a subclass of Bicycle. Here is the MountainBike (subclass) constructor that calls the superclass constructor and then adds initialization code of its own:</p><ol><li><strong>public</strong> MountainBike(<strong>int</strong> startHeight, <strong>int</strong> startCadence, <strong>int</strong> startSpeed, <strong>int</strong> startGear) {  </li><li>    <strong>super</strong>(startCadence, startSpeed, startGear);  </li><li>    seatHeight = startHeight;  </li><li>}  </li></ol><p>Invocation of a superclass constructor must be the first line in the subclass constructor.</p><p>The syntax for calling a superclass constructor is</p><ol><li><strong>super</strong>();  </li><li>or: <strong>super</strong>(parameter list);  </li></ol><p>With super(), the superclass no-argument constructor is called. With super(parameter list), the superclass constructor with a matching parameter list is called.</p><p><strong>Note:</strong> If a constructor does not explicitly invoke a superclass constructor, the Java compiler automatically inserts a call to the no-argument constructor of the superclass. If the super class does not have a no-argument constructor, you will get a compile-time error. Object <em>does</em> have such a constructor, so if Object is the only superclass, there is no problem.</p><p>If a subclass constructor invokes a constructor of its superclass, either explicitly or implicitly, you might think that there will be a whole chain of constructors called, all the way back to the constructor of Object. In fact, this is the case. It is called <em>constructor chaining</em>, and you need to be aware of it when there is a long line of class descent.</p><h2>5.13 Object as a Superclass</h2><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">Object</a> class, in the java.lang package, sits at the top of the class hierarchy tree. Every class is a descendant, direct or indirect, of the Object class. Every class you use or write inherits the instance methods of Object. You need not use any of these methods, but, if you choose to do so, you may need to override them with code that is specific to your class. The methods inherited from Object that are discussed in this section are:</p><ul><li>protected Object clone() throws CloneNotSupportedException
      Creates and returns a copy of this object.</li><li>public boolean equals(Object obj)
      Indicates whether some other object is &quot;equal to&quot; this one.</li><li>protected void finalize() throws Throwable
      Called by the garbage collector on an object when garbage
      collection determines that there are no more references to the object</li><li>public final Class getClass()
      Returns the runtime class of an object.</li><li>public int hashCode()
      Returns a hash code value for the object.</li><li>public String toString()
      Returns a string representation of the object.</li></ul><p>The notify, notifyAll, and wait methods of Object all play a part in synchronizing the activities of independently running threads in a program, There are five of these methods:</p><ul><li>public final void notify()</li><li>public final void notifyAll()</li><li>public final void wait()</li><li>public final void wait(long timeout)</li><li>public final void wait(long timeout, int nanos)</li></ul><p><strong>Note:</strong> There are some subtle aspects to a number of these methods, especially the clone method.</p><h3>5.13.1 The clone() Method</h3><p>If a class, or one of its superclasses, implements the Cloneable interface, you can use the clone() method to create a copy from an existing object. To create a clone, you write:</p><ol><li>aCloneableObject.clone();    </li></ol><p>Object&#x27;s implementation of this method checks to see whether the object on which clone() was invoked implements the Cloneable interface. If the object does not, the method throws a CloneNotSupportedException exception. Exception handling will be covered in a later lesson. For the moment, you need to know that clone() must be declared as</p><ol><li><strong>protected</strong>  Object  clone()  <strong>throws</strong>  CloneNotSupportedException  or:  <strong>public</strong>  Object  clone()  <strong>throws</strong>  CloneNotSupportedException    </li></ol><p>if you are going to write a clone() method to override the one in Object.</p><p>If the object on which clone() was invoked does implement the Cloneable interface, Object&#x27;s implementation of the clone() method creates an object of the same class as the original object and initializes the new object&#x27;s member variables to have the same values as the original object&#x27;s corresponding member variables.</p><p>The simplest way to make your class cloneable is to add implements Cloneable to your class&#x27;s declaration. then your objects can invoke the clone() method.</p><p>For some classes, the default behavior of Object&#x27;s clone() method works just fine. If, however, <strong>an object contains a reference to an external object, say ObjExternal, you may need to override clone() to get correct behavior. Otherwise, a change in ObjExternal made by one object will be visible in its clone also. This means that the original object and its clone are not independent---to decouple them, you must override clone()</strong> so that it clones the object <em>and</em> ObjExternal. Then the original object references ObjExternal and the clone references a clone of ObjExternal, so that the object and its clone are truly independent.</p><p><a href="https://stackoverflow.com/questions/2326758/how-to-properly-override-clone-method">https://stackoverflow.com/questions/2326758/how-to-properly-override-clone-method</a></p><h3>5.13.2 The equals() Method</h3><p>The equals() method compares two objects for equality and returns true if they are equal. The equals() method provided in the Object class uses the identity operator (==) to determine whether two objects are equal. For primitive data types, this gives the correct result. For objects, however, it does not. The equals() method provided by Object tests whether the object <em>references</em> are equal---that is, if the objects compared are the exact same object.</p><p>To test whether two objects are equal in the sense of <em>equivalency</em> (containing the same information), you must override the equals() method. Here is an example of a Book class that overrides equals():</p><ol><li><strong>public</strong> <strong>class</strong> Book {<!-- -->.<!-- -->..<strong>public</strong> <strong>boolean</strong> equals(Object obj) {  </li><li>        <strong>if</strong> (obj <strong>instanceof</strong> Book) <strong>return</strong> ISBN.equals((Book) obj.getISBN());  </li><li>        <strong>else</strong> <strong>return</strong> <strong>false</strong>;  </li><li>    }  </li><li>}  </li></ol><p>Consider this code that tests two instances of the Book class for equality:</p><ol><li>// Swing Tutorial, 2nd edition  </li><li>Book firstBook = <strong>new</strong> Book(&quot;0201914670&quot;);  </li><li>Book secondBook = <strong>new</strong> Book(&quot;0201914670&quot;);  </li><li><strong>if</strong> (firstBook.equals(secondBook)) {  </li><li>    System.out.println(&quot;objects are equal&quot;);  </li><li>} <strong>else</strong> {  </li><li>    System.out.println(&quot;objects are not equal&quot;);  </li><li>}  </li></ol><p>This program displays objects are equal even though firstBook and secondBook reference two distinct objects. They are considered equal because the objects compared contain the same ISBN number.</p><p>You should always override the equals() method if the identity operator is not appropriate for your class.</p><p><strong>Note:</strong> If you override equals(), you must override hashCode() as well.</p><p><a href="https://stackoverflow.com/questions/7520432/what-is-the-difference-between-vs-equals-in-java">https://stackoverflow.com/questions/7520432/what-is-the-difference-between-vs-equals-in-java</a></p><h3>5.13.3 The finalize() Method</h3><p>The Object class provides a callback method, finalize(), that <em>may be</em> invoked on an object when it becomes garbage. Object&#x27;s implementation of finalize() does nothing---you can override finalize() to do cleanup, such as freeing resources.</p><p>The finalize() method <em>may be</em> called automatically by the system, but when it is called, or even if it is called, is uncertain. Therefore, you should not rely on this method to do your cleanup for you. For example, if you don&#x27;t close file descriptors in your code after performing I/O and you expect finalize() to close them for you, you may run out of file descriptors.</p><p><a href="https://stackoverflow.com/questions/2506488/when-is-the-finalize-method-called-in-java">https://stackoverflow.com/questions/2506488/when-is-the-finalize-method-called-in-java</a></p><h3>5.13.4 The getClass() Method</h3><p>You cannot override getClass.The getClass() method returns a Class object, which has methods you can use to get information about the class, such as its name (getSimpleName()), its superclass (getSuperclass()), and the interfaces it implements (getInterfaces()). For example, the following method gets and displays the class name of an object:</p><ol><li><strong>void</strong>  printClassName(Object  obj)  {        </li><li>    System.out.println(&quot;The object&#x27;s&quot;  +  &quot; class is &quot;  +  obj.getClass().getSimpleName());    </li><li>}    </li></ol><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html">Class</a> class, in the java.lang package, has a large number of methods (more than 50). For example, you can test to see if the class is an annotation (isAnnotation()), an interface (isInterface()), or an enumeration (isEnum()). You can see what the object&#x27;s fields are (getFields()) or what its methods are (getMethods()), and so on.</p><h3>5.13.5 The hashCode() Method</h3><p>The value returned by hashCode() is the object&#x27;s hash code, which is the object&#x27;s memory address in hexadecimal.</p><p>By definition, if two objects are equal, their hash code <em>must also</em> be equal. If you override the equals() method, you change the way two objects are equated and Object&#x27;s implementation of hashCode() is no longer valid. Therefore, if you override the equals() method, you must also override the hashCode() method as well.</p><h3>5.13.6 The toString() Method</h3><p>The Object&#x27;s toString() method returns a String representation of the object, which is very useful for debugging. The String representation for an object depends entirely on the object, which is why you need to override toString() in your classes.You can use toString() along with System.out.println() to display a text representation of an object, such as an instance of Book:</p><ol><li>System.out.println(firstBook.toString());    </li></ol><p>which would, for a properly overridden toString() method, print something useful, like this:</p><h2>5.14 Writing Final Classes and Methods</h2><p>You can declare some or all of a class&#x27;s methods <em>final</em>. You use the final keyword in a method declaration to indicate that the method cannot be overridden by subclasses. The Object class does this---a number of its methods are final.</p><p>You might wish to make a method final if it has an implementation that should not be changed and it is critical to the consistent state of the object. For example, you might want to make the getFirstPlayer method in this ChessAlgorithm class final:</p><ol><li><strong>class</strong>  ChessAlgorithm  {        </li><li>    <strong>enum</strong>  ChessPlayer  {            </li><li>        WHITE,  BLACK        </li><li>    }<!-- -->.<!-- -->..<strong>final</strong>  ChessPlayer  getFirstPlayer()  {            </li><li>        <strong>return</strong>  ChessPlayer.WHITE;        </li><li>    }<!-- -->.<!-- -->..    </li><li>}    </li></ol><p>Methods called from constructors should generally be declared final. If a constructor calls a non-final method, a subclass may redefine that method with surprising or undesirable results.</p><p><strong>Note that you can also declare an entire class final. A class that is declared final cannot be subclassed. This is particularly useful, for example, when creating an immutable class like the String class.</strong></p><h2>5.15 Abstract Methods and Classes</h2><p>An <em>abstract class</em> is a class that is declared abstract---it may or may not include abstract methods. Abstract classes cannot be instantiated, but they can be subclassed.</p><p>An <em>abstract method</em> is a method that is declared without an implementation (without braces, and followed by a semicolon), like this:</p><ol><li><strong>abstract</strong> <strong>void</strong> moveTo(<strong>double</strong> deltaX, <strong>double</strong> deltaY);  </li></ol><p>If a class includes abstract methods, then the class itself <em>must</em> be declared abstract, as in:</p><ol><li><strong>public</strong> <strong>abstract</strong> <strong>class</strong> GraphicObject { // declare fields // declare nonabstract methods  </li><li>    <strong>abstract</strong> <strong>void</strong> draw();  </li><li>}  </li></ol><p>When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, then the subclass must also be declared abstract.</p><p><strong>Note:</strong> Methods in an <em>interface</em> (see the <a href="https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html">Interfaces</a> section) that are not declared as default or static are <em>implicitly</em> abstract, so the abstract modifier is not used with interface methods. (It can be used, but it is unnecessary.)</p><h3>5.15.1 Abstract Classes Compared to Interfaces</h3><p>Abstract classes are similar to interfaces. You cannot instantiate them, and they may contain a mix of methods declared with or without an implementation. However, with abstract classes, you can declare fields that are not static and final, and define public, protected, and private concrete methods. With interfaces, all fields are automatically public, static, and final, and all methods that you declare or define (as default methods) are public. In addition, you can extend only one class, whether or not it is abstract, whereas you can implement any number of interfaces.</p><p>Which should you use, abstract classes or interfaces?</p><ul><li>Consider using abstract classes if any of these statements apply to your situation:<ul><li>You want to share code among several closely related classes.</li><li>You expect that classes that extend your abstract class have many common methods or fields, or <strong>require access modifiers other than public</strong> (such as protected and private).</li><li>You want to declare non-static or non-final fields. This enables you to define methods that can access and modify the state of the object to which they belong.</li></ul></li><li>Consider using interfaces if any of these statements apply to your situation:<ul><li>You expect that unrelated classes would implement your interface. For example, the interfaces <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">Comparable</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html">Cloneable</a> are implemented by many unrelated classes.</li><li>You want to s<strong>pecify the behavior of a particular data type, but not concerned about who implements its behavior</strong>.</li><li>You want to <strong>take advantage of multiple inheritance of type.</strong></li></ul></li></ul><p>An example of an abstract class in the JDK is <a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractMap.html">AbstractMap</a>, which is part of the Collections Framework. Its subclasses (which include HashMap, TreeMap, and ConcurrentHashMap) share many methods (including get, put, isEmpty, containsKey, and containsValue) that AbstractMap defines.</p><p>An example of a class in the JDK that implements several interfaces is <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a>, which implements the interfaces Serializable, Cloneable, and Map&lt;K, V&gt;. By reading this list of interfaces, you can infer that an instance of HashMap (regardless of the developer or company who implemented the class) can be cloned, is serializable (which means that it can be converted into a byte stream; see the section <a href="https://docs.oracle.com/javase/tutorial/jndi/objects/serial.html">Serializable Objects</a>), and has the functionality of a map. In addition, the Map&lt;K, V&gt; interface has been enhanced with many default methods such as mergeand forEach that older classes that have implemented this interface do not have to define.</p><p>Note that many software libraries use both abstract classes and interfaces; the HashMap class implements several interfaces and also extends the abstract class AbstractMap.</p><h3>5.15.2 An Abstract Class Example</h3><p>In an object-oriented drawing application, you can draw circles, rectangles, lines, Bezier curves, and many other graphic objects. These objects all have certain states (for example: position, orientation, line color, fill color) and behaviors (for example: moveTo, rotate, resize, draw) in common. Some of these states and behaviors are the same for all graphic objects (for example: position, fill color, and moveTo). Others require different implementations (for example, resize or draw). All GraphicObjects must be able to draw or resize themselves; they just differ in how they do it. This is a perfect situation for an abstract superclass. You can take advantage of the similarities and declare all the graphic objects to inherit from the same abstract parent object (for example, GraphicObject) as shown in the following figure.</p><p>First, you declare an abstract class, GraphicObject, to provide member variables and methods that are wholly shared by all subclasses, such as the current position and the moveTo method. GraphicObject also declares abstract methods for methods, such as draw or resize, that need to be implemented by all subclasses but must be implemented in different ways. The GraphicObject class can look something like this:<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8PAwAI9gL7rVpmuwAAAABJRU5ErkJggg==" alt="Classes Rectangle, Line, Bezier, and Circle Inherit from GraphicObject "/></p><ol><li><strong>abstract</strong> <strong>class</strong> GraphicObject {  </li><li>    <strong>int</strong> x, y;<!-- -->.<!-- -->..<strong>void</strong> moveTo(<strong>int</strong> newX, <strong>int</strong> newY) {<!-- -->.<!-- -->..  </li><li>    }  </li><li>    <strong>abstract</strong> <strong>void</strong> draw();  </li><li>    <strong>abstract</strong> <strong>void</strong> resize();  </li><li>}  </li></ol><p>Each nonabstract subclass of GraphicObject, such as Circle and Rectangle, must provide implementations for the draw and resize methods:</p><ol><li><strong>class</strong> Circle <strong>extends</strong> GraphicObject {  </li><li>    <strong>void</strong> draw() {<!-- -->.<!-- -->..  </li><li>    }  </li><li>    <strong>void</strong> resize() {<!-- -->.<!-- -->..  </li><li>    }  </li><li>}  </li><li><strong>class</strong> Rectangle <strong>extends</strong> GraphicObject {  </li><li>    <strong>void</strong> draw() {<!-- -->.<!-- -->..  </li><li>    }  </li><li>    <strong>void</strong> resize() {<!-- -->.<!-- -->..  </li><li>    }  </li><li>}  </li></ol><h3>5.15.3 When an Abstract Class Implements an Interface</h3><p>In the section on <a href="https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html">Interfaces</a>, it was noted that a class that implements an interface must implement <em>all</em> of the interface&#x27;s methods. It is possible, however, to define a class that does not implement all of the interface&#x27;s methods, provided that the class is declared to be abstract. For example,</p><ol><li><strong>abstract</strong> <strong>class</strong> X <strong>implements</strong> Y { // implements all but one method of Y  </li><li>}  </li><li><strong>class</strong> XX <strong>extends</strong> X { // implements the remaining method in Y  </li><li>}  </li></ol><p>In this case, class X must be abstract because it does not fully implement Y, but class XX does, in fact, implement Y.</p><h3>5.15.4 Class Members</h3><p>An abstract class may have static fields and static methods. You can use these static members with a class reference (for example, AbstractClass.staticMethod()) as you would with any other class.</p><h2>5.16 Summary of Inheritance</h2><p>Except for the Object class, a class has exactly one direct superclass. A class inherits fields and methods from all its superclasses, whether direct or indirect. A subclass can override methods that it inherits, or it can hide fields or methods that it inherits. (Note that hiding fields is generally bad programming practice.)</p><p>The table in <a href="https://docs.oracle.com/javase/tutorial/java/IandI/override.html">Overriding and Hiding Methods</a> section shows the effect of declaring a method with the same signature as a method in the superclass.</p><p>The Object class is the top of the class hierarchy. All classes are descendants from this class and inherit methods from it. Useful methods inherited from Object include toString(), equals(), clone(), and getClass().</p><p>You can prevent a class from being subclassed by using the final keyword in the class&#x27;s declaration. Similarly, you can prevent a method from being overridden by subclasses by declaring it as a final method.</p><p>An abstract class can only be subclassed; it cannot be instantiated. An abstract class can contain abstract methods---methods that are declared but not implemented. Subclasses then provide the implementations for the abstract methods.</p><h1>6 Annotations</h1><p><em>Annotations</em>, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.</p><p>Annotations have a number of uses, among them:</p><ul><li><strong>Information for the compiler</strong> --- Annotations can be used by the compiler to detect errors or suppress warnings.</li><li><strong>Compile-time and deployment-time processing</strong> --- Software tools can process annotation information to generate code, XML files, and so forth.</li><li><strong>Runtime processing</strong> --- Some annotations are available to be examined at runtime.</li></ul><p>This lesson explains where annotations can be used, how to apply annotations, what predefined annotation types are available in the Java Platform, Standard Edition (Java SE API), how type annnotations can be used in conjunction with pluggable type systems to write code with stronger type checking, and how to implement repeating annotations.</p><h2>6.1 Annotations Basics</h2><h3>6.1.1 The Format of an Annotation</h3><p>In its simplest form, an annotation looks like the following:</p><p>\@Entity</p><p>The at sign character (@) indicates to the compiler that what follows is an annotation. In the following example, the annotation&#x27;s name is Override:</p><p>\@Override</p><p>void mySuperMethod() { <!-- -->.<!-- -->.. }</p><p>The annotation can include <em>elements</em>, which can be named or unnamed, and there are values for those elements:</p><p>\@Author(</p><p>name = &quot;Benjamin Franklin&quot;,</p><p>date = &quot;3/27/2003&quot;</p><p>)</p><p>class MyClass() { <!-- -->.<!-- -->.. }</p><p>or</p><p>\@SuppressWarnings(value = &quot;unchecked&quot;)</p><p>void myMethod() { <!-- -->.<!-- -->.. }</p><p>If there is just one element named value, then the name can be omitted, as in:</p><p>\@SuppressWarnings(&quot;unchecked&quot;)</p><p>void myMethod() { <!-- -->.<!-- -->.. }</p><p>If the annotation has no elements, then the parentheses can be omitted, as shown in the previous \@Override example.</p><p>It is also possible to use multiple annotations on the same declaration:</p><p>\@Author(name = &quot;Jane Doe&quot;)</p><p>\@EBook</p><p>class MyClass { <!-- -->.<!-- -->.. }</p><p>If the annotations have the same type, then this is called a repeating annotation:</p><p>\@Author(name = &quot;Jane Doe&quot;)</p><p>\@Author(name = &quot;John Smith&quot;)</p><p>class MyClass { <!-- -->.<!-- -->.. }</p><p>Repeating annotations are supported as of the Java SE 8 release. For more information, see <a href="https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html">Repeating Annotations</a>.</p><p>The annotation type can be one of the types that are defined in the java.lang or java.lang.annotation packages of the Java SE API. In the previous examples, Override and SuppressWarnings are <a href="https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html">predefined Java annotations</a>. It is also possible to define your own annotation type. The Author and Ebook annotations in the previous example are custom annotation types.</p><h3>6.1.2 Where Annotations Can Be Used</h3><p>Annotations can be applied to declarations: declarations of classes, fields, methods, and other program elements. When used on a declaration, each annotation often appears, by convention, on its own line.</p><p>As of the Java SE 8 release, annotations can also be applied to the <em>use</em> of types. Here are some examples:</p><pre><code class="language-java">-   Class instance creation expression:
-   new \@Interned MyObject();
-   Type cast:
-   myString = (\@NonNull String) str;
-   implements clause:
-   class UnmodifiableList&lt;T&gt; implements
-   \@Readonly List&lt;\@Readonly T&gt; { \... }
-   Thrown exception declaration:
-   void monitorTemperature() throws
-   \@Critical TemperatureException { \... }
</code></pre><p>This form of annotation is called a <em>type annotation</em>. For more information, see <a href="https://docs.oracle.com/javase/tutorial/java/annotations/type_annotations.html">Type Annotations and Pluggable Type Systems</a>.</p><h2>6.2 Declaring an Annotation Type</h2><p>Many annotations replace comments in code.</p><p>Suppose that a software group traditionally starts the body of every class with comments providing important information:</p><p>public class Generation3List extends Generation2List {</p><p>// Author: John Doe</p><p>// Date: 3/17/2002</p><p>// Current revision: 6</p><p>// Last modified: 4/12/2004</p><p>// By: Jane Doe</p><p>// Reviewers: Alice, Bill, Cindy</p><p>// class code goes here</p><p>}</p><p>To add this same metadata with an annotation, you must first define the <em>annotation type</em>. The syntax for doing this is:</p><p>\@interface ClassPreamble {</p><p>String author();</p><p>String date();</p><p>int currentRevision() default 1;</p><p>String lastModified() default &quot;N/A&quot;;</p><p>String lastModifiedBy() default &quot;N/A&quot;;</p><p>// Note use of array</p><p>String[] reviewers();</p><p>}</p><p>The annotation type definition looks similar to an interface definition where the keyword interface is preceded by the at sign (@) (@ = AT, as in annotation type). Annotation types are a form of <em>interface</em>, which will be covered in a later lesson. For the moment, you do not need to understand interfaces.</p><p>The body of the previous annotation definition contains <em>annotation type element</em> declarations, which look a lot like methods. Note that they can define optional default values.</p><p>After the annotation type is defined, you can use annotations of that type, with the values filled in, like this:</p><p>\@ClassPreamble (</p><p>author = &quot;John Doe&quot;,</p><p>date = &quot;3/17/2002&quot;,</p><p>currentRevision = 6,</p><p>lastModified = &quot;4/12/2004&quot;,</p><p>lastModifiedBy = &quot;Jane Doe&quot;,</p><p>// Note array notation</p><p>reviewers = {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Cindy&quot;}</p><p>)</p><p>public class Generation3List extends Generation2List {</p><p>// class code goes here</p><p>}</p><p><strong>Note:</strong> To make the information in \@ClassPreamble appear in Javadoc-generated documentation, you must annotate the \@ClassPreamble definition with the \@Documentedannotation:</p><pre><code class="language-java">// import this to use @Documented

import java.lang.annotation;

\@Documented

\@interface ClassPreamble {

// Annotation element definitions

}
</code></pre><h2>6.3 Predefined Annotation Types</h2><p>A set of annotation types are predefined in the Java SE API. Some annotation types are used by the Java compiler, and some apply to other annotations.</p><h3>6.3.1 Annotation Types Used by the Java Language</h3><p>The predefined annotation types defined in java.lang are \@Deprecated, \@Override, and \@SuppressWarnings.</p><p><strong>\@Deprecated</strong> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html">\@Deprecated</a> annotation indicates that the marked element is <em>deprecated</em> and should no longer be used. The compiler generates a warning whenever a program uses a method, class, or field with the \@Deprecated annotation. When an element is deprecated, it should also be documented using the Javadoc \@deprecated tag, as shown in the following example. The use of the at sign (@) in both Javadoc comments and in annotations is not coincidental: they are related conceptually. Also, note that the Javadoc tag starts with a lowercase <em>d</em> and the annotation starts with an uppercase <em>D</em>.</p><p>// Javadoc comment follows</p><p>/<!-- -->*<!-- -->*</p><p>*<!-- --> <em>\@deprecated</em></p><p>*<!-- --> <em>explanation of why it was deprecated</em></p><p>*<!-- -->/</p><p><strong>\@Deprecated</strong></p><p>static void deprecatedMethod() { }</p><p>}</p><p><strong>\@Override</strong> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html">\@Override</a> annotation informs the compiler that the element is meant to override an element declared in a superclass. Overriding methods will be discussed in <a href="https://docs.oracle.com/javase/tutorial/java/IandI/index.html">Interfaces and Inheritance</a>.</p><p>// <em>mark method as a superclass method</em></p><p>// <em>that has been overridden</em></p><p><strong>\@Override</strong></p><p>int overriddenMethod() { }</p><p>While it is not required to use this annotation when overriding a method, it helps to prevent errors. If a method marked with \@Override fails to correctly override a method in one of its superclasses, the compiler generates an error.</p><p><strong>\@SuppressWarnings</strong> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html">\@SuppressWarnings</a> annotation tells the compiler to suppress specific warnings that it would otherwise generate. In the following example, a deprecated method is used, and the compiler usually generates a warning. In this case, however, the annotation causes the warning to be suppressed.</p><p>// <em>use a deprecated method and tell</em></p><p>// <em>compiler not to generate a warning</em></p><p><strong>\@SuppressWarnings(&quot;deprecation&quot;)</strong></p><p>void useDeprecatedMethod() {</p><p>// deprecation warning</p><p>// - suppressed</p><p>objectOne.deprecatedMethod();</p><p>}</p><p>Every compiler warning belongs to a category. The Java Language Specification lists two categories: deprecation and unchecked. The unchecked warning can occur when interfacing with legacy code written before the advent of <a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">generics</a>. To suppress multiple categories of warnings, use the following syntax:</p><p>\@SuppressWarnings({&quot;unchecked&quot;, &quot;deprecation&quot;})</p><p><strong>\@SafeVarargs</strong> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SafeVarargs.html">\@SafeVarargs</a> annotation, when applied to a method or constructor, asserts that the code does not perform potentially unsafe operations on its varargs parameter. When this annotation type is used, unchecked warnings relating to varargs usage are suppressed.</p><p><strong>\@FunctionalInterface</strong> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html">\@FunctionalInterface</a> annotation, introduced in Java SE 8, indicates that the type declaration is intended to be a functional interface, as defined by the Java Language Specification.</p><h3>6.3.2 Annotations That Apply to Other Annotations</h3><p>Annotations that apply to other annotations are called <em>meta-annotations</em>. There are several meta-annotation types defined in java.lang.annotation.</p><p><strong>\@Retention</strong> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html">\@Retention</a> annotation specifies how the marked annotation is stored:</p><ul><li>RetentionPolicy.SOURCE -- The marked annotation is retained only in the source level and is ignored by the compiler.</li><li>RetentionPolicy.CLASS -- The marked annotation is retained by the compiler at compile time, but is ignored by the Java Virtual Machine (JVM).</li><li>RetentionPolicy.RUNTIME -- The marked annotation is retained by the JVM so it can be used by the runtime environment.</li></ul><p><strong>\@Documented</strong> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Documented.html">\@Documented</a> annotation indicates that whenever the specified annotation is used those elements should be documented using the Javadoc tool. (By default, annotations are not included in Javadoc.) For more information, see the <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/index.html">Javadoc tools page</a>.</p><p><strong>\@Target</strong> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html">\@Target</a> annotation marks another annotation to restrict what kind of Java elements the annotation can be applied to. A target annotation specifies one of the following element types as its value:</p><ul><li>ElementType.ANNOTATION_TYPE can be applied to an annotation type.</li><li>ElementType.CONSTRUCTOR can be applied to a constructor.</li><li>ElementType.FIELD can be applied to a field or property.</li><li>ElementType.LOCAL_VARIABLE can be applied to a local variable.</li><li>ElementType.METHOD can be applied to a method-level annotation.</li><li>ElementType.PACKAGE can be applied to a package declaration.</li><li>ElementType.PARAMETER can be applied to the parameters of a method.</li><li>ElementType.TYPE can be applied to any element of a class.</li></ul><p><strong>\@Inherited</strong> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html">\@Inherited</a> annotation indicates that the annotation type can be inherited from the super class. (This is not true by default.) When the user queries the annotation type and the class has no annotation for this type, the class&#x27; superclass is queried for the annotation type. This annotation applies only to class declarations.</p><p><strong>\@Repeatable</strong> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Repeatable.html">\@Repeatable</a> annotation, introduced in Java SE 8, indicates that the marked annotation can be applied more than once to the same declaration or type use. For more information, see <a href="https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html">Repeating Annotations</a>.</p><h2>6.4 Type Annotations and Pluggable Type Systems</h2><p>Before the Java SE 8 release, annotations could only be applied to declarations. As of the Java SE 8 release, annotations can also be applied to any <em>type use</em>. This means that annotations can be used anywhere you use a type. A few examples of where types are used are class instance creation expressions (new), casts, implements clauses, and throws clauses. This form of annotation is called a <em>type annotation</em> and several examples are provided in <a href="https://docs.oracle.com/javase/tutorial/java/annotations/basics.html">Annotations Basics</a>.</p><p>Type annotations were created to support improved analysis of Java programs way of ensuring stronger type checking. The Java SE 8 release does not provide a type checking framework, but it allows you to write (or download) a type checking framework that is implemented as one or more pluggable modules that are used in conjunction with the Java compiler.</p><p>For example, you want to ensure that a particular variable in your program is never assigned to null; you want to avoid triggering a NullPointerException. You can write a custom plug-in to check for this. You would then modify your code to annotate that particular variable, indicating that it is never assigned to null. The variable declaration might look like this:</p><p><strong>\@NonNull</strong> String str;</p><p>When you compile the code, including the NonNull module at the command line, the compiler prints a warning if it detects a potential problem, allowing you to modify the code to avoid the error. After you correct the code to remove all warnings, this particular error will not occur when the program runs.</p><p>You can use multiple type-checking modules where each module checks for a different kind of error. In this way, you can build on top of the Java type system, adding specific checks when and where you want them.</p><p>With the judicious use of type annotations and the presence of pluggable type checkers, you can write code that is stronger and less prone to error.</p><p>In many cases, you do not have to write your own type checking modules. There are third parties who have done the work for you. For example, you might want to take advantage of the Checker Framework created by the University of Washington. This framework includes a NonNull module, as well as a regular expression module, and a mutex lock module. For more information, see the <a href="http://types.cs.washington.edu/checker-framework/">Checker Framework</a>.</p><h2>6.5 Repeating Annotations</h2><p>There are some situations where you want to apply the same annotation to a declaration or type use. As of the Java SE 8 release, <em>repeating annotations</em> enable you to do this.</p><p>For example, you are writing code to use a timer service that enables you to run a method at a given time or on a certain schedule, similar to the UNIX cron service. Now you want to set a timer to run a method, doPeriodicCleanup, on the last day of the month and on every Friday at 11:00 p.m. To set the timer to run, create an \@Schedule annotation and apply it twice to the doPeriodicCleanupmethod. The first use specifies the last day of the month and the second specifies Friday at 11p.m., as shown in the following code example:</p><p>\@Schedule(dayOfMonth=&quot;last&quot;)</p><p>\@Schedule(dayOfWeek=&quot;Fri&quot;, hour=&quot;23&quot;)</p><p>public void doPeriodicCleanup() { <!-- -->.<!-- -->.. }</p><p>The previous example applies an annotation to a method. You can repeat an annotation anywhere that you would use a standard annotation. For example, you have a class for handling unauthorized access exceptions. You annotate the class with one \@Alert annotation for managers and another for admins:</p><p>\@Alert(role=&quot;Manager&quot;)</p><p>\@Alert(role=&quot;Administrator&quot;)</p><p>public class UnauthorizedAccessException extends SecurityException { <!-- -->.<!-- -->.. }</p><p>For compatibility reasons, repeating annotations are stored in a <em>container annotation</em> that is automatically generated by the Java compiler. In order for the compiler to do this, two declarations are required in your code.</p><h3>6.5.1 Step 1: Declare a Repeatable Annotation Type</h3><p>The annotation type must be marked with the \@Repeatable meta-annotation. The following example defines a custom \@Schedule repeatable annotation type:</p><pre><code class="language-java">import java.lang.annotation.Repeatable;

**\@Repeatable(Schedules.class)**

public \@interface Schedule {

String dayOfMonth() default &quot;first&quot;;

String dayOfWeek() default &quot;Mon&quot;;

int hour() default 12;

}
</code></pre><p>The value of the \@Repeatable meta-annotation, in parentheses, is the type of the container annotation that the Java compiler generates to store repeating annotations. In this example, the containing annotation type is Schedules, so repeating \@Schedule annotations is stored in an \@Schedules annotation.</p><p>Applying the same annotation to a declaration without first declaring it to be repeatable results in a compile-time error.</p><h3>6.5.2 Step 2: Declare the Containing Annotation Type</h3><p>The containing annotation type must have a value element with an array type. The component type of the array type must be the repeatable annotation type. The declaration for the Schedulescontaining annotation type is the following:</p><p>public \@interface Schedules {</p><p>Schedule[] value();</p><p>}</p><h3>6.5.3 Retrieving Annotations</h3><p>There are several methods available in the Reflection API that can be used to retrieve annotations. The behavior of the methods that return a single annotation, such as<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html#getAnnotation-java.lang.Class-"><code>AnnotatedElement.getAnnotation(Class&lt;T&gt;)</code></a>, are unchanged in that they only return a single annotation if <em>one</em> annotation of the requested type is present. If more than one annotation of the requested type is present, you can obtain them by first getting their container annotation. In this way, legacy code continues to work. Other methods were introduced in Java SE 8 that scan through the container annotation to return multiple annotations at once, such as <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html#getAnnotationsByType-java.lang.Class-"><code>AnnotatedElement.getAnnotationsByType(Class&lt;T&gt;)</code></a>. See the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html">AnnotatedElement</a> class specification for information on all of the available methods.</p><h3>6.5.4 Design Considerations</h3><p>When designing an annotation type, you must consider the <em>cardinality</em> of annotations of that type. It is now possible to use an annotation zero times, once, or, if the annotation&#x27;s type is marked as \@Repeatable, more than once. It is also possible to restrict where an annotation type can be used by using the \@Target meta-annotation. For example, you can create a repeatable annotation type that can only be used on methods and fields. It is important to design your annotation type carefully to ensure that the programmer <em>using</em> the annotation finds it to be as flexible and powerful as possible.</p><h1>7 Numbers and Strings</h1><h2><a href="https://docs.oracle.com/javase/tutorial/java/data/numbers.html">7.1 Numbers</a></h2><p>This section begins with a discussion of the Number class (in the java.lang package) and its subclasses. In particular, this section talks about the situations where you would use instantiations of these classes rather than the primitive data types. Additionally, this section talks about other classes you might need to work with numbers, such as formatting or using mathematical functions to complement the operators built into the language. Finally, there is a discussion on autoboxing and unboxing, a compiler feature that simplifies your code.</p><h2><a href="https://docs.oracle.com/javase/tutorial/java/data/strings.html">7.2 Strings</a></h2><p>Strings, which are widely used in Java programming, are a sequence of characters. In the Java programming language, strings are objects. This section describes using the String class to create and manipulate strings. It also compares the String and StringBuilder classes.</p><h2>7.3 Numbers</h2><p>This section begins with a discussion of the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html">Number</a> class in the java.lang package, its subclasses, and the situations where you would use instantiations of these classes rather than the primitive number types.</p><p>This section also presents the <a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html">PrintStream</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html">DecimalFormat</a> classes, which provide methods for writing formatted numerical output.</p><p>Finally, the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html">Math</a> class in java.lang is discussed. It contains mathematical functions to complement the operators built into the language. This class has methods for the trigonometric functions, exponential functions, and so forth.</p><h2>7.4 The Numbers Classes</h2><p>When working with numbers, most of the time you use the primitive types in your code. For example:</p><p>int i = 500;</p><p>float gpa = 3.65f;</p><p>byte mask = 0xff;</p><p>There are, however, reasons to use objects in place of primitives, and the Java platform provides <em>wrapper</em> classes for each of the primitive data types. These classes &quot;wrap&quot; the primitive in an object. Often, the wrapping is done by the compiler---if you use a primitive where an object is expected, the compiler <em>boxes</em> the primitive in its wrapper class for you. Similarly, if you use a number object when a primitive is expected, the compiler <em>unboxes</em> the object for you. For more information, see <a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">Autoboxing and Unboxing</a></p><p>All of the numeric wrapper classes are subclasses of the abstract class Number:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8pAwAIyALkosqvcgAAAABJRU5ErkJggg==" alt="The class hierarchy of Number."/></p><p><strong>Note:</strong> There are four other subclasses of Number that are not discussed here. BigDecimal and BigInteger are used for high-precision calculations. AtomicInteger and AtomicLong are used for multi-threaded applications.</p><p>There are three reasons that you might use a Number object rather than a primitive:</p><ol><li>As an argument of a method that expects an object (often used when manipulating collections of numbers).</li><li>To use constants defined by the class, such as MIN_VALUE and MAX_VALUE, that provide the upper and lower bounds of the data type.</li><li>To use class methods for converting values to and from other primitive types, for converting to and from strings, and for converting between number systems (decimal, octal, hexadecimal, binary).</li></ol><p>The following table lists the instance methods that all the subclasses of the Number class implement.</p><p>+-----------------------------------+-----------------------------------+
| <strong>Methods Implemented by all      |                                   |
| Subclasses of Number</strong>            |                                   |
+-----------------------------------+-----------------------------------+
| <strong>Method</strong>                        | <strong>Description</strong>                   |
+-----------------------------------+-----------------------------------+
| byte byteValue()\                 | Converts the value of             |
| short shortValue()\               | this Number object to the         |
| int intValue()\                   | primitive data type returned.     |
| long longValue()\                 |                                   |
| float floatValue()\               |                                   |
| double doubleValue()              |                                   |
+-----------------------------------+-----------------------------------+
| int compareTo(Byte anotherByte)\  | Compares this Number object to    |
| int compareTo(Double              | the argument.                     |
| anotherDouble)\                   |                                   |
| int compareTo(Float               |                                   |
| anotherFloat)\                    |                                   |
| int compareTo(Integer             |                                   |
| anotherInteger)\                  |                                   |
| int compareTo(Long anotherLong)\  |                                   |
| int compareTo(Short anotherShort) |                                   |
+-----------------------------------+-----------------------------------+
| boolean equals(Object obj)        | Determines whether this number    |
|                                   | object is equal to the argument.\ |
|                                   | The methods return true if the    |
|                                   | argument is not null and is an    |
|                                   | object of the same type and with  |
|                                   | the same numeric value.\          |
|                                   | There are some extra requirements |
|                                   | for Double and Float objects that |
|                                   | are described in the Java API     |
|                                   | documentation.                    |
+-----------------------------------+-----------------------------------+</p><p>Each Number class contains other methods that are useful for converting numbers to and from strings and for converting between number systems. The following table lists these methods in the Integer class. Methods for the other Number subclasses are similar:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Conversion Methods, Integer Class</strong></td><td></td></tr><tr><td><strong>Method</strong></td><td><strong>Description</strong></td></tr><tr><td>static Integer decode(String s)</td><td>Decodes a string into an integer. Can accept string representations of decimal, octal, or hexadecimal numbers as input.</td></tr><tr><td>static int parseInt(String s)</td><td>Returns an integer (decimal only).</td></tr><tr><td>static int parseInt(String s, int radix)</td><td>Returns an integer, given a string representation of decimal, binary, octal, or hexadecimal (radix equals 10, 2, 8, or 16 respectively) numbers as input.</td></tr><tr><td>String toString()</td><td>Returns a String object representing the value of this Integer.</td></tr><tr><td>static String toString(int i)</td><td>Returns a String object representing the specified integer.</td></tr><tr><td>static Integer valueOf(int i)</td><td>Returns an Integer object holding the value of the specified primitive.</td></tr><tr><td>static Integer valueOf(String s)</td><td>Returns an Integer object holding the value of the specified string representation.</td></tr><tr><td>static Integer valueOf(String s, int radix)</td><td>Returns an Integer object holding the integer value of the specified string representation, parsed with the value of radix. For example, if s = &quot;333&quot; and radix = 8, the method returns the base-ten integer equivalent of the octal number 333.</td></tr></tbody></table><h2>7.5 Formatting Numeric Print Output</h2><p>Earlier you saw the use of the print and println methods for printing strings to standard output (System.out). Since all numbers can be converted to strings (as you will see later in this lesson), you can use these methods to print out an arbitrary mixture of strings and numbers. The Java programming language has other methods, however, that allow you to exercise much more control over your print output when numbers are included.</p><h3>7.5.1 The printf and format Methods</h3><p>The java.io package includes a PrintStream class that has two formatting methods that you can use to replace print and println. These methods, format and printf, are equivalent to one another. The familiar System.out that you have been using happens to be a PrintStream object, so you can invoke PrintStream methods on System.out. Thus, you can use format or printf anywhere in your code where you have previously been using print or println. For example,</p><p>System.out.format(<!-- -->.<!-- -->....);</p><p>The syntax for these two <a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html">java.io.PrintStream </a>methods is the same:</p><p>public PrintStream format(String format, Object<!-- -->.<!-- -->.. args)</p><p>where format is a string that specifies the formatting to be used and args is a list of the variables to be printed using that formatting. A simple example would be</p><p>System.out.format(&quot;The value of &quot; + &quot;the float variable is &quot; +</p><p>&quot;%f, while the value of the &quot; + &quot;integer variable is %d, &quot; +</p><p>&quot;and the string is %s&quot;, floatVar, intVar, stringVar);</p><p>The first parameter, format, is a format string specifying how the objects in the second parameter, args, are to be formatted. The format string contains plain text as well as <em>format specifiers</em>, which are special characters that format the arguments of Object<!-- -->.<!-- -->.. args. (The notation Object<!-- -->.<!-- -->.. args is called <em>varargs</em>, which means that the number of arguments may vary.)</p><p>Format specifiers begin with a percent sign (%) and end with a <em>converter</em>. The converter is a character indicating the type of argument to be formatted. In between the percent sign (%) and the converter you can have optional flags and specifiers. There are many converters, flags, and specifiers, which are documented in <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html">java.util.Formatter</a></p><p>Here is a basic example:</p><p>int i = 461012;</p><p>System.out.format(&quot;The value of i is: %d%n&quot;, i);</p><p>The %d specifies that the single variable is a decimal integer. The %n is a platform-independent newline character. The output is:</p><p>The value of i is: 461012</p><p>The printf and format methods are overloaded. Each has a version with the following syntax:</p><p>public PrintStream format(Locale l, String format, Object<!-- -->.<!-- -->.. args)</p><p>To print numbers in the French system (where a comma is used in place of the decimal place in the English representation of floating point numbers), for example, you would use:</p><p>System.out.format(Locale.FRANCE,</p><p>&quot;The value of the float &quot; + &quot;variable is %f, while the &quot; +</p><p>&quot;value of the integer variable &quot; + &quot;is %d, and the string is %s%n&quot;,</p><p>floatVar, intVar, stringVar);</p><h3>7.5.2 An Example</h3><p>The following table lists some of the converters and flags that are used in the sample program, TestFormat.java, that follows the table.</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>Converters and Flags Used in TestFormat.java</strong></td><td></td><td></td></tr><tr><td><strong>Converter</strong></td><td><strong>Flag</strong></td><td><strong>Explanation</strong></td></tr><tr><td>d</td><td> </td><td>A decimal integer.</td></tr><tr><td>f</td><td> </td><td>A float.</td></tr><tr><td>n</td><td> </td><td>A new line character appropriate to the platform running the application. You should always use %n, rather than <!-- -->\<!-- -->n.</td></tr><tr><td>tB</td><td> </td><td>A date &amp; time conversion---locale-specific full name of month.</td></tr><tr><td>td, te</td><td> </td><td>A date &amp; time conversion---2-digit day of month. td has leading zeroes as needed, te does not.</td></tr><tr><td>ty, tY</td><td> </td><td>A date &amp; time conversion---ty = 2-digit year, tY = 4-digit year.</td></tr><tr><td>tl</td><td> </td><td>A date &amp; time conversion---hour in 12-hour clock.</td></tr><tr><td>tM</td><td> </td><td>A date &amp; time conversion---minutes in 2 digits, with leading zeroes as necessary.</td></tr><tr><td>tp</td><td> </td><td>A date &amp; time conversion---locale-specific am/pm (lower case).</td></tr><tr><td>tm</td><td> </td><td>A date &amp; time conversion---months in 2 digits, with leading zeroes as necessary.</td></tr><tr><td>tD</td><td> </td><td>A date &amp; time conversion---date as %tm%td%ty</td></tr><tr><td> </td><td>08</td><td>Eight characters in width, with leading zeroes as necessary.</td></tr><tr><td> </td><td>+</td><td>Includes sign, whether positive or negative.</td></tr><tr><td> </td><td>,</td><td>Includes locale-specific grouping characters.</td></tr><tr><td> </td><td>-</td><td>Left-justified..</td></tr><tr><td> </td><td>.3</td><td>Three places after decimal point.</td></tr><tr><td> </td><td>10.3</td><td>Ten characters in width, right justified, with three places after decimal point.</td></tr></tbody></table><p>The following program shows some of the formatting that you can do with format. The output is shown within double quotes in the embedded comment:</p><pre><code class="language-java">import java.util.Calendar;

import java.util.Locale;

public class TestFormat {

public static void main(String[] args) {

long n = 461012;

System.out.format(&quot;%d%n&quot;, n); // --&gt; &quot;461012&quot;

System.out.format(&quot;%08d%n&quot;, n); // --&gt; &quot;00461012&quot;

System.out.format(&quot;%+8d%n&quot;, n); // --&gt; &quot; +461012&quot;

System.out.format(&quot;%,8d%n&quot;, n); // --&gt; &quot; 461,012&quot;

System.out.format(&quot;%+,8d%n%n&quot;, n); // --&gt; &quot;+461,012&quot;

double pi = Math.PI;

System.out.format(&quot;%f%n&quot;, pi); // --&gt; &quot;3.141593&quot;

System.out.format(&quot;%.3f%n&quot;, pi); // --&gt; &quot;3.142&quot;

System.out.format(&quot;%10.3f%n&quot;, pi); // --&gt; &quot; 3.142&quot;

System.out.format(&quot;%-10.3f%n&quot;, pi); // --&gt; &quot;3.142&quot;

System.out.format(Locale.FRANCE,

&quot;%-10.4f%n%n&quot;, pi); // --&gt; &quot;3,1416&quot;

Calendar c = Calendar.getInstance();

System.out.format(&quot;%tB %te, %tY%n&quot;, c, c, c); // --&gt; &quot;May 29, 2006&quot;

System.out.format(&quot;%tl:%tM %tp%n&quot;, c, c, c); // --&gt; &quot;2:34 am&quot;

System.out.format(&quot;%tD%n&quot;, c); // --&gt; &quot;05/29/06&quot;

}

}
</code></pre><p><strong>Note:</strong>  The discussion in this section covers just the basics of the format and printf methods. Further detail can be found in the <a href="https://docs.oracle.com/javase/tutorial/essential/io/formatting.html">Basic I/O </a>section of the Essential trail, in the &quot;Formatting&quot; page.
Using String.format to create strings is covered in <a href="https://docs.oracle.com/javase/tutorial/java/data/strings.html">Strings</a>.</p><h3>7.5.3 The DecimalFormat Class</h3><p>You can use the <a href="https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html">java.text.DecimalFormat </a>class to control the display of leading and trailing zeros, prefixes and suffixes, grouping (thousands) separators, and the decimal separator. DecimalFormat offers a great deal of flexibility in the formatting of numbers, but it can make your code more complex.</p><p>The example that follows creates a DecimalFormat object, myFormatter, by passing a pattern string to the DecimalFormat constructor. The format() method, which DecimalFormatinherits from NumberFormat, is then invoked by myFormatter---it accepts a double value as an argument and returns the formatted number in a string:</p><p>Here is a sample program that illustrates the use of DecimalFormat:</p><pre><code class="language-Java">import java.text.*;

public class DecimalFormatDemo {

static public void customFormat(String pattern, double value ) {

DecimalFormat myFormatter = new DecimalFormat(pattern);

String output = myFormatter.format(value);

System.out.println(value + &quot; &quot; + pattern + &quot; &quot; + output);

}

static public void main(String[] args) {

customFormat(&quot;\#\#\#,\#\#\#.\#\#\#&quot;, 123456.789);

customFormat(&quot;\#\#\#.\#\#&quot;, 123456.789);

customFormat(&quot;000000.000&quot;, 123.78);

customFormat(&quot;\$\#\#\#,\#\#\#.\#\#\#&quot;, 12345.67);

}

}

The output is:

123456.789 \#\#\#,\#\#\#.\#\#\# 123,456.789

123456.789 \#\#\#.\#\# 123456.79

123.78 000000.000 000123.780

12345.67 \$\#\#\#,\#\#\#.\#\#\# \$12,345.67
</code></pre><p>The following table explains each line of output.</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>DecimalFormat.java Output</strong></td><td></td><td></td><td></td></tr><tr><td><strong>Value</strong></td><td><strong>Pattern</strong></td><td><strong>Output</strong></td><td><strong>Explanation</strong></td></tr><tr><td>123456.789</td><td>#<!-- -->#<!-- -->#<!-- -->,<!-- -->#<!-- -->#<!-- -->#<!-- -->.<!-- -->#<!-- -->#<!-- -->#</td><td>123,456.789</td><td>The pound sign (<!-- -->#<!-- -->) denotes a digit, the comma is a placeholder for the grouping separator, and the period is a placeholder for the decimal separator.</td></tr><tr><td>123456.789</td><td>#<!-- -->#<!-- -->#<!-- -->.<!-- -->#<!-- -->#</td><td>123456.79</td><td>The value has three digits to the right of the decimal point, but the pattern has only two. The format method handles this by rounding up.</td></tr><tr><td>123.78</td><td>000000.000</td><td>000123.780</td><td>The pattern specifies leading and trailing zeros, because the 0 character is used instead of the pound sign (<!-- -->#<!-- -->).</td></tr><tr><td>12345.67</td><td>\$<!-- -->#<!-- -->#<!-- -->#<!-- -->,<!-- -->#<!-- -->#<!-- -->#<!-- -->.<!-- -->#<!-- -->#<!-- -->#</td><td>\$12,345.67</td><td>The first character in the pattern is the dollar sign (\$). Note that it immediately precedes the leftmost digit in the formatted output.</td></tr></tbody></table><h2>7.6 Beyond Basic Arithmetic</h2><p>The Java programming language supports basic arithmetic with its arithmetic operators: +, -, <!-- -->*<!-- -->, /, and %. The <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html">Math </a>class in the java.lang package provides methods and constants for doing more advanced mathematical computation.</p><p>The methods in the Math class are all static, so you call them directly from the class, like this:</p><p>Math.cos(angle);</p><p><strong>Note:</strong> Using the <a href="https://docs.oracle.com/javase/tutorial/java/package/usepkgs.html#staticimport">static import </a>language feature, you don&#x27;t have to write Math in front of every math function:</p><pre><code class="language-java">import static java.lang.Math.*;
</code></pre><p>This allows you to invoke the Math class methods by their simple names. For example:</p><p>cos(angle);</p><h3>7.6.1 Constants and Basic Methods</h3><p>The Math class includes two constants:</p><ul><li>Math.E, which is the base of natural logarithms, and</li><li>Math.PI, which is the ratio of the circumference of a circle to its diameter.</li></ul><p>The Math class also includes more than 40 static methods. The following table lists a number of the basic methods.</p><p>+-----------------------------------+-----------------------------------+
| <strong>Basic Math Methods</strong>            |                                   |
+-----------------------------------+-----------------------------------+
| <strong>Method</strong>                        | <strong>Description</strong>                   |
+-----------------------------------+-----------------------------------+
| double abs(double d)\             | Returns the absolute value of the |
| float abs(float f)\               | argument.                         |
| int abs(int i)\                   |                                   |
| long abs(long lng)                |                                   |
+-----------------------------------+-----------------------------------+
| double ceil(double d)             | Returns the smallest integer that |
|                                   | is greater than or equal to the   |
|                                   | argument. Returned as a double.   |
+-----------------------------------+-----------------------------------+
| double floor(double d)            | Returns the largest integer that  |
|                                   | is less than or equal to the      |
|                                   | argument. Returned as a double.   |
+-----------------------------------+-----------------------------------+
| double rint(double d)             | Returns the integer that is       |
|                                   | closest in value to the argument. |
|                                   | Returned as a double.             |
+-----------------------------------+-----------------------------------+
| long round(double d)\             | Returns the closest long or int,  |
| int round(float f)                | as indicated by the method&#x27;s     |
|                                   | return type, to the argument.     |
+-----------------------------------+-----------------------------------+
| double min(double arg1, double    | Returns the smaller of the two    |
| arg2)\                            | arguments.                        |
| float min(float arg1, float       |                                   |
| arg2)\                            |                                   |
| int min(int arg1, int arg2)\      |                                   |
| long min(long arg1, long arg2)    |                                   |
+-----------------------------------+-----------------------------------+
| double max(double arg1, double    | Returns the larger of the two     |
| arg2)\                            | arguments.                        |
| float max(float arg1, float       |                                   |
| arg2)\                            |                                   |
| int max(int arg1, int arg2)\      |                                   |
| long max(long arg1, long arg2)    |                                   |
+-----------------------------------+-----------------------------------+</p><p>The following program, <a href="https://docs.oracle.com/javase/tutorial/java/data/examples/BasicMathDemo.java">BasicMathDemo</a> , illustrates how to use some of these methods:</p><p>public class BasicMathDemo {</p><p>public static void main(String[] args) {</p><p>double a = -191.635;</p><p>double b = 43.74;</p><p>int c = 16, d = 45;</p><p>System.out.printf(&quot;The absolute value &quot; + &quot;of %.3f is %.3f%n&quot;,</p><p>a, Math.abs(a));</p><p>System.out.printf(&quot;The ceiling of &quot; + &quot;%.2f is %.0f%n&quot;,</p><p>b, Math.ceil(b));</p><p>System.out.printf(&quot;The floor of &quot; + &quot;%.2f is %.0f%n&quot;,</p><p>b, Math.floor(b));</p><p>System.out.printf(&quot;The rint of %.2f &quot; + &quot;is %.0f%n&quot;,</p><p>b, Math.rint(b));</p><p>System.out.printf(&quot;The max of %d and &quot; + &quot;%d is %d%n&quot;,</p><p>c, d, Math.max(c, d));</p><p>System.out.printf(&quot;The min of of %d &quot; + &quot;and %d is %d%n&quot;,</p><p>c, d, Math.min(c, d));</p><p>}</p><p>}</p><p>Here&#x27;s the output from this program:</p><p>The absolute value of -191.635 is 191.635</p><p>The ceiling of 43.74 is 44</p><p>The floor of 43.74 is 43</p><p>The rint of 43.74 is 44</p><p>The max of 16 and 45 is 45</p><p>The min of 16 and 45 is 16</p><h3>7.6.2 Exponential and Logarithmic Methods</h3><p>The next table lists exponential and logarithmic methods of the Math class.</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Exponential and Logarithmic Methods</strong></td><td></td></tr><tr><td><strong>Method</strong></td><td><strong>Description</strong></td></tr><tr><td>double exp(double d)</td><td>Returns the base of the natural logarithms, e, to the power of the argument.</td></tr><tr><td>double log(double d)</td><td>Returns the natural logarithm of the argument.</td></tr><tr><td>double pow(double base, double exponent)</td><td>Returns the value of the first argument raised to the power of the second argument.</td></tr><tr><td>double sqrt(double d)</td><td>Returns the square root of the argument.</td></tr></tbody></table><p>The following program, <a href="https://docs.oracle.com/javase/tutorial/java/data/examples/ExponentialDemo.java">ExponentialDemo</a>, displays the value of e, then calls each of the methods listed in the previous table on arbitrarily chosen numbers:</p><p>public class ExponentialDemo {</p><p>public static void main(String[] args) {</p><p>double x = 11.635;</p><p>double y = 2.76;</p><p>System.out.printf(&quot;The value of &quot; + &quot;e is %.4f%n&quot;,</p><p>Math.E);</p><p>System.out.printf(&quot;exp(%.3f) &quot; + &quot;is %.3f%n&quot;,</p><p>x, Math.exp(x));</p><p>System.out.printf(&quot;log(%.3f) is &quot; + &quot;%.3f%n&quot;,</p><p>x, Math.log(x));</p><p>System.out.printf(&quot;pow(%.3f, %.3f) &quot; + &quot;is %.3f%n&quot;,</p><p>x, y, Math.pow(x, y));</p><p>System.out.printf(&quot;sqrt(%.3f) is &quot; + &quot;%.3f%n&quot;,</p><p>x, Math.sqrt(x));</p><p>}</p><p>}</p><p>Here&#x27;s the output you&#x27;ll see when you run ExponentialDemo:</p><p>The value of e is 2.7183</p><p>exp(11.635) is 112983.831</p><p>log(11.635) is 2.454</p><p>pow(11.635, 2.760) is 874.008</p><p>sqrt(11.635) is 3.411</p><h3>7.6.3 Trigonometric Methods</h3><p>The Math class also provides a collection of trigonometric functions, which are summarized in the following table. The value passed into each of these methods is an angle expressed in radians. You can use the toRadians method to convert from degrees to radians.</p><p>+-----------------------------------+-----------------------------------+
| <strong>Trigonometric Methods</strong>         |                                   |
+-----------------------------------+-----------------------------------+
| <strong>Method</strong>                        | <strong>Description</strong>                   |
+-----------------------------------+-----------------------------------+
| double sin(double d)              | Returns the sine of the specified |
|                                   | double value.                     |
+-----------------------------------+-----------------------------------+
| double cos(double d)              | Returns the cosine of the         |
|                                   | specified double value.           |
+-----------------------------------+-----------------------------------+
| double tan(double d)              | Returns the tangent of the        |
|                                   | specified double value.           |
+-----------------------------------+-----------------------------------+
| double asin(double d)             | Returns the arcsine of the        |
|                                   | specified double value.           |
+-----------------------------------+-----------------------------------+
| double acos(double d)             | Returns the arccosine of the      |
|                                   | specified double value.           |
+-----------------------------------+-----------------------------------+
| double atan(double d)             | Returns the arctangent of the     |
|                                   | specified double value.           |
+-----------------------------------+-----------------------------------+
| double atan2(double y, double x)  | Converts rectangular              |
|                                   | coordinates (x, y) to polar       |
|                                   | coordinate (r, theta) and         |
|                                   | returns theta.                    |
+-----------------------------------+-----------------------------------+
| double toDegrees(double d)\       | Converts the argument to degrees  |
| double toRadians(double d)        | or radians.                       |
+-----------------------------------+-----------------------------------+</p><p>Here&#x27;s a program, <a href="https://docs.oracle.com/javase/tutorial/java/data/examples/TrigonometricDemo.java">TrigonometricDemo</a>, that uses each of these methods to compute various trigonometric values for a 45-degree angle:</p><p>public class TrigonometricDemo {</p><p>public static void main(String[] args) {</p><p>double degrees = 45.0;</p><p>double radians = Math.toRadians(degrees);</p><p>System.out.format(&quot;The value of pi &quot; + &quot;is %.4f%n&quot;,</p><p>Math.PI);</p><p>System.out.format(&quot;The sine of %.1f &quot; + &quot;degrees is %.4f%n&quot;,</p><p>degrees, Math.sin(radians));</p><p>System.out.format(&quot;The cosine of %.1f &quot; + &quot;degrees is %.4f%n&quot;,</p><p>degrees, Math.cos(radians));</p><p>System.out.format(&quot;The tangent of %.1f &quot; + &quot;degrees is %.4f%n&quot;,</p><p>degrees, Math.tan(radians));</p><p>System.out.format(&quot;The arcsine of %.4f &quot; + &quot;is %.4f degrees %n&quot;,</p><p>Math.sin(radians),</p><p>Math.toDegrees(Math.asin(Math.sin(radians))));</p><p>System.out.format(&quot;The arccosine of %.4f &quot; + &quot;is %.4f degrees %n&quot;,</p><p>Math.cos(radians),</p><p>Math.toDegrees(Math.acos(Math.cos(radians))));</p><p>System.out.format(&quot;The arctangent of %.4f &quot; + &quot;is %.4f degrees %n&quot;,</p><p>Math.tan(radians),</p><p>Math.toDegrees(Math.atan(Math.tan(radians))));</p><p>}</p><p>}</p><p>The output of this program is as follows:</p><p>The value of pi is 3.1416</p><p>The sine of 45.0 degrees is 0.7071</p><p>The cosine of 45.0 degrees is 0.7071</p><p>The tangent of 45.0 degrees is 1.0000</p><p>The arcsine of 0.7071 is 45.0000 degrees</p><p>The arccosine of 0.7071 is 45.0000 degrees</p><p>The arctangent of 1.0000 is 45.0000 degrees</p><h3>7.6.4 Random Numbers</h3><p>The random() method returns a pseudo-randomly selected number between 0.0 and 1.0. The range includes 0.0 but not 1.0. In other words: 0.0 &lt;= Math.random() &lt; 1.0. To get a number in a different range, you can perform arithmetic on the value returned by the random method. For example, to generate an integer between 0 and 9, you would write:</p><p>int number = (int)(Math.random() <!-- -->*<!-- --> 10);</p><p>By multiplying the value by 10, the range of possible values becomes 0.0 &lt;= number &lt; 10.0.</p><p>Using Math.random works well when you need to generate a single random number. If you need to generate a series of random numbers, you should create an instance of java.util.Random and invoke methods on that object to generate numbers.</p><h2>7.7 Summary of Numbers</h2><p>You use one of the wrapper classes -- Byte, Double, Float, Integer, Long, or Short -- to wrap a number of primitive type in an object. The Java compiler automatically wraps (boxes) primitives for you when necessary and unboxes them, again when necessary.</p><p>The Number classes include constants and useful class methods. The MIN_VALUE and MAX_VALUE constants contain the smallest and largest values that can be contained by an object of that type. The byteValue, shortValue, and similar methods convert one numeric type to another. The valueOf method converts a string to a number, and the toString method converts a number to a string.</p><p>To format a string containing numbers for output, you can use the printf() or format() methods in the PrintStream class. Alternatively, you can use the NumberFormat class to customize numerical formats using patterns.</p><p>The Math class contains a variety of class methods for performing mathematical functions, including exponential, logarithmic, and trigonometric methods. Math also includes basic arithmetic functions, such as absolute value and rounding, and a method, random(), for generating random numbers.</p><h2>7.8 Characters</h2><p>Most of the time, if you are using a single character value, you will use the primitive char type. For example:</p><p>char ch = &#x27;a&#x27;;</p><p>// Unicode for uppercase Greek omega character</p><p>char uniChar = &#x27;<!-- -->\<!-- -->u03A9&#x27;;</p><p>// an array of chars</p><p>char[] charArray = { &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; };</p><p>There are times, however, when you need to use a char as an object---for example, as a method argument where an object is expected. The Java programming language provides a <em>wrapper</em>class that &quot;wraps&quot; the char in a Character object for this purpose. An object of type Character contains a single field, whose type is char. This <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html">Character</a> class also offers a number of useful class (i.e., static) methods for manipulating characters.</p><p>You can create a Character object with the Character constructor:</p><p>Character ch = new Character(&#x27;a&#x27;);</p><p>The Java compiler will also create a Character object for you under some circumstances. For example, if you pass a primitive char into a method that expects an object, the compiler automatically converts the char to a Character for you. This feature is called <em>autoboxing</em>---or <em>unboxing</em>, if the conversion goes the other way. For more information on autoboxing and unboxing, see <a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">Autoboxing and Unboxing</a>.</p><p><strong>Note:</strong> The Character class is immutable, so that once it is created, a Character object cannot be changed.</p><p>The following table lists some of the most useful methods in the Character class, but is not exhaustive. For a complete listing of all methods in this class (there are more than 50), refer to the<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html">java.lang.Character</a> API specification.</p><p>+-----------------------------------+-----------------------------------+
| <strong>Useful Methods in               |                                   |
| the Character Class</strong>             |                                   |
+-----------------------------------+-----------------------------------+
| <strong>Method</strong>                        | <strong>Description</strong>                   |
+-----------------------------------+-----------------------------------+
| boolean isLetter(char ch)\        | Determines whether the specified  |
| boolean isDigit(char ch)          | char value is a letter or a       |
|                                   | digit, respectively.              |
+-----------------------------------+-----------------------------------+
| boolean isWhitespace(char ch)     | Determines whether the specified  |
|                                   | char value is white space.        |
+-----------------------------------+-----------------------------------+
| boolean isUpperCase(char ch)\     | Determines whether the specified  |
| boolean isLowerCase(char ch)      | char value is uppercase or        |
|                                   | lowercase, respectively.          |
+-----------------------------------+-----------------------------------+
| char toUpperCase(char ch)\        | Returns the uppercase or          |
| char toLowerCase(char ch)         | lowercase form of the specified   |
|                                   | char value.                       |
+-----------------------------------+-----------------------------------+
| toString(char ch)                 | Returns a String object           |
|                                   | representing the specified        |
|                                   | character value --- that is, a    |
|                                   | one-character string.             |
+-----------------------------------+-----------------------------------+</p><h3>7.8.1 Escape Sequences</h3><p>A character preceded by a backslash (<!-- -->\<!-- -->) is an <em>escape sequence</em> and has special meaning to the compiler. The following table shows the Java escape sequences:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Escape Sequences</strong></td><td></td></tr><tr><td><strong>Escape Sequence</strong></td><td><strong>Description</strong></td></tr><tr><td>\<!-- -->t</td><td>Insert a tab in the text at this point.</td></tr><tr><td>\<!-- -->b</td><td>Insert a backspace in the text at this point.</td></tr><tr><td>\<!-- -->n</td><td>Insert a newline in the text at this point.</td></tr><tr><td>\<!-- -->r</td><td>Insert a carriage return in the text at this point.</td></tr><tr><td>\<!-- -->f</td><td>Insert a formfeed in the text at this point.</td></tr><tr><td>\<!-- -->&#x27;</td><td>Insert a single quote character in the text at this point.</td></tr><tr><td>\<!-- -->&quot;</td><td>Insert a double quote character in the text at this point.</td></tr><tr><td>\<!-- -->\</td><td>Insert a backslash character in the text at this point.</td></tr></tbody></table><p>When an escape sequence is encountered in a print statement, the compiler interprets it accordingly. For example, if you want to put quotes within quotes you must use the escape sequence, <!-- -->\<!-- -->&quot;, on the interior quotes. To print the sentence</p><p>She said &quot;Hello!&quot; to me.</p><p>you would write</p><p>System.out.println(&quot;She said <!-- -->\<!-- -->&quot;Hello!<!-- -->\<!-- -->&quot; to me.&quot;);</p><h2>7.9 Strings</h2><p>Strings, which are widely used in Java programming, are a sequence of characters. In the Java programming language, strings are objects.</p><p>The Java platform provides the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">String </a>class to create and manipulate strings.</p><h3>7.9.1 Creating Strings</h3><p>The most direct way to create a string is to write:</p><p>String greeting = &quot;Hello world!&quot;;</p><p>In this case, &quot;Hello world!&quot; is a <em>string literal</em>---a series of characters in your code that is enclosed in double quotes. Whenever it encounters a string literal in your code, the compiler creates a String object with its value---in this case, Hello world!.</p><p>As with any other object, you can create String objects by using the new keyword and a constructor. The String class has thirteen constructors that allow you to provide the initial value of the string using different sources, such as an array of characters:</p><p>char[] helloArray = { &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;.&#x27; };</p><p>String helloString = new String(helloArray);</p><p>System.out.println(helloString);</p><p>The last line of this code snippet displays hello.</p><p><strong>Note:</strong> The String class is immutable, so that once it is created a String object cannot be changed. The String class has a number of methods, some of which will be discussed below, that appear to modify strings. Since strings are immutable, what these methods really do is create and return a new string that contains the result of the operation.</p><h3>7.9.2 String Length</h3><p>Methods used to obtain information about an object are known as <em>accessor methods</em>. One accessor method that you can use with strings is the length() method, which returns the number of characters contained in the string object. After the following two lines of code have been executed, len equals 17:</p><p>String palindrome = &quot;Dot saw I was Tod&quot;;</p><p>int len = palindrome.length();</p><p>A <em>palindrome</em> is a word or sentence that is symmetric---it is spelled the same forward and backward, ignoring case and punctuation. Here is a short and inefficient program to reverse a palindrome string. It invokes the String method charAt(i), which returns the i^th^ character in the string, counting from 0.</p><p>public class StringDemo {</p><p>public static void main(String[] args) {</p><p>String palindrome = &quot;Dot saw I was Tod&quot;;</p><p>int len = palindrome.length();</p><p>char[] tempCharArray = new char<!-- -->[len]<!-- -->;</p><p>char[] charArray = new char<!-- -->[len]<!-- -->;</p><p>// put original string in an</p><p>// array of chars</p><p>for (int i = 0; i &lt; len; i++) {</p><p>tempCharArray<!-- -->[i]<!-- --> =</p><p>palindrome.charAt(i);</p><p>}</p><p>// reverse array of chars</p><p>for (int j = 0; j &lt; len; j++) {</p><p>charArray<!-- -->[j]<!-- --> =</p><p>tempCharArray<!-- -->[len - 1 - j]<!-- -->;</p><p>}</p><p>String reversePalindrome =</p><p>new String(charArray);</p><p>System.out.println(reversePalindrome);</p><p>}</p><p>}</p><p>Running the program produces this output:</p><p>doT saw I was toD</p><p>To accomplish the string reversal, the program had to convert the string to an array of characters (first for loop), reverse the array into a second array (second for loop), and then convert back to a string. The <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">String </a>class includes a method, getChars(), to convert a string, or a portion of a string, into an array of characters so we could replace the first for loop in the program above with</p><p>palindrome.getChars(0, len, tempCharArray, 0);</p><h3>Concatenating Strings</h3><p>The String class includes a method for concatenating two strings:</p><p>string1.concat(string2);</p><p>This returns a new string that is string1 with string2 added to it at the end.</p><p>You can also use the concat() method with string literals, as in:</p><p>&quot;My name is &quot;.concat(&quot;Rumplestiltskin&quot;);</p><p>Strings are more commonly concatenated with the <strong>+</strong> operator, as in</p><p>&quot;Hello,&quot; + &quot; world&quot; + &quot;!&quot;</p><p>which results in</p><p>&quot;Hello, world!&quot;</p><p>The <strong>+</strong> operator is widely used in print statements. For example:</p><p>String string1 = &quot;saw I was &quot;;</p><p>System.out.println(&quot;Dot &quot; + string1 + &quot;Tod&quot;);</p><p>which prints</p><p>Dot saw I was Tod</p><p>Such a concatenation can be a mixture of any objects. For each object that is not a String, its toString() method is called to convert it to a String.</p><p><strong>Note:</strong> The Java programming language does not permit literal strings to span lines in source files, so you must use the + concatenation operator at the end of each line in a multi-line string. For example:</p><p>String quote =</p><p>&quot;Now is the time for all good &quot; +</p><p>&quot;men to come to the aid of their country.&quot;;</p><p>Breaking strings between lines using the + concatenation operator is, once again, very common in print statements.</p><h3>7.9.4 Creating Format Strings</h3><p>You have seen the use of the printf() and format() methods to print output with formatted numbers. The String class has an equivalent class method, format(), that returns a Stringobject rather than a PrintStream object.</p><p>Using String&#x27;s static format() method allows you to create a formatted string that you can reuse, as opposed to a one-time print statement. For example, instead of</p><p>System.out.printf(&quot;The value of the float &quot; +</p><p>&quot;variable is %f, while &quot; +</p><p>&quot;the value of the &quot; +</p><p>&quot;integer variable is %d, &quot; +</p><p>&quot;and the string is %s&quot;,</p><p>floatVar, intVar, stringVar);</p><p>you can write</p><p>String fs;</p><p>fs = String.format(&quot;The value of the float &quot; +</p><p>&quot;variable is %f, while &quot; +</p><p>&quot;the value of the &quot; +</p><p>&quot;integer variable is %d, &quot; +</p><p>&quot; and the string is %s&quot;,</p><p>floatVar, intVar, stringVar);</p><p>System.out.println(fs);</p><h2>7.10 Converting Between Numbers and Strings</h2><h3>7.10.1 Converting Strings to Numbers</h3><p>Frequently, a program ends up with numeric data in a string object---a value entered by the user, for example.</p><p>The Number subclasses that wrap primitive numeric types ( <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Byte.html">Byte</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html">Integer</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html">Double</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Float.html">Float</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html">Long</a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Short.html">Short</a>) each provide a class method named valueOf that converts a string to an object of that type. Here is an example, <a href="https://docs.oracle.com/javase/tutorial/java/data/examples/ValueOfDemo.java">ValueOfDemo</a> , that gets two strings from the command line, converts them to numbers, and performs arithmetic operations on the values:</p><p>public class ValueOfDemo {</p><p>public static void main(String[] args) {</p><p>// this program requires two</p><p>// arguments on the command line</p><p>if (args.length == 2) {</p><p>// convert strings to numbers</p><p>float a = (Float.valueOf(args<!-- -->[0]<!-- -->)).floatValue();</p><p>float b = (Float.valueOf(args<!-- -->[1]<!-- -->)).floatValue();</p><p>// do some arithmetic</p><p>System.out.println(&quot;a + b = &quot; +</p><p>(a + b));</p><p>System.out.println(&quot;a - b = &quot; +</p><p>(a - b));</p><p>System.out.println(&quot;a <!-- -->*<!-- --> b = &quot; +</p><p>(a <!-- -->*<!-- --> b));</p><p>System.out.println(&quot;a / b = &quot; +</p><p>(a / b));</p><p>System.out.println(&quot;a % b = &quot; +</p><p>(a % b));</p><p>} else {</p><p>System.out.println(&quot;This program &quot; +</p><p>&quot;requires two command-line arguments.&quot;);</p><p>}</p><p>}</p><p>}</p><p>The following is the output from the program when you use 4.5 and 87.2 for the command-line arguments:</p><p>a + b = 91.7</p><p>a - b = -82.7</p><p>a <!-- -->*<!-- --> b = 392.4</p><p>a / b = 0.0516055</p><p>a % b = 4.5</p><p><strong>Note:</strong> Each of the Number subclasses that wrap primitive numeric types also provides a parseXXXX() method (for example, parseFloat()) that can be used to convert strings to primitive numbers. Since a primitive type is returned instead of an object, the parseFloat() method is more direct than the valueOf() method. For example, in the ValueOfDemoprogram, we could use:</p><p>float a = Float.parseFloat(args<!-- -->[0]<!-- -->);</p><p>float b = Float.parseFloat(args<!-- -->[1]<!-- -->);</p><h3>7.10.2 Converting Numbers to Strings</h3><p>Sometimes you need to convert a number to a string because you need to operate on the value in its string form. There are several easy ways to convert a number to a string:</p><p>int i;</p><p>// Concatenate &quot;i&quot; with an empty string; conversion is handled for you.</p><p>String s1 = &quot;&quot; + i;</p><p>or</p><p>// The valueOf class method.</p><p>String s2 = String.valueOf(i);</p><p>Each of the Number subclasses includes a class method, toString(), that will convert its primitive type to a string. For example:</p><p>int i;</p><p>double d;</p><p>String s3 = Integer.toString(i);</p><p>String s4 = Double.toString(d);</p><p>The <a href="https://docs.oracle.com/javase/tutorial/java/data/examples/ToStringDemo.java">ToStringDemo</a> example uses the toString method to convert a number to a string. The program then uses some string methods to compute the number of digits before and after the decimal point:</p><p>public class ToStringDemo {</p><p>public static void main(String[] args) {</p><p>double d = 858.48;</p><p>String s = Double.toString(d);</p><p>int dot = s.indexOf(&#x27;.&#x27;);</p><p>System.out.println(dot + &quot; digits &quot; +</p><p>&quot;before decimal point.&quot;);</p><p>System.out.println( (s.length() - dot - 1) +</p><p>&quot; digits after decimal point.&quot;);</p><p>}</p><p>}</p><p>The output of this program is:</p><p>3 digits before decimal point.</p><p>2 digits after decimal point.</p><h2>7.11 Manipulating Characters in a String</h2><p>The String class has a number of methods for examining the contents of strings, finding characters or substrings within a string, changing case, and other tasks.</p><h3>7.11.1 Getting Characters and Substrings by Index</h3><p>You can get the character at a particular index within a string by invoking the charAt() accessor method. The index of the first character is 0, while the index of the last character is length()-1. For example, the following code gets the character at index 9 in a string:</p><p>String anotherPalindrome = &quot;Niagara. O roar again!&quot;;</p><p>char aChar = anotherPalindrome.charAt(9);</p><p>Indices begin at 0, so the character at index 9 is &#x27;O&#x27;, as illustrated in the following figure:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8FAwAIzgLnN1PRkgAAAABJRU5ErkJggg==" alt="Use the charAt method to get a character at a particular index."/></p><p>If you want to get more than one consecutive character from a string, you can use the substring method. The substring method has two versions, as shown in the following table:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>The substring Methods in the String Class</strong></td><td></td></tr><tr><td><strong>Method</strong></td><td><strong>Description</strong></td></tr><tr><td>String substring(int beginIndex, int endIndex)</td><td>Returns a new string that is a substring of this string. The substring begins at the specified beginIndex and extends to the character at index endIndex - 1.</td></tr><tr><td>String substring(int beginIndex)</td><td>Returns a new string that is a substring of this string. The integer argument specifies the index of the first character. Here, the returned substring extends to the end of the original string.</td></tr></tbody></table><p>The following code gets from the Niagara palindrome the substring that extends from index 11 up to, but not including, index 15, which is the word &quot;roar&quot;:</p><p>String anotherPalindrome = &quot;Niagara. O roar again!&quot;;</p><p>String roar = anotherPalindrome.substring(11, 15);</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8JAwAIxgLj+Y0uRwAAAABJRU5ErkJggg==" alt="Use the substring method to get part of a string."/></p><h3>7.11.2 Other Methods for Manipulating Strings</h3><p>Here are several other String methods for manipulating strings:</p><p>+-----------------------------------+-----------------------------------+
| <strong>Other Methods in                |                                   |
| the String Class for Manipulating |                                   |
| Strings</strong>                         |                                   |
+-----------------------------------+-----------------------------------+
| <strong>Method</strong>                        | <strong>Description</strong>                   |
+-----------------------------------+-----------------------------------+
| String[] split(String regex)\   | Searches for a match as specified |
| String[] split(String regex,    | by the string argument (which     |
| int limit)                        | contains a regular expression)    |
|                                   | and splits this string into an    |
|                                   | array of strings accordingly. The |
|                                   | optional integer argument         |
|                                   | specifies the maximum size of the |
|                                   | returned array. Regular           |
|                                   | expressions are covered in the    |
|                                   | lesson titled &quot;Regular           |
|                                   | Expressions.&quot;                    |
+-----------------------------------+-----------------------------------+
| CharSequence subSequence(int      | Returns a new character sequence  |
| beginIndex, int endIndex)         | constructed from beginIndex index |
|                                   | up until endIndex - 1.            |
+-----------------------------------+-----------------------------------+
| String trim()                     | Returns a copy of this string     |
|                                   | with leading and trailing white   |
|                                   | space removed.                    |
+-----------------------------------+-----------------------------------+
| String toLowerCase()\             | Returns a copy of this string     |
| String toUpperCase()              | converted to lowercase or         |
|                                   | uppercase. If no conversions are  |
|                                   | necessary, these methods return   |
|                                   | the original string.              |
+-----------------------------------+-----------------------------------+</p><h3>7.11.3 Searching for Characters and Substrings in a String</h3><p>Here are some other String methods for finding characters or substrings within a string. The String class provides accessor methods that return the position within the string of a specific character or substring: indexOf() and lastIndexOf(). The indexOf() methods search forward from the beginning of the string, and the lastIndexOf() methods search backward from the end of the string. If a character or substring is not found, indexOf() and lastIndexOf() return -1.</p><p>The String class also provides a search method, contains, that returns true if the string contains a particular character sequence. Use this method when you only need to know that the string contains a character sequence, but the precise location isn&#x27;t important.</p><p>The following table describes the various string search methods.</p><p>+-----------------------------------+-----------------------------------+
| <strong>The Search Methods in           |                                   |
| the String Class</strong>                |                                   |
+-----------------------------------+-----------------------------------+
| <strong>Method</strong>                        | <strong>Description</strong>                   |
+-----------------------------------+-----------------------------------+
| int indexOf(int ch)\              | Returns the index of the first    |
| int lastIndexOf(int ch)           | (last) occurrence of the          |
|                                   | specified character.              |
+-----------------------------------+-----------------------------------+
| int indexOf(int ch, int           | Returns the index of the first    |
| fromIndex)\                       | (last) occurrence of the          |
| int lastIndexOf(int ch, int       | specified character, searching    |
| fromIndex)                        | forward (backward) from the       |
|                                   | specified index.                  |
+-----------------------------------+-----------------------------------+
| int indexOf(String str)\          | Returns the index of the first    |
| int lastIndexOf(String str)       | (last) occurrence of the          |
|                                   | specified substring.              |
+-----------------------------------+-----------------------------------+
| int indexOf(String str, int       | Returns the index of the first    |
| fromIndex)\                       | (last) occurrence of the          |
| int lastIndexOf(String str, int   | specified substring, searching    |
| fromIndex)                        | forward (backward) from the       |
|                                   | specified index.                  |
+-----------------------------------+-----------------------------------+
| boolean contains(CharSequence s)  | Returns true if the string        |
|                                   | contains the specified character  |
|                                   | sequence.                         |
+-----------------------------------+-----------------------------------+</p><p><strong>Note:</strong> CharSequence is an interface that is implemented by the String class. Therefore, you can use a string as an argument for the contains() method.</p><h3>7.11.4 Replacing Characters and Substrings into a String</h3><p>The String class has very few methods for inserting characters or substrings into a string. In general, they are not needed: You can create a new string by concatenation of substrings you have <em>removed</em> from a string with the substring that you want to insert.</p><p>The String class does have four methods for <em>replacing</em> found characters or substrings, however. They are:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Methods in the String Class for Manipulating Strings</strong></td><td></td></tr><tr><td><strong>Method</strong></td><td><strong>Description</strong></td></tr><tr><td>String replace(char oldChar, char newChar)</td><td>Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar.</td></tr><tr><td>String replace(CharSequence target, CharSequence replacement)</td><td>Replaces each substring of this string that matches the literal target sequence with the specified literal replacement sequence.</td></tr><tr><td>String replaceAll(String regex, String replacement)</td><td>Replaces each substring of this string that matches the given regular expression with the given replacement.</td></tr><tr><td>String replaceFirst(String regex, String replacement)</td><td>Replaces the first substring of this string that matches the given regular expression with the given replacement.</td></tr></tbody></table><h3>7.11.5 An Example</h3><p>The following class, <a href="https://docs.oracle.com/javase/tutorial/java/data/examples/Filename.java">Filename</a>, illustrates the use of lastIndexOf() and substring() to isolate different parts of a file name.</p><p><strong>Note:</strong> The methods in the following Filename class don&#x27;t do any error checking and assume that their argument contains a full directory path and a filename with an extension. If these methods were production code, they would verify that their arguments were properly constructed.</p><p>public class Filename {</p><p>private String fullPath;</p><p>private char pathSeparator,</p><p>extensionSeparator;</p><p>public Filename(String str, char sep, char ext) {</p><p>fullPath = str;</p><p>pathSeparator = sep;</p><p>extensionSeparator = ext;</p><p>}</p><p>public String extension() {</p><p>int dot = fullPath.lastIndexOf(extensionSeparator);</p><p>return fullPath.substring(dot + 1);</p><p>}</p><p>// gets filename without extension</p><p>public String filename() {</p><p>int dot = fullPath.lastIndexOf(extensionSeparator);</p><p>int sep = fullPath.lastIndexOf(pathSeparator);</p><p>return fullPath.substring(sep + 1, dot);</p><p>}</p><p>public String path() {</p><p>int sep = fullPath.lastIndexOf(pathSeparator);</p><p>return fullPath.substring(0, sep);</p><p>}</p><p>}</p><p>Here is a program, <a href="https://docs.oracle.com/javase/tutorial/java/data/examples/FilenameDemo.java">FilenameDemo</a>, that constructs a Filename object and calls all of its methods:</p><p>public class FilenameDemo {</p><p>public static void main(String[] args) {</p><p>final String FPATH = &quot;/home/user/index.html&quot;;</p><p>Filename myHomePage = new Filename(FPATH, &#x27;/&#x27;, &#x27;.&#x27;);</p><p>System.out.println(&quot;Extension = &quot; + myHomePage.extension());</p><p>System.out.println(&quot;Filename = &quot; + myHomePage.filename());</p><p>System.out.println(&quot;Path = &quot; + myHomePage.path());</p><p>}</p><p>}</p><p>And here&#x27;s the output from the program:</p><p>Extension = html</p><p>Filename = index</p><p>Path = /home/user</p><p>As shown in the following figure, our extension method uses lastIndexOf to locate the last occurrence of the period (.) in the file name. Then substring uses the return value of lastIndexOf to extract the file name extension --- that is, the substring from the period to the end of the string. This code assumes that the file name has a period in it; if the file name does not have a period, lastIndexOf returns -1, and the substring method throws a StringIndexOutOfBoundsException.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8uAwAIuALcG55BMgAAAABJRU5ErkJggg==" alt="The use of lastIndexOf and substring in the extension method in the Filename class."/></p><p>Also, notice that the extension method uses dot + 1 as the argument to substring. If the period character (.) is the last character of the string, dot + 1 is equal to the length of the string, which is one larger than the largest index into the string (because indices start at 0). This is a legal argument to substring because that method accepts an index equal to, but not greater than, the length of the string and interprets it to mean &quot;the end of the string.&quot;</p><h2>7.12 Comparing Strings and Portions of Strings</h2><p>The String class has a number of methods for comparing strings and portions of strings. The following table lists these methods.</p><p>+-----------------------------------+-----------------------------------+
| <strong>Methods for Comparing Strings</strong> |                                   |
+-----------------------------------+-----------------------------------+
| <strong>Method</strong>                        | <strong>Description</strong>                   |
+-----------------------------------+-----------------------------------+
| boolean endsWith(String suffix)\  | Returns true if this string ends  |
| boolean startsWith(String prefix) | with or begins with the substring |
|                                   | specified as an argument to the   |
|                                   | method.                           |
+-----------------------------------+-----------------------------------+
| boolean startsWith(String prefix, | Considers the string beginning at |
| int offset)                       | the index offset, and             |
|                                   | returns true if it begins with    |
|                                   | the substring specified as an     |
|                                   | argument.                         |
+-----------------------------------+-----------------------------------+
| int compareTo(String              | Compares two strings              |
| anotherString)                    | lexicographically. Returns an     |
|                                   | integer indicating whether this   |
|                                   | string is greater than (result is |
|                                   | &gt; 0), equal to (result is = 0),  |
|                                   | or less than (result is &lt; 0) the |
|                                   | argument.                         |
+-----------------------------------+-----------------------------------+
| int compareToIgnoreCase(String    | Compares two strings              |
| str)                              | lexicographically, ignoring       |
|                                   | differences in case. Returns an   |
|                                   | integer indicating whether this   |
|                                   | string is greater than (result is |
|                                   | &gt; 0), equal to (result is = 0),  |
|                                   | or less than (result is &lt; 0) the |
|                                   | argument.                         |
+-----------------------------------+-----------------------------------+
| boolean equals(Object anObject)   | Returns true if and only if the   |
|                                   | argument is a String object that  |
|                                   | represents the same sequence of   |
|                                   | characters as this object.        |
+-----------------------------------+-----------------------------------+
| boolean equalsIgnoreCase(String   | Returns true if and only if the   |
| anotherString)                    | argument is a String object that  |
|                                   | represents the same sequence of   |
|                                   | characters as this object,        |
|                                   | ignoring differences in case.     |
+-----------------------------------+-----------------------------------+
| boolean regionMatches(int         | Tests whether the specified       |
| toffset, String other, int        | region of this string matches the |
| ooffset, int len)                 | specified region of the String    |
|                                   | argument.                         |
|                                   |                                   |
|                                   | Region is of length len and       |
|                                   | begins at the index toffset for   |
|                                   | this string and ooffset for the   |
|                                   | other string.                     |
+-----------------------------------+-----------------------------------+
| boolean regionMatches(boolean     | Tests whether the specified       |
| ignoreCase, int toffset, String   | region of this string matches the |
| other, int ooffset, int len)      | specified region of the String    |
|                                   | argument.                         |
|                                   |                                   |
|                                   | Region is of length len and       |
|                                   | begins at the index toffset for   |
|                                   | this string and ooffset for the   |
|                                   | other string.                     |
|                                   |                                   |
|                                   | The boolean argument indicates    |
|                                   | whether case should be ignored;   |
|                                   | if true, case is ignored when     |
|                                   | comparing characters.             |
+-----------------------------------+-----------------------------------+
| boolean matches(String regex)     | Tests whether this string matches |
|                                   | the specified regular expression. |
|                                   | Regular expressions are discussed |
|                                   | in the lesson titled &quot;Regular    |
|                                   | Expressions.&quot;                    |
+-----------------------------------+-----------------------------------+</p><p>The following program, RegionMatchesDemo, uses the regionMatches method to search for a string within another string:</p><p>public class RegionMatchesDemo {</p><p>public static void main(String[] args) {</p><p>String searchMe = &quot;Green Eggs and Ham&quot;;</p><p>String findMe = &quot;Eggs&quot;;</p><p>int searchMeLength = searchMe.length();</p><p>int findMeLength = findMe.length();</p><p>boolean foundIt = false;</p><p>for (int i = 0;</p><p>i &lt;= (searchMeLength - findMeLength);</p><p>i++) {</p><p>if (searchMe.regionMatches(i, findMe, 0, findMeLength)) {</p><p>foundIt = true;</p><p>System.out.println(searchMe.substring(i, i + findMeLength));</p><p>break;</p><p>}</p><p>}</p><p>if (!foundIt)</p><p>System.out.println(&quot;No match found.&quot;);</p><p>}</p><p>}</p><p>The output from this program is Eggs.</p><p>The program steps through the string referred to by searchMe one character at a time. For each character, the program calls the regionMatches method to determine whether the substring beginning with the current character matches the string the program is looking for.</p><h2>7.13 The StringBuilder Class</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html">StringBuilder </a>objects are like <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">String </a>objects, except that they can be modified. Internally, these objects are treated like variable-length arrays that contain a sequence of characters. At any point, the length and content of the sequence can be changed through method invocations.</p><p>Strings should always be used unless string builders offer an advantage in terms of simpler code (see the sample program at the end of this section) or better performance. For example, if you need to concatenate a large number of strings, appending to a StringBuilder object is more efficient.</p><h3>7.13.1 Length and Capacity</h3><p>The StringBuilder class, like the String class, has a length() method that returns the length of the character sequence in the builder.</p><p>Unlike strings, every string builder also has a <em>capacity</em>, the number of character spaces that have been allocated. The capacity, which is returned by the capacity() method, is always greater than or equal to the length (usually greater than) and will automatically expand as necessary to accommodate additions to the string builder.</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>StringBuilder Constructors</strong></td><td></td></tr><tr><td><strong>Constructor</strong></td><td><strong>Description</strong></td></tr><tr><td>StringBuilder()</td><td>Creates an empty string builder with a capacity of 16 (16 empty elements).</td></tr><tr><td>StringBuilder(CharSequence cs)</td><td>Constructs a string builder containing the same characters as the specified CharSequence, plus an extra 16 empty elements trailing the CharSequence.</td></tr><tr><td>StringBuilder(int initCapacity)</td><td>Creates an empty string builder with the specified initial capacity.</td></tr><tr><td>StringBuilder(String s)</td><td>Creates a string builder whose value is initialized by the specified string, plus an extra 16 empty elements trailing the string.</td></tr></tbody></table><p>For example, the following code</p><p>// creates empty builder, capacity 16</p><p>StringBuilder sb = new StringBuilder();</p><p>// adds 9 character string at beginning</p><p>sb.append(&quot;Greetings&quot;);</p><p>will produce a string builder with a length of 9 and a capacity of 16:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8dAwAI2gLtmJjhiQAAAABJRU5ErkJggg==" alt="A string builder&#x27;s length is the number of characters it contains; a string builder&#x27;s capacity is the number of character spaces that have been allocated."/></p><p>The StringBuilder class has some methods related to length and capacity that the String class does not have:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Length and Capacity Methods</strong></td><td></td></tr><tr><td><strong>Method</strong></td><td><strong>Description</strong></td></tr><tr><td>void setLength(int newLength)</td><td>Sets the length of the character sequence. If newLength is less than length(), the last characters in the character sequence are truncated. If newLength is greater than length(), null characters are added at the end of the character sequence.</td></tr><tr><td>void ensureCapacity(int minCapacity)</td><td>Ensures that the capacity is at least equal to the specified minimum.</td></tr></tbody></table><p>A number of operations (for example, append(), insert(), or setLength()) can increase the length of the character sequence in the string builder so that the resultant length() would be greater than the current capacity(). When this happens, the capacity is automatically increased.</p><h3>7.13.2 StringBuilder Operations</h3><p>The principal operations on a StringBuilder that are not available in String are the append() and insert() methods, which are overloaded so as to accept data of any type. Each converts its argument to a string and then appends or inserts the characters of that string to the character sequence in the string builder. The append method always adds these characters at the end of the existing character sequence, while the insert method adds the characters at a specified point.</p><p>Here are a number of the methods of the StringBuilder class.</p><p>+-----------------------------------+-----------------------------------+
| <strong>Various StringBuilder Methods</strong> |                                   |
+-----------------------------------+-----------------------------------+
| <strong>Method</strong>                        | <strong>Description</strong>                   |
+-----------------------------------+-----------------------------------+
| StringBuilder append(boolean b)\  | Appends the argument to this      |
| StringBuilder append(char c)\     | string builder. The data is       |
| StringBuilder append(char[]     | converted to a string before the  |
| str)\                             | append operation takes place.     |
| StringBuilder append(char[]     |                                   |
| str, int offset, int len)\        |                                   |
| StringBuilder append(double d)\   |                                   |
| StringBuilder append(float f)\    |                                   |
| StringBuilder append(int i)\      |                                   |
| StringBuilder append(long lng)\   |                                   |
| StringBuilder append(Object obj)\ |                                   |
| StringBuilder append(String s)    |                                   |
+-----------------------------------+-----------------------------------+
| StringBuilder delete(int start,   | The first method deletes the      |
| int end)\                         | subsequence from start to end-1   |
| StringBuilder deleteCharAt(int    | (inclusive) in                    |
| index)                            | the StringBuilder&#x27;s char         |
|                                   | sequence. The second method       |
|                                   | deletes the character located     |
|                                   | at index.                         |
+-----------------------------------+-----------------------------------+
| StringBuilder insert(int offset,  | Inserts the second argument into  |
| boolean b)\                       | the string builder. The first     |
| StringBuilder insert(int offset,  | integer argument indicates the    |
| char c)\                          | index before which the data is to |
| StringBuilder insert(int offset,  | be inserted. The data is          |
| char[] str)\                    | converted to a string before the  |
| StringBuilder insert(int index,   | insert operation takes place.     |
| char[] str, int offset, int     |                                   |
| len)\                             |                                   |
| StringBuilder insert(int offset,  |                                   |
| double d)\                        |                                   |
| StringBuilder insert(int offset,  |                                   |
| float f)\                         |                                   |
| StringBuilder insert(int offset,  |                                   |
| int i)\                           |                                   |
| StringBuilder insert(int offset,  |                                   |
| long lng)\                        |                                   |
| StringBuilder insert(int offset,  |                                   |
| Object obj)\                      |                                   |
| StringBuilder insert(int offset,  |                                   |
| String s)                         |                                   |
+-----------------------------------+-----------------------------------+
| StringBuilder replace(int start,  | Replaces the specified            |
| int end, String s)\               | character(s) in this string       |
| void setCharAt(int index, char c) | builder.                          |
+-----------------------------------+-----------------------------------+
| StringBuilder reverse()           | Reverses the sequence of          |
|                                   | characters in this string         |
|                                   | builder.                          |
+-----------------------------------+-----------------------------------+
| String toString()                 | Returns a string that contains    |
|                                   | the character sequence in the     |
|                                   | builder.                          |
+-----------------------------------+-----------------------------------+</p><p><strong>Note:</strong> You can use any String method on a StringBuilder object by first converting the string builder to a string with the toString() method of the StringBuilder class. Then convert the string back into a string builder using the StringBuilder(String str) constructor.</p><h3>7.13.3 An Example</h3><p>The StringDemo program that was listed in the section titled &quot;Strings&quot; is an example of a program that would be more efficient if a StringBuilder were used instead of a String.</p><p>StringDemo reversed a palindrome. Here, once again, is its listing:</p><p>public class StringDemo {</p><p>public static void main(String[] args) {</p><p>String palindrome = &quot;Dot saw I was Tod&quot;;</p><p>int len = palindrome.length();</p><p>char[] tempCharArray = new char<!-- -->[len]<!-- -->;</p><p>char[] charArray = new char<!-- -->[len]<!-- -->;</p><p>// put original string in an</p><p>// array of chars</p><p>for (int i = 0; i &lt; len; i++) {</p><p>tempCharArray<!-- -->[i]<!-- --> =</p><p>palindrome.charAt(i);</p><p>}</p><p>// reverse array of chars</p><p>for (int j = 0; j &lt; len; j++) {</p><p>charArray<!-- -->[j]<!-- --> =</p><p>tempCharArray<!-- -->[len - 1 - j]<!-- -->;</p><p>}</p><p>String reversePalindrome =</p><p>new String(charArray);</p><p>System.out.println(reversePalindrome);</p><p>}</p><p>}</p><p>Running the program produces this output:</p><p>doT saw I was toD</p><p>To accomplish the string reversal, the program converts the string to an array of characters (first for loop), reverses the array into a second array (second for loop), and then converts back to a string.</p><p>If you convert the palindrome string to a string builder, you can use the reverse() method in the StringBuilder class. It makes the code simpler and easier to read:</p><p>public class StringBuilderDemo {</p><p>public static void main(String[] args) {</p><p>String palindrome = &quot;Dot saw I was Tod&quot;;</p><p>StringBuilder sb = new StringBuilder(palindrome);</p><p>sb.reverse(); // reverse it</p><p>System.out.println(sb);</p><p>}</p><p>}</p><p>Running this program produces the same output:</p><p>doT saw I was toD</p><p>Note that println() prints a string builder, as in:</p><p>System.out.println(sb);</p><p>because sb.toString() is called implicitly, as it is with any other object in a println() invocation.</p><p><strong>Note:</strong> There is also a StringBuffer class that is <em>exactly</em> the same as the StringBuilder class, except that it is thread-safe by virtue of having its methods synchronized. Threads will be discussed in the lesson on concurrency.</p><h2>7.14 Summary of Characters and Strings</h2><p>Most of the time, if you are using a single character value, you will use the primitive char type. There are times, however, when you need to use a char as an object---for example, as a method argument where an object is expected. The Java programming language provides a <em>wrapper</em> class that &quot;wraps&quot; the char in a Character object for this purpose. An object of type Charactercontains a single field whose type is char. This <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html">Character</a> class also offers a number of useful class (i.e., static) methods for manipulating characters.</p><p>Strings are a sequence of characters and are widely used in Java programming. In the Java programming language, strings are objects. The <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">String </a>class has over 60 methods and 13 constructors.</p><p>Most commonly, you create a string with a statement like</p><p>String s = &quot;Hello world!&quot;;</p><p>rather than using one of the String constructors.</p><p>The String class has many methods to find and retrieve substrings; these can then be easily reassembled into new strings using the <strong>+</strong> concatenation operator.</p><p>The String class also includes a number of utility methods, among them split(), toLowerCase(), toUpperCase(), and valueOf(). The latter method is indispensable in converting user input strings to numbers. The Number subclasses also have methods for converting strings to numbers and vice versa.</p><p>In addition to the String class, there is also a <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html">StringBuilder </a>class. Working with StringBuilder objects can sometimes be more efficient than working with strings. The StringBuilderclass offers a few methods that can be useful for strings, among them reverse(). In general, however, the String class has a wider variety of methods.</p><p>A string can be converted to a string builder using a StringBuilder constructor. A string builder can be converted to a string with the toString() method.</p><h2>7.15 Autoboxing and Unboxing</h2><p><em>Autoboxing</em> is the automatic conversion that the Java compiler makes between the primitive types and their corresponding object wrapper classes. For example, converting an int to an Integer, a double to a Double, and so on. If the conversion goes the other way, this is called <em>unboxing</em>.</p><p>Here is the simplest example of autoboxing:</p><p>Character ch = &#x27;a&#x27;;</p><p>The rest of the examples in this section use generics. If you are not yet familiar with the syntax of generics, see the <a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">Generics (Updated)</a> lesson.</p><p>Consider the following code:</p><pre><code class="language-java">List&lt;Integer&gt; li = new ArrayList&lt;&gt;();

for (int i = 1; i &lt; 50; i += 2)

li.add(i);
</code></pre><p>Although you add the int values as primitive types, rather than Integer objects, to li, the code compiles. Because li is a list of Integer objects, not a list of int values, you may wonder why the Java compiler does not issue a compile-time error. The compiler does not generate an error because it creates an Integer object from i and adds the object to li. Thus, the compiler converts the previous code to the following at runtime:</p><pre><code class="language-java">List&lt;Integer&gt; li = new ArrayList&lt;&gt;();

for (int i = 1; i &lt; 50; i += 2)

li.add(Integer.valueOf(i));
</code></pre><p>Converting a primitive value (an int, for example) into an object of the corresponding wrapper class (Integer) is called autoboxing. The Java compiler applies autoboxing when a primitive value is:</p><ul><li>Passed as a parameter to a method that expects an object of the corresponding wrapper class.</li><li>Assigned to a variable of the corresponding wrapper class.</li></ul><p>Consider the following method:</p><pre><code class="language-java">public static int sumEven(List&lt;Integer&gt; li) {

int sum = 0;

for (Integer i: li)

if (i % 2 == 0)

sum += i;

return sum;

}
</code></pre><p>Because the remainder (%) and unary plus (+=) operators do not apply to Integer objects, you may wonder why the Java compiler compiles the method without issuing any errors. The compiler does not generate an error because it invokes the intValue method to convert an Integer to an int at runtime:</p><pre><code class="language-java">public static int sumEven(List&lt;Integer&gt; li) {

int sum = 0;

for (Integer i : li)

if (i.intValue() % 2 == 0)

sum += i.intValue();

return sum;

}
</code></pre><p>Converting an object of a wrapper type (Integer) to its corresponding primitive (int) value is called unboxing. The Java compiler applies unboxing when an object of a wrapper class is:</p><ul><li>Passed as a parameter to a method that expects a value of the corresponding primitive type.</li><li>Assigned to a variable of the corresponding primitive type.</li></ul><p>The <a href="https://docs.oracle.com/javase/tutorial/java/data/examples/Unboxing.java">Unboxing</a> example shows how this works:</p><pre><code class="language-Java">import java.util.ArrayList;

import java.util.List;

public class Unboxing {

public static void main(String[] args) {

Integer i = new Integer(-8);

// 1. Unboxing through method invocation

int absVal = absoluteValue(i);

System.out.println(&quot;absolute value of &quot; + i + &quot; = &quot; + absVal);

List&lt;Double&gt; ld = new ArrayList&lt;&gt;();

ld.add(3.1416); // Π is autoboxed through method invocation.

// 2. Unboxing through assignment

double pi = ld.get(0);

System.out.println(&quot;pi = &quot; + pi);

}

public static int absoluteValue(int i) {

return (i &lt; 0) ? -i : i;

}

}
</code></pre><p>The program prints the following:</p><p>absolute value of -8 = 8</p><p>pi = 3.1416</p><p>Autoboxing and unboxing lets developers write cleaner code, making it easier to read. The following table lists the primitive types and their corresponding wrapper classes, which are used by the Java compiler for autoboxing and unboxing:</p><p>|--------------------|-------------------|
| <strong>Primitive type</strong> | <strong>Wrapper class</strong> |
| boolean            | Boolean           |
| byte               | Byte              |
| char               | Character         |
| float              | Float             |
| int                | Integer           |
| long               | Long              |
| short              | Short             |
| double             | Double            |</p><h1>8 Generics</h1><p>In any nontrivial software project, bugs are simply a fact of life. Careful planning, programming, and testing can help reduce their pervasiveness, but somehow, somewhere, they&#x27;ll always find a way to creep into your code. This becomes especially apparent as new features are introduced and your code base grows in size and complexity.</p><p>Fortunately, some bugs are easier to detect than others. Compile-time bugs, for example, can be detected early on; you can use the compiler&#x27;s error messages to figure out what the problem is and fix it, right then and there. Runtime bugs, however, can be much more problematic; they don&#x27;t always surface immediately, and when they do, it may be at a point in the program that is far removed from the actual cause of the problem.</p><p>Generics add stability to your code by making more of your bugs detectable at compile time. After completing this lesson, you may want to follow up with the <a href="https://docs.oracle.com/javase/tutorial/extra/generics/index.html">Generics</a> tutorial by Gilad Bracha.</p><h2>Why Use Generics?</h2><p>In a nutshell, generics enable <em>types</em> (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar <em>formal parameters</em> used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.</p><p>Code that uses generics has many benefits over non-generic code:</p><ul><li>Stronger type checks at compile time.
A Java compiler applies strong type checking to generic code and issues errors if the code violates type safety. Fixing compile-time errors is easier than fixing runtime errors, which can be difficult to find.</li><li>Elimination of casts.
The following code snippet without generics requires casting:</li><li>List list = new ArrayList();</li><li>list.add(&quot;hello&quot;);</li><li>String s = <strong>(String)</strong> list.get(0);</li></ul><p>When re-written to use generics, the code does not require casting:</p><pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;String&gt;();

list.add(&quot;hello&quot;);

String s = list.get(0); // no cast
</code></pre><ul><li>Enabling programmers to implement generic algorithms.
By using generics, programmers can implement generic algorithms that work on collections of different types, can be customized, and are type safe and easier to read.</li></ul><h2>Generic Types</h2><p>A <em>generic type</em> is a generic class or interface that is parameterized over types. The following Box class will be modified to demonstrate the concept.</p><h3>A Simple Box Class</h3><p>Begin by examining a non-generic Box class that operates on objects of any type. It needs only to provide two methods: set, which adds an object to the box, and get, which retrieves it:</p><pre><code class="language-java">public class Box {

private Object object;

public void set(Object object) { this.object = object; }

public Object get() { return object; }

}
</code></pre><p>Since its methods accept or return an Object, you are free to pass in whatever you want, provided that it is not one of the primitive types. There is no way to verify, at compile time, how the class is used. One part of the code may place an Integer in the box and expect to get Integers out of it, while another part of the code may mistakenly pass in a String, resulting in a runtime error.</p><h3>A Generic Version of the Box Class</h3><p>A <em>generic class</em> is defined with the following format:</p><pre><code class="language-java">class name&lt;T1, T2, \..., Tn&gt; { /\* \... \*/ }
</code></pre><p>The type parameter section, delimited by angle brackets <code>&lt;&gt;</code>, follows the class name. It specifies the <em>type parameters</em> (also called <em>type variables</em>) T1, T2, <!-- -->.<!-- -->.., and Tn.</p><p>To update the Box class to use generics, you create a <em>generic type declaration</em> by changing the code <code>public class Box</code> to <code>public class Box&lt;T&gt;</code>. This introduces the type variable, T, that can be used anywhere inside the class.</p><p>With this change, the Box class becomes:</p><pre><code class="language-java">/\*\*

\* Generic version of the Box class.

\* \@param &lt;T&gt; the type of the value being boxed

\*/

public class Box&lt;T&gt; {

// T stands for &quot;Type&quot;

private T t;

public void set(T t) { this.t = t; }

public T get() { return t; }

}
</code></pre><p>As you can see, all occurrences of Object are replaced by T. A type variable can be any <strong>non-primitive</strong> type you specify: any class type, any interface type, any array type, or even another type variable.</p><p>This same technique can be applied to create generic interfaces.</p><h3>Type Parameter Naming Conventions</h3><p>By convention, type parameter names are single, uppercase letters. This stands in sharp contrast to the variable <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html#naming">naming</a> conventions that you already know about, and with good reason: Without this convention, it would be difficult to tell the difference between a type variable and an ordinary class or interface name.</p><p>The most commonly used type parameter names are:</p><ul><li>E - Element (used extensively by the Java Collections Framework)</li><li>K - Key</li><li>N - Number</li><li>T - Type</li><li>V - Value</li><li>S,U,V etc. - 2nd, 3rd, 4th types</li></ul><p>You&#x27;ll see these names used throughout the Java SE API and the rest of this lesson.</p><h3>Invoking and Instantiating a Generic Type</h3><p>To reference the generic Box class from within your code, you must perform a <em>generic type invocation</em>, which replaces T with some concrete value, such as Integer:</p><pre><code class="language-java">Box&lt;Integer&gt; integerBox;
</code></pre><p>You can think of a generic type invocation as being similar to an ordinary method invocation, but instead of passing an argument to a method, you are passing a <em>type argument</em> --- Integer in this case --- to the Box class itself.</p><p><strong>Type Parameter and Type Argument Terminology:</strong> Many developers use the terms &quot;type parameter&quot; and &quot;type argument&quot; interchangeably, but these terms are not the same. When coding, one provides type arguments in order to create a parameterized type. Therefore, the <code>T</code> in <code>Foo&lt;T&gt;</code> is a type parameter and the String in <code>Foo&lt;String&gt;</code> f is a type argument. This lesson observes this definition when using these terms.</p><p>Like any other variable declaration, this code does not actually create a new Box object. It simply declares that integerBox will hold a reference to a &quot;Box of Integer&quot;, which is how <code>Box&lt;Integer&gt;</code> is read.</p><p>An invocation of a generic type is generally known as a <em>parameterized type</em>.</p><p>To instantiate this class, use the new keyword, as usual, but place <code>&lt;Integer&gt;</code> between the class name and the parenthesis:</p><pre><code class="language-java">Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();
</code></pre><h3>The Diamond</h3><p>In Java SE 7 and later, you can replace the type arguments required to invoke the constructor of a generic class with an empty set of type arguments <code>&lt;&gt;</code> as long as the compiler can determine, or infer, the type arguments from the context. This pair of angle brackets, <code>&lt;&gt;</code>, is informally called <em>the diamond</em>. For example, you can create an instance of <code>Box&lt;Integer&gt;</code> with the following statement:</p><pre><code class="language-java">Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();
</code></pre><p>For more information on diamond notation and type inference, see <a href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html">Type Inference</a>.</p><h3>Multiple Type Parameters</h3><p>As mentioned previously, a generic class can have multiple type parameters. For example, the generic OrderedPair class, which implements the generic Pair interface:</p><pre><code class="language-java">public interface Pair&lt;K, V&gt; {

public K getKey();

public V getValue();

}

public class OrderedPair&lt;K, V&gt; implements Pair&lt;K, V&gt; {

private K key;

private V value;

public OrderedPair(K key, V value) {

this.key = key;

this.value = value;

}

public K getKey() { return key; }

public V getValue() { return value; }

}
</code></pre><p>The following statements create two instantiations of the OrderedPair class:</p><pre><code class="language-java">Pair&lt;String, Integer&gt; p1 = new OrderedPair&lt;String, Integer&gt;(&quot;Even&quot;, 8);

Pair&lt;String, String&gt; p2 = new OrderedPair&lt;String, String&gt;(&quot;hello&quot;, &quot;world&quot;);
</code></pre><p>The code, <code>new OrderedPair&lt;String, Integer&gt;</code>, instantiates K as a String and V as an Integer. Therefore, the parameter types of OrderedPair&#x27;s constructor are String and Integer, respectively. Due to<a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">autoboxing</a>, it is valid to pass a String and an int to the class.</p><p>As mentioned in <a href="https://docs.oracle.com/javase/tutorial/java/generics/types.html#diamond">The Diamond</a>, because a Java compiler can infer the K and V types from the declaration <code>OrderedPair&lt;String, Integer&gt;</code>, these statements can be shortened using diamond notation:</p><pre><code class="language-java">OrderedPair&lt;String, Integer&gt; p1 = new OrderedPair**&lt;&gt;**(&quot;Even&quot;, 8);
OrderedPair&lt;String, String&gt; p2 = new OrderedPair**&lt;&gt;**(&quot;hello&quot;, &quot;world&quot;);
</code></pre><p>To create a generic interface, follow the same conventions as for creating a generic class.</p><h3>Parameterized Types</h3><p>You can also substitute a type parameter (i.e., K or V) with a parameterized type (i.e., <code>List&lt;String&gt;</code>). For example, using the <code>OrderedPair&lt;K, V&gt;</code> example:</p><pre><code class="language-java">OrderedPair&lt;String, **Box&lt;Integer&gt;**&gt; p = new OrderedPair&lt;&gt;(&quot;primes&quot;, new Box&lt;Integer&gt;(\...));
</code></pre><h2>Raw Types</h2><p>A <em>raw type</em> is the name of a generic class or interface without any type arguments. For example, given the generic Box class:</p><pre><code class="language-java">public class Box&lt;T&gt; {

public void set(T t) { /\* \... \*/ }

// \...

}
</code></pre><p>To create a parameterized type of <code>Box&lt;T&gt;</code>, you supply an actual type argument for the formal type parameter T:</p><pre><code class="language-java">Box&lt;Integer&gt; intBox = new Box&lt;&gt;();
</code></pre><p>If the actual type argument is omitted, you create a raw type of <code>Box&lt;T&gt;</code>:</p><pre><code class="language-java">Box rawBox = new Box();
</code></pre><p>Therefore, Box is the raw type of the generic type <code>Box&lt;T&gt;</code>. However, a non-generic class or interface type is <em>not</em> a raw type.</p><p>Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior --- a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:</p><pre><code class="language-java">Box&lt;String&gt; stringBox = new Box&lt;&gt;();
Box rawBox = stringBox; // OK
</code></pre><p>But if you assign a raw type to a parameterized type, you get a warning:</p><pre><code class="language-java">Box rawBox = new Box(); // rawBox is a raw type of Box&lt;T&gt;
Box&lt;Integer&gt; intBox = rawBox; // warning: unchecked conversion
</code></pre><p>You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:</p><pre><code class="language-java">Box&lt;String&gt; stringBox = new Box&lt;&gt;();
Box rawBox = stringBox;
rawBox.set(8); // warning: unchecked invocation to set(T)
</code></pre><p>The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.</p><p>The <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">Type Erasure</a> section has more information on how the Java compiler uses raw types.</p><h3>8.3.1 Unchecked Error Messages</h3><p>As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:</p><p>Note: Example.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.</p><p>This can happen when using an older API that operates on raw types, as shown in the following example:</p><pre><code class="language-java">public class WarningDemo {

public static void main(String[] args){

Box&lt;Integer&gt; bi;

bi = createBox();

}

static Box createBox(){

return new Box();

}

}
</code></pre><p>The term &quot;unchecked&quot; means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The &quot;unchecked&quot; warning is disabled, by default, though the compiler gives a hint. To see all &quot;unchecked&quot; warnings, recompile with -Xlint:unchecked.</p><p>Recompiling the previous example with -Xlint:unchecked reveals the following additional information:</p><pre><code class="language-bash">WarningDemo.java:4: warning: [unchecked] unchecked conversion

found : Box

required: Box&lt;java.lang.Integer&gt;

bi = createBox();

\^

1 warning
</code></pre><p>To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The \@SuppressWarnings(&quot;unchecked&quot;) annotation suppresses unchecked warnings. If you are unfamiliar with the \@SuppressWarnings syntax, see <a href="https://docs.oracle.com/javase/tutorial/java/annotations/index.html">Annotations</a>.</p><h2>8.4 Generic Methods</h2><p><em>Generic methods</em> are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter&#x27;s scope is limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.</p><p>The syntax for a generic method includes a list of type parameters, inside angle brackets, which appears before the method&#x27;s return type. For static generic methods, the type parameter section must appear before the method&#x27;s return type.</p><p>The Util class includes a generic method, compare, which compares two Pair objects:</p><pre><code class="language-java">public class Util {

**public static &lt;K, V&gt; boolean compare(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2)** {

return p1.getKey().equals(p2.getKey()) &amp;&amp;

p1.getValue().equals(p2.getValue());

}

}

public class Pair&lt;K, V&gt; {

private K key;

private V value;

public Pair(K key, V value) {

this.key = key;

this.value = value;

}

public void setKey(K key) { this.key = key; }

public void setValue(V value) { this.value = value; }

public K getKey() { return key; }

public V getValue() { return value; }

}
</code></pre><p>The complete syntax for invoking this method would be:</p><pre><code class="language-java">Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, &quot;apple&quot;);

Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, &quot;pear&quot;);

boolean same = Util.**&lt;Integer, String&gt;**compare(p1, p2);
</code></pre><p>The type has been explicitly provided, as shown in bold. Generally, this can be left out and the compiler will infer the type that is needed:</p><pre><code class="language-java">Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, &quot;apple&quot;);

Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, &quot;pear&quot;);

boolean same = Util.compare(p1, p2);
</code></pre><p>This feature, known as <em>type inference</em>, allows you to invoke a generic method as an ordinary method, without specifying a type between angle brackets. This topic is further discussed in the following section, <a href="https://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html">Type Inference</a>.</p><h2>8.5 Bounded Type Parameters</h2><p>There may be times when you want to restrict the types that can be used as type arguments in a parameterized type. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. This is what <em>bounded type parameters</em> are for.</p><p>To declare a bounded type parameter, list the type parameter&#x27;s name, followed by the extends keyword, followed by its <em>upper bound</em>, which in this example is Number. Note that, in this context, extends is used in a general sense to mean either &quot;extends&quot; (as in classes) or &quot;implements&quot; (as in interfaces).</p><pre><code class="language-java">public class Box&lt;T&gt; {

private T t;

public void set(T t) {

this.t = t;

}

public T get() {

return t;

}

public &lt;U **extends Number**&gt; void inspect(U u){

System.out.println(&quot;T: &quot; + t.getClass().getName());

System.out.println(&quot;U: &quot; + u.getClass().getName());

}

public static void main(String[] args) {

Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();

integerBox.set(new Integer(10));

integerBox.inspect(&quot;some text&quot;); // **error: this is still String!**

}

}
</code></pre><p>By modifying our generic method to include this bounded type parameter, compilation will now fail, since our invocation of inspect still includes a String:</p><pre><code class="language-bash">Box.java:21: &lt;U&gt;inspect(U) in Box&lt;java.lang.Integer&gt; cannot

be applied to (java.lang.String)

integerBox.inspect(&quot;10&quot;);

\^

1 error
</code></pre><p>In addition to limiting the types you can use to instantiate a generic type, bounded type parameters allow you to invoke methods defined in the bounds:</p><pre><code class="language-java">public class NaturalNumber&lt;T extends Integer&gt; {

private T n;

public NaturalNumber(T n) { this.n = n; }

public boolean isEven() {

return **n.intValue()** % 2 == 0;

}

// \...

}
</code></pre><p>The isEven method invokes the intValue method defined in the Integer class through n.</p><h3>8.5.1 Multiple Bounds</h3><p>The preceding example illustrates the use of a type parameter with a single bound, but a type parameter can have <em>multiple bounds</em>:</p><pre><code class="language-java">&lt;T extends B1 &amp; B2 &amp; B3&gt;
</code></pre><p>A type variable with multiple bounds is a subtype of all the types listed in the bound. If one of the bounds is a class, it must be specified first. For example:</p><pre><code class="language-java">Class A { /\* \... \*/ }

interface B { /\* \... \*/ }

interface C { /\* \... \*/ }

class D &lt;T extends A &amp; B &amp; C&gt; { /\* \... \*/ }
</code></pre><p>If bound A is not specified first, you get a compile-time error:</p><pre><code class="language-java">class D &lt;T extends B &amp; A &amp; C&gt; { /\* \... \*/ } // compile-time error
</code></pre><h2>8.6 Generic Methods and Bounded Type Parameters</h2><p>Bounded type parameters are key to the implementation of generic algorithms. Consider the following method that counts the number of elements in an array T[] that are greater than a specified element elem.</p><pre><code class="language-java">public static &lt;T&gt; int countGreaterThan(T[] anArray, T elem) {

int count = 0;

for (T e : anArray)

if (e &gt; elem) // compiler error

++count;

return count;

}
</code></pre><p>The implementation of the method is straightforward, but it does not compile because the greater than operator (&gt;) applies only to primitive types such as short, int, double, long, float, byte, and char. You cannot use the &gt; operator to compare objects. To fix the problem, use a type parameter bounded by the <code>Comparable&lt;T&gt;</code> interface:</p><pre><code class="language-java">public interface Comparable&lt;T&gt; {

public int compareTo(T o);

}
</code></pre><p>The resulting code will be:</p><pre><code class="language-java">public static &lt;T extends Comparable&lt;T&gt;&gt; int countGreaterThan(T[] anArray, T elem) {

int count = 0;

for (T e : anArray)

if (e.compareTo(elem) &gt; 0)

++count;

return count;

}
</code></pre><h2>8.7 Generics, Inheritance, and Subtypes</h2><p>As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an Integer to an Object, since Object is one of Integer&#x27;s supertypes:</p><pre><code class="language-java">Object someObject = new Object();

Integer someInteger = new Integer(10);

someObject = someInteger; // OK
</code></pre><p>In object-oriented terminology, this is called an &quot;is a&quot; relationship. Since an Integer <em>is a</em> kind of Object, the assignment is allowed. But Integer is also a kind of Number, so the following code is valid as well:</p><pre><code class="language-java">public void someMethod(Number n) { /\* \... \*/ }

someMethod(new Integer(10)); // OK

someMethod(new Double(10.1)); // OK
</code></pre><p>The same is also true with generics. You can perform a generic type invocation, passing Number as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with Number:</p><pre><code class="language-java">Box&lt;Number&gt; box = new Box&lt;Number&gt;();

box.add(new Integer(10)); // OK

box.add(new Double(10.1)); // OK
</code></pre><p>Now consider the following method:</p><pre><code class="language-java">public void boxTest(Box&lt;Number&gt; n) { /\* \... \*/ }
</code></pre><p>What type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is <code>Box&lt;Number&gt;</code>. But what does that mean? Are you allowed to pass in <code>Box&lt;Integer&gt;</code>or <code>Box&lt;Double&gt;</code>, as you might expect? The answer is &quot;no&quot;, because <code>Box&lt;Integer&gt;</code> and <code>Box&lt;Double&gt;</code> are not subtypes of <code>Box&lt;Number&gt;</code>.</p><p>This is a common misunderstanding when it comes to programming with generics, but it is an important concept to learn.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8zAwAI5ALypOdmJwAAAABJRU5ErkJggg==" alt="diagram showing that `Box&lt;Integer&gt;` is not a subtype of `Box&lt;Number&gt;`"/></p><p><code>Box&lt;Integer&gt;</code> is not a subtype of <code>Box&lt;Number&gt;</code> even though Integer is a subtype of Number.</p><p><strong>Note:</strong> Given two concrete types A and B (for example, Number and Integer), <code>MyClass&lt;A&gt;</code> has no relationship to <code>MyClass&lt;B&gt;</code>, regardless of whether or not A and B are related. The common parent of <code>MyClass&lt;A&gt;</code> and <code>MyClass&lt;B&gt;</code> is Object.</p><p>For information on how to create a subtype-like relationship between two generic classes when the type parameters are related, see <a href="https://docs.oracle.com/javase/tutorial/java/generics/subtyping.html">Wildcards and Subtyping</a>.</p><h3>8.7.1 Generic Classes and Subtyping</h3><p>You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.</p><p>Using the Collections classes as an example, <code>ArrayList&lt;E&gt; implements List&lt;E&gt;</code>, and <code>List&lt;E&gt;</code> extends <code>Collection&lt;E&gt;</code>. So <code>ArrayList&lt;String&gt;</code> is a subtype of <code>List&lt;String&gt;</code>, which is a subtype of <code>Collection&lt;String&gt;</code>. So long as you do not vary the type argument, the subtyping relationship is preserved between the types.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//87AwAI7AL2nna94QAAAABJRU5ErkJggg==" alt="diagram showing a sample collections hierarchy: `ArrayList&lt;String&gt;` is a subtype of `List&lt;String&gt;`, which is a subtype of `Collection&lt;String&gt;`."/></p><p>A sample Collections hierarchy</p><p>Now imagine we want to define our own list interface, PayloadList, that associates an optional value of generic type P with each element. Its declaration might look like:</p><pre><code class="language-java">interface PayloadList&lt;E,P&gt; extends List&lt;E&gt; {

void setPayload(int index, P val);

\...

}
</code></pre><p>The following parameterizations of PayloadList are subtypes of <code>List&lt;String&gt;</code>:</p><ul><li>PayloadList&lt;String,String&gt;</li><li>PayloadList&lt;String,Integer&gt;</li><li>PayloadList&lt;String,Exception&gt;</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//82AwAItALar9bPygAAAABJRU5ErkJggg==" alt="diagram showing an example PayLoadList hierarchy: PayloadList&lt;String, String&gt; is a subtype of `List&lt;String&gt;`, which is a subtype of `Collection&lt;String&gt;`. At the same level of PayloadList&lt;String,String&gt; is PayloadList&lt;String, Integer&gt; and PayloadList&lt;String, Exceptions&gt;."/></p><p>A sample PayloadList hierarchy</p><h2>8.8 Type Inference</h2><p><em>Type inference</em> is a Java compiler&#x27;s ability to look at each method invocation and corresponding declaration to determine the type argument (or arguments) that make the invocation applicable. The inference algorithm determines the types of the arguments and, if available, the type that the result is being assigned, or returned. Finally, the inference algorithm tries to find the <em>most specific</em>type that works with all of the arguments.</p><p>To illustrate this last point, in the following example, inference determines that the second argument being passed to the pick method is of type Serializable:</p><pre><code class="language-java">static &lt;T&gt; T pick(T a1, T a2) { return a2; }
Serializable s = pick(&quot;d&quot;, new ArrayList&lt;String&gt;());
</code></pre><h3>8.8.1 Type Inference and Generic Methods</h3><p><a href="https://docs.oracle.com/javase/tutorial/java/generics/methods.html">Generic Methods</a> introduced you to type inference, which enables you to invoke a generic method as you would an ordinary method, without specifying a type between angle brackets. Consider the following example, <a href="https://docs.oracle.com/javase/tutorial/java/generics/examples/BoxDemo.java">BoxDemo</a>, which requires the <a href="https://docs.oracle.com/javase/tutorial/java/generics/examples/Box.java">Box</a> class:</p><pre><code class="language-Java">public class BoxDemo {

public static &lt;U&gt; void addBox(U u,

java.util.List&lt;Box&lt;U&gt;&gt; boxes) {

Box&lt;U&gt; box = new Box&lt;&gt;();

box.set(u);

boxes.add(box);

}

public static &lt;U&gt; void outputBoxes(java.util.List&lt;Box&lt;U&gt;&gt; boxes) {

int counter = 0;

for (Box&lt;U&gt; box: boxes) {

U boxContents = box.get();

System.out.println(&quot;Box \#&quot; + counter + &quot; contains [&quot; +

boxContents.toString() + &quot;]&quot;);

counter++;

}

}

public static void main(String[] args) {

java.util.ArrayList&lt;Box&lt;Integer&gt;&gt; listOfIntegerBoxes =

new java.util.ArrayList&lt;&gt;();

BoxDemo.&lt;Integer&gt;addBox(Integer.valueOf(10), listOfIntegerBoxes);

BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);

BoxDemo.addBox(Integer.valueOf(30), listOfIntegerBoxes);

BoxDemo.outputBoxes(listOfIntegerBoxes);

}

}
</code></pre><p>The following is the output from this example:</p><p>Box <!-- -->#<!-- -->0 contains <!-- -->[10]</p><p>Box <!-- -->#<!-- -->1 contains <!-- -->[20]</p><p>Box <!-- -->#<!-- -->2 contains <!-- -->[30]</p><p>The generic method addBox defines one type parameter named U. Generally, a Java compiler can infer the type parameters of a generic method call. Consequently, in most cases, you do not have to specify them. For example, to invoke the generic method addBox, you can specify the type parameter with a <em>type witness</em> as follows:</p><p>BoxDemo.<strong><code>&lt;Integer&gt;</code></strong>addBox(Integer.valueOf(10), listOfIntegerBoxes);</p><p>Alternatively, if you omit the type witness,a Java compiler automatically infers (from the method&#x27;s arguments) that the type parameter is Integer:</p><p>BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);</p><h3>8.8.2 Type Inference and Instantiation of Generic Classes</h3><p>You can replace the type arguments required to invoke the constructor of a generic class with an empty set of type parameters <code>&lt;&gt;</code> as long as the compiler can infer the type arguments from the context. This pair of angle brackets is informally called <a href="https://docs.oracle.com/javase/tutorial/java/generics/types.html#diamond">the diamond</a>.</p><p>For example, consider the following variable declaration:</p><pre><code class="language-java">Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;String, List&lt;String&gt;&gt;();
</code></pre><p>You can substitute the parameterized type of the constructor with an empty set of type parameters <code>&lt;&gt;</code>:</p><pre><code class="language-java">Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;&gt;();
</code></pre><p>Note that to take advantage of type inference during generic class instantiation, you must use the diamond. In the following example, the compiler generates an unchecked conversion warning because the HashMap() constructor refers to the HashMap raw type, not the Map&lt;String, <code>List&lt;String&gt;</code>&gt; type:</p><pre><code class="language-java">Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap(); // unchecked conversion warning
</code></pre><h3>8.8.3 Type Inference and Generic Constructors of Generic and Non-Generic Classes</h3><p>Note that constructors can be generic (in other words, declare their own formal type parameters) in both generic and non-generic classes. Consider the following example:</p><pre><code class="language-java">class MyClass&lt;X&gt; {

&lt;T&gt; MyClass(T t) {

// \...

}

}
</code></pre><p>Consider the following instantiation of the class MyClass:</p><pre><code class="language-java">new MyClass&lt;Integer&gt;(&quot;&quot;)
</code></pre><p>This statement creates an instance of the parameterized type <code>MyClass&lt;Integer&gt;</code>; the statement explicitly specifies the type Integer for the formal type parameter, X, of the generic class <code>MyClass&lt;X&gt;</code>. Note that the constructor for this generic class contains a formal type parameter, T. The compiler infers the type String for the formal type parameter, T, of the constructor of this generic class (because the actual parameter of this constructor is a String object).</p><p>Compilers from releases prior to Java SE 7 are able to infer the actual type parameters of generic constructors, similar to generic methods. However, compilers in Java SE 7 and later can infer the actual type parameters of the generic class being instantiated if you use the diamond (<code>&lt;&gt;</code>). Consider the following example:</p><pre><code class="language-java">MyClass&lt;Integer&gt; myObject = new MyClass&lt;&gt;(&quot;&quot;);
</code></pre><p>In this example, the compiler infers the type Integer for the formal type parameter, X, of the generic class <code>MyClass&lt;X&gt;</code>. It infers the type String for the formal type parameter, T, of the constructor of this generic class.</p><p><strong>Note:</strong> It is important to note that the inference algorithm uses only invocation arguments, target types, and possibly an obvious expected return type to infer types. The inference algorithm does not use results from later in the program.</p><h3>8.8.4 Target Types</h3><p>The Java compiler takes advantage of target typing to infer the type parameters of a generic method invocation. The <em>target type</em> of an expression is the data type that the Java compiler expects depending on where the expression appears. Consider the method Collections.emptyList, which is declared as follows:</p><pre><code class="language-java">static &lt;T&gt; List&lt;T&gt; emptyList();
</code></pre><p>Consider the following assignment statement:</p><pre><code class="language-java">List&lt;String&gt; listOne = Collections.emptyList();
</code></pre><p>This statement is expecting an instance of <code>List&lt;String&gt;</code>; this data type is the target type. Because the method emptyList returns a value of type <code>List&lt;T&gt;</code>, the compiler infers that the type argument T must be the value String. This works in both Java SE 7 and 8. Alternatively, you could use a type witness and specify the value of T as follows:</p><pre><code class="language-java">List&lt;String&gt; listOne = Collections.&lt;String&gt;emptyList();
</code></pre><p>However, this is not necessary in this context. It was necessary in other contexts, though. Consider the following method:</p><pre><code class="language-java">void processStringList(List&lt;String&gt; stringList) {

// process stringList

}
</code></pre><p>Suppose you want to invoke the method processStringList with an empty list. In Java SE 7, the following statement does not compile:</p><p>processStringList(Collections.emptyList());</p><p>The Java SE 7 compiler generates an error message similar to the following:</p><pre><code class="language-java">List&lt;Object&gt; cannot be converted to List&lt;String&gt;
</code></pre><p>The compiler requires a value for the type argument T so it starts with the value Object. Consequently, the invocation of Collections.emptyList returns a value of type <code>List&lt;Object&gt;</code>, which is incompatible with the method processStringList. Thus, in Java SE 7, you must specify the value of the value of the type argument as follows:</p><pre><code class="language-java">processStringList(Collections.&lt;String&gt;emptyList());
</code></pre><p>This is no longer necessary in Java SE 8. The notion of what is a target type has been expanded to include method arguments, such as the argument to the method processStringList. In this case, processStringList requires an argument of type <code>List&lt;String&gt;</code>. The method Collections.emptyList returns a value of <code>List&lt;T&gt;</code>, so using the target type of <code>List&lt;String&gt;</code>, the compiler infers that the type argument T has a value of String. Thus, in Java SE 8, the following statement compiles:</p><p>processStringList(Collections.emptyList());</p><p>See <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#target-typing">Target Typing</a> in <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Lambda Expressions</a> for more information.</p><h2>8.9 Wildcards</h2><p>In generic code, the question mark (?), called the <em>wildcard</em>, represents an unknown type. The wildcard can be used in a variety of situations: as the type of a parameter, field, or local variable; sometimes as a return type (though it is better programming practice to be more specific). The wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype.</p><p>The following sections discuss wildcards in more detail, including upper bounded wildcards, lower bounded wildcards, and wildcard capture.</p><h2>8.10 Upper Bounded Wildcards</h2><p>You can use an upper bounded wildcard to relax the restrictions on a variable. For example, say you want to write a method that works on <code>List&lt;Integer&gt;</code>, <code>List&lt;Double&gt;</code>, <em>and</em> <code>List&lt;Number&gt;</code>; you can achieve this by using an upper bounded wildcard.</p><p>To declare an upper-bounded wildcard, use the wildcard character (&#x27;?&#x27;), followed by the extends keyword, followed by its <em>upper bound</em>. Note that, in this context, extends is used in a general sense to mean either &quot;extends&quot; (as in classes) or &quot;implements&quot; (as in interfaces).</p><p>To write the method that works on lists of Number and the subtypes of Number, such as Integer, Double, and Float, you would specify List&lt;? extends Number&gt;. The term <code>List&lt;Number&gt;</code> is more restrictive than List&lt;? extends Number&gt; because the former matches a list of type Number only, whereas the latter matches a list of type Number or any of its subclasses.</p><p>Consider the following process method:</p><pre><code class="language-java">public static void process(List**&lt;? extends Foo&gt;** list) { /\* \... \*/ }
</code></pre><p>The upper bounded wildcard, &lt;? extends Foo&gt;, where Foo is any type, matches Foo and any subtype of Foo. The process method can access the list elements as type Foo:</p><pre><code class="language-java">public static void process(List&lt;? extends Foo&gt; list) {

for (Foo elem : list) {

// \...

}

}
</code></pre><p>In the foreach clause, the elem variable iterates over each element in the list. Any method defined in the Foo class can now be used on elem.</p><p>The sumOfList method returns the sum of the numbers in a list:</p><pre><code class="language-java">public static double sumOfList(List&lt;? extends Number&gt; list) {

double s = 0.0;

for (Number n : list)

s += n.doubleValue();

return s;

}
</code></pre><p>The following code, using a list of Integer objects, prints sum = 6.0:</p><pre><code class="language-java">List&lt;Integer&gt; li = Arrays.asList(1, 2, 3);

System.out.println(&quot;sum = &quot; + sumOfList(li));
</code></pre><p>A list of Double values can use the same sumOfList method. The following code prints sum = 7.0:</p><pre><code class="language-java">List&lt;Double&gt; ld = Arrays.asList(1.2, 2.3, 3.5);

System.out.println(&quot;sum = &quot; + sumOfList(ld));
</code></pre><h2>8.11 Unbounded Wildcards</h2><p>The unbounded wildcard type is specified using the wildcard character (?), for example, List&lt;?&gt;. This is called a <em>list of unknown type</em>. There are two scenarios where an unbounded wildcard is a useful approach:</p><ul><li>If you are writing a method that can be implemented using functionality provided in the Object class.</li><li>When the code is using methods in the generic class that don&#x27;t depend on the type parameter. For example, List.size or List.clear. In fact, Class&lt;?&gt; is so often used because most of the methods in <code>Class&lt;T&gt;</code> do not depend on T.</li></ul><p>Consider the following method, printList:</p><pre><code class="language-java">public static void printList(List&lt;Object&gt; list) {

for (Object elem : list)

System.out.println(elem + &quot; &quot;);

System.out.println();

}
</code></pre><p>The goal of printList is to print a list of any type, but it fails to achieve that goal --- it prints only a list of Object instances; it cannot print <code>List&lt;Integer&gt;</code>, <code>List&lt;String&gt;</code>, <code>List&lt;Double&gt;</code>, and so on, because they are not subtypes of <code>List&lt;Object&gt;</code>. To write a generic printList method, use List&lt;?&gt;:</p><p>public static void printList(List&lt;?&gt; list) {</p><p>for (Object elem: list)</p><p>System.out.print(elem + &quot; &quot;);</p><p>System.out.println();</p><p>}</p><p>Because for any concrete type A, <code>List&lt;A&gt;</code> is a subtype of List&lt;?&gt;, you can use printList to print a list of any type:</p><pre><code class="language-java">List&lt;Integer&gt; li = Arrays.asList(1, 2, 3);

List&lt;String&gt; ls = Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);

printList(li);

printList(ls);
</code></pre><p><strong>Note:</strong> The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-">Arrays.asList</a> method is used in examples throughout this lesson. This static factory method converts the specified array and returns a fixed-size list.</p><p>It&#x27;s important to note that <code>List&lt;Object&gt;</code> and List&lt;?&gt; are not the same. You can insert an Object, or any subtype of Object, into a <code>List&lt;Object&gt;</code>. But you can only insert null into a List&lt;?&gt;. The<a href="https://docs.oracle.com/javase/tutorial/java/generics/wildcardGuidelines.html">Guidelines for Wildcard Use</a> section has more information on how to determine what kind of wildcard, if any, should be used in a given situation.</p><h2>8.12 Lower Bounded Wildcards</h2><p>The <a href="https://docs.oracle.com/javase/tutorial/java/generics/upperBounded.html">Upper Bounded Wildcards</a> section shows that an upper bounded wildcard restricts the unknown type to be a specific type or a subtype of that type and is represented using the extendskeyword. In a similar way, a <em>lower bounded</em> wildcard restricts the unknown type to be a specific type or a <em>super type</em> of that type.</p><p>A lower bounded wildcard is expressed using the wildcard character (&#x27;?&#x27;), following by the super keyword, followed by its <em>lower bound</em>: &lt;? super A&gt;.</p><p><strong>Note:</strong> You can specify an upper bound for a wildcard, or you can specify a lower bound, but you cannot specify both.</p><p>Say you want to write a method that puts Integer objects into a list. To maximize flexibility, you would like the method to work on <code>List&lt;Integer&gt;</code>, <code>List&lt;Number&gt;</code>, and <code>List&lt;Object&gt;</code> --- anything that can hold Integer values.</p><p>To write the method that works on lists of Integer and the supertypes of Integer, such as Integer, Number, and Object, you would specify List&lt;? super Integer&gt;. The term <code>List&lt;Integer&gt;</code> is more restrictive than List&lt;? super Integer&gt; because the former matches a list of type Integer only, whereas the latter matches a list of any type that is a supertype of Integer.</p><p>The following code adds the numbers 1 through 10 to the end of a list:</p><p>public static void addNumbers(List&lt;? super Integer&gt; list) {</p><p>for (int i = 1; i &lt;= 10; i++) {</p><p>list.add(i);</p><p>}</p><p>}</p><p>The <a href="https://docs.oracle.com/javase/tutorial/java/generics/wildcardGuidelines.html">Guidelines for Wildcard Use</a> section provides guidance on when to use upper bounded wildcards and when to use lower bounded wildcards.</p><h2>8.13 Wildcards and Subtyping</h2><p>As described in <a href="https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html">Generics, Inheritance, and Subtypes</a>, generic classes or interfaces are not related merely because there is a relationship between their types. However, you can use wildcards to create a relationship between generic classes or interfaces.</p><p>Given the following two regular (non-generic) classes:</p><pre><code class="language-java">class A { /\* \... \*/ }

class B extends A { /\* \... \*/ }

It would be reasonable to write the following code:

B b = new B();

A a = b;
</code></pre><p>This example shows that inheritance of regular classes follows this rule of subtyping: class B is a subtype of class A if B extends A. This rule does not apply to generic types:</p><pre><code class="language-java">List&lt;B&gt; lb = new ArrayList&lt;&gt;();

List&lt;A&gt; la = lb; // compile-time error
</code></pre><p>Given that Integer is a subtype of Number, what is the relationship between <code>List&lt;Integer&gt;</code> and <code>List&lt;Number&gt;</code>?</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//85AwAIzALmLBP6TAAAAABJRU5ErkJggg==" alt="diagram showing that the common parent of `List&lt;Number&gt;` and `List&lt;Integer&gt;` is the list of unknown type"/></p><p>The common parent is <code>List&lt;?&gt;</code>.</p><p>Although Integer is a subtype of Number, <code>List&lt;Integer&gt;</code> is not a subtype of <code>List&lt;Number&gt;</code> and, in fact, these two types are not related. The common parent of <code>List&lt;Number&gt;</code> and <code>List&lt;Integer&gt;</code> is <code>List&lt;?&gt;</code>.</p><p>In order to create a relationship between these classes so that the code can access Number&#x27;s methods through <code>List&lt;Integer&gt;</code>&#x27;s elements, use an upper bounded wildcard:</p><pre><code class="language-java">List&lt;? extends Integer&gt; intList = new ArrayList&lt;&gt;();

List&lt;? extends Number&gt; numList = intList; // OK. List&lt;? extends Integer&gt; is a subtype of List&lt;? extends Number&gt;
</code></pre><p>Because Integer is a subtype of Number, and numList is a list of Number objects, a relationship now exists between intList (a list of Integer objects) and numList. The following diagram shows the relationships between several List classes declared with both upper and lower bounded wildcards.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8/AwAI/AL+eMSysAAAAABJRU5ErkJggg==" alt="diagram showing that `List&lt;Integer&gt;` is a subtype of both `List&lt;? extends Integer&gt;` and `List&lt;?super Integer&gt;`. `List&lt;? extends Integer&gt;` is a subtype of `List&lt;? extends Number&gt;` which is a subtype of `List&lt;?&gt;`. `List&lt;Number&gt;` is a subtype of `List&lt;? super Number&gt; and List&gt;? extends Number&gt;`. `List&lt;? super Number&gt;` is a subtype of `List&lt;? super Integer&gt;` which is a subtype of `List&lt;?&gt;`."/></p><p>A hierarchy of several generic List class declarations.</p><p>The <a href="https://docs.oracle.com/javase/tutorial/java/generics/wildcardGuidelines.html">Guidelines for Wildcard Use</a> section has more information about the ramifications of using upper and lower bounded wildcards.</p><h2>8.14 Wildcard Capture and Helper Methods</h2><p>In some cases, the compiler infers the type of a wildcard. For example, a list may be defined as List&lt;?&gt; but, when evaluating an expression, the compiler infers a particular type from the code. This scenario is known as <em>wildcard capture</em>.</p><p>For the most part, you don&#x27;t need to worry about wildcard capture, except when you see an error message that contains the phrase &quot;capture of&quot;.</p><p>The <a href="https://docs.oracle.com/javase/tutorial/java/generics/examples/WildcardError.java">WildcardError</a> example produces a capture error when compiled:</p><pre><code class="language-java">import java.util.List;

public class WildcardError {

void foo(List&lt;?&gt; i) {

i.set(0, i.get(0));

}

}
</code></pre><p>In this example, the compiler processes the i input parameter as being of type Object. When the foo method invokes <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html#set-int-E-">List.set(int, E)</a>, the compiler is not able to confirm the type of object that is being inserted into the list, and an error is produced. When this type of error occurs it typically means that the compiler believes that you are assigning the wrong type to a variable. Generics were added to the Java language for this reason --- to enforce type safety at compile time.</p><p>The WildcardError example generates the following error when compiled by Oracle&#x27;s JDK 7 javac implementation:</p><p>WildcardError.java:6: error: method set in interface <code>List&lt;E&gt;</code> cannot be applied to given types;</p><p>i.set(0, i.get(0));</p><p>\^</p><p>required: int,CAP<!-- -->#<!-- -->1</p><p>found: int,Object</p><p>reason: actual argument Object cannot be converted to CAP<!-- -->#<!-- -->1 by method invocation conversion</p><p>where E is a type-variable:</p><p>E extends Object declared in interface List</p><p>where CAP<!-- -->#<!-- -->1 is a fresh type-variable:</p><p>CAP<!-- -->#<!-- -->1 extends Object from capture of ?</p><p>1 error</p><p>In this example, the code is attempting to perform a safe operation, so how can you work around the compiler error? You can fix it by writing a <em>private helper method</em> which captures the wildcard. In this case, you can work around the problem by creating the private helper method, fooHelper, as shown in <a href="https://docs.oracle.com/javase/tutorial/java/generics/examples/WildcardFixed.java">WildcardFixed</a>:</p><pre><code class="language-java">public class WildcardFixed {

void foo(List&lt;?&gt; i) {

fooHelper(i);

}

// Helper method created so that the wildcard can be captured

// through type inference.

**private &lt;T&gt; void fooHelper(List&lt;T&gt; l) {**

**l.set(0, l.get(0));**

**}**

}
</code></pre><p>Thanks to the helper method, the compiler uses inference to determine that T is CAP<!-- -->#<!-- -->1, the capture variable, in the invocation. The example now compiles successfully.</p><p>By convention, helper methods are generally named <em>originalMethodName</em>Helper.</p><p>Now consider a more complex example, <a href="https://docs.oracle.com/javase/tutorial/java/generics/examples/WildcardErrorBad.java">WildcardErrorBad</a>:</p><pre><code class="language-java">import java.util.List;

public class WildcardErrorBad {

void swapFirst(List&lt;? extends Number&gt; l1, List&lt;? extends Number&gt; l2) {

Number temp = l1.get(0);

l1.set(0, l2.get(0)); // expected a CAP\#1 extends Number,

// got a CAP\#2 extends Number;

// same bound, but different types

l2.set(0, temp); // expected a CAP\#1 extends Number,

// got a Number

}

}
</code></pre><p>In this example, the code is attempting an unsafe operation. For example, consider the following invocation of the swapFirst method:</p><pre><code class="language-java">List&lt;Integer&gt; li = Arrays.asList(1, 2, 3);

List&lt;Double&gt; ld = Arrays.asList(10.10, 20.20, 30.30);

swapFirst(li, ld);
</code></pre><p>While <code>List&lt;Integer&gt;</code> and <code>List&lt;Double&gt;</code> both fulfill the criteria of List&lt;? extends Number&gt;, it is clearly incorrect to take an item from a list of Integer values and attempt to place it into a list of Doublevalues.</p><p>Compiling the code with Oracle&#x27;s JDK javac compiler produces the following error:</p><p>WildcardErrorBad.java:7: error: method set in interface <code>List&lt;E&gt;</code> cannot be applied to given types;</p><p>l1.set(0, l2.get(0)); // expected a CAP<!-- -->#<!-- -->1 extends Number,</p><p>\^</p><p>required: int,CAP<!-- -->#<!-- -->1</p><p>found: int,Number</p><p>reason: actual argument Number cannot be converted to CAP<!-- -->#<!-- -->1 by method invocation conversion</p><p>where E is a type-variable:</p><p>E extends Object declared in interface List</p><p>where CAP<!-- -->#<!-- -->1 is a fresh type-variable:</p><p>CAP<!-- -->#<!-- -->1 extends Number from capture of ? extends Number</p><p>WildcardErrorBad.java:10: error: method set in interface <code>List&lt;E&gt;</code> cannot be applied to given types;</p><p>l2.set(0, temp); // expected a CAP<!-- -->#<!-- -->1 extends Number,</p><p>\^</p><p>required: int,CAP<!-- -->#<!-- -->1</p><p>found: int,Number</p><p>reason: actual argument Number cannot be converted to CAP<!-- -->#<!-- -->1 by method invocation conversion</p><p>where E is a type-variable:</p><p>E extends Object declared in interface List</p><p>where CAP<!-- -->#<!-- -->1 is a fresh type-variable:</p><p>CAP<!-- -->#<!-- -->1 extends Number from capture of ? extends Number</p><p>WildcardErrorBad.java:15: error: method set in interface <code>List&lt;E&gt;</code> cannot be applied to given types;</p><p>i.set(0, i.get(0));</p><p>\^</p><p>required: int,CAP<!-- -->#<!-- -->1</p><p>found: int,Object</p><p>reason: actual argument Object cannot be converted to CAP<!-- -->#<!-- -->1 by method invocation conversion</p><p>where E is a type-variable:</p><p>E extends Object declared in interface List</p><p>where CAP<!-- -->#<!-- -->1 is a fresh type-variable:</p><p>CAP<!-- -->#<!-- -->1 extends Object from capture of ?</p><p>3 errors</p><p>There is no helper method to work around the problem, because the code is fundamentally wrong.</p><h2>8.15 Guidelines for Wildcard Use</h2><p>One of the more confusing aspects when learning to program with generics is determining when to use an upper bounded wildcard and when to use a lower bounded wildcard. This page provides some guidelines to follow when designing your code.</p><p>For purposes of this discussion, it is helpful to think of variables as providing one of two functions:</p><p><strong>An &quot;In&quot; Variable</strong></p><p>An &quot;in&quot; variable serves up data to the code. Imagine a copy method with two arguments: copy(src, dest). The src argument provides the data to be copied, so it is the &quot;in&quot; parameter.</p><p><strong>An &quot;Out&quot; Variable</strong></p><p>An &quot;out&quot; variable holds data for use elsewhere. In the copy example, copy(src, dest), the dest argument accepts data, so it is the &quot;out&quot; parameter.</p><p>Of course, some variables are used both for &quot;in&quot; and &quot;out&quot; purposes --- this scenario is also addressed in the guidelines.</p><p>You can use the &quot;in&quot; and &quot;out&quot; principle when deciding whether to use a wildcard and what type of wildcard is appropriate. The following list provides the guidelines to follow:</p><p><strong>Wildcard Guidelines:</strong> </p><ul><li>An &quot;in&quot; variable is defined with an upper bounded wildcard, using the extends keyword.</li><li>An &quot;out&quot; variable is defined with a lower bounded wildcard, using the super keyword.</li><li>In the case where the &quot;in&quot; variable can be accessed using methods defined in the Object class, use an unbounded wildcard.</li><li>In the case where the code needs to access the variable as both an &quot;in&quot; and an &quot;out&quot; variable, do not use a wildcard.</li></ul><p>These guidelines do not apply to a method&#x27;s return type. Using a wildcard as a return type should be avoided because it forces programmers using the code to deal with wildcards.</p><p>A list defined by List&lt;? extends <!-- -->.<!-- -->..&gt; can be informally thought of as read-only, but that is not a strict guarantee. Suppose you have the following two classes:</p><pre><code class="language-java">class NaturalNumber {

private int i;

public NaturalNumber(int i) { this.i = i; }

// \...

}

class EvenNumber extends NaturalNumber {

public EvenNumber(int i) { super(i); }

// \...

}
</code></pre><p>Consider the following code:</p><pre><code class="language-java">List&lt;EvenNumber&gt; le = new ArrayList&lt;&gt;();

List&lt;? extends NaturalNumber&gt; ln = le;

ln.add(new NaturalNumber(35)); // compile-time error
</code></pre><p>Because <code>List&lt;EvenNumber&gt;</code> is a subtype of <code>List&lt;? extends NaturalNumber&gt;</code>, you can assign le to ln. But you cannot use ln to add a natural number to a list of even numbers. The following operations on the list are possible:</p><ul><li>You can add null.</li><li>You can invoke clear.</li><li>You can get the iterator and invoke remove.</li><li>You can capture the wildcard and write elements that you&#x27;ve read from the list.</li></ul><p>You can see that the list defined by List&lt;? extends NaturalNumber&gt; is not read-only in the strictest sense of the word, but you might think of it that way because you cannot store a new element or change an existing element in the list.</p><h2>8.16 Type Erasure</h2><p>Generics were introduced to the Java language to provide tighter type checks at compile time and to support generic programming. To implement generics, the Java compiler applies type erasure to:</p><ul><li>Replace all type parameters in generic types with their bounds or Object if the type parameters are unbounded. The produced bytecode, therefore, contains only ordinary classes, interfaces, and methods.</li><li>Insert type casts if necessary to preserve type safety.</li><li>Generate bridge methods to preserve polymorphism in extended generic types.</li></ul><p>Type erasure ensures that no new classes are created for parameterized types; consequently, generics incur no runtime overhead.</p><h2>8.17 Erasure of Generic Types</h2><p>During the type erasure process, the Java compiler erases all type parameters and replaces each with its first bound if the type parameter is bounded, or Object if the type parameter is unbounded.</p><p>Consider the following generic class that represents a node in a singly linked list:</p><pre><code class="language-java">public class Node&lt;T&gt; {

private T data;

private Node&lt;T&gt; next;

public Node(T data, Node&lt;T&gt; next) {

this.data = data;

this.next = next;

}

public T getData() { return data; }

// \...

}
</code></pre><p>Because the type parameter T is unbounded, the Java compiler replaces it with Object:</p><pre><code class="language-java">public class Node {

private Object data;

private Node next;

public Node(Object data, Node next) {

this.data = data;

this.next = next;

}

public Object getData() { return data; }

// \...

}
</code></pre><p>In the following example, the generic Node class uses a bounded type parameter:</p><pre><code class="language-java">public class Node&lt;T extends Comparable&lt;T&gt;&gt; {

private T data;

private Node&lt;T&gt; next;

public Node(T data, Node&lt;T&gt; next) {

this.data = data;

this.next = next;

}

public T getData() { return data; }

// \...

}
</code></pre><p>The Java compiler replaces the bounded type parameter T with the first bound class, Comparable:</p><pre><code class="language-java">public class Node {

private Comparable data;

private Node next;

public Node(Comparable data, Node next) {

this.data = data;

this.next = next;

}

public Comparable getData() { return data; }

// \...

}
</code></pre><h2>8.18 Erasure of Generic Methods</h2><p>The Java compiler also erases type parameters in generic method arguments. Consider the following generic method:</p><pre><code class="language-java">// Counts the number of occurrences of elem in anArray.

//

public static &lt;T&gt; int count(T[] anArray, T elem) {

int cnt = 0;

for (T e : anArray)

if (e.equals(elem))

++cnt;

return cnt;

}
</code></pre><p>Because T is unbounded, the Java compiler replaces it with Object:</p><pre><code class="language-java">public static int count(Object[] anArray, Object elem) {

int cnt = 0;

for (Object e : anArray)

if (e.equals(elem))

++cnt;

return cnt;

}
</code></pre><p>Suppose the following classes are defined:</p><pre><code class="language-java">class Shape { /\* \... \*/ }

class Circle extends Shape { /\* \... \*/ }

class Rectangle extends Shape { /\* \... \*/ }
</code></pre><p>You can write a generic method to draw different shapes:</p><pre><code class="language-java">public static &lt;T extends Shape&gt; void draw(T shape) { /\* \... \*/ }
</code></pre><p>The Java compiler replaces T with Shape:</p><pre><code class="language-java">public static void draw(Shape shape) { /\* \... \*/ }
</code></pre><h2>8.19 Effects of Type Erasure and Bridge Methods</h2><p>Sometimes type erasure causes a situation that you may not have anticipated. The following example shows how this can occur. The example (described in <a href="https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html#bridgeMethods">Bridge Methods</a>) shows how a compiler sometimes creates a synthetic method, called a bridge method, as part of the type erasure process.</p><p>Given the following two classes:</p><pre><code class="language-java">public class Node&lt;T&gt; {

public T data;

public Node(T data) { this.data = data; }

public void setData(T data) {

System.out.println(&quot;Node.setData&quot;);

this.data = data;

}

}

public class MyNode extends Node&lt;Integer&gt; {

public MyNode(Integer data) { super(data); }

public void setData(Integer data) {

System.out.println(&quot;MyNode.setData&quot;);

super.setData(data);

}

}
</code></pre><p>Consider the following code:</p><pre><code class="language-java">MyNode mn = new MyNode(5);

Node n = mn; // A raw type - compiler throws an unchecked warning

n.setData(&quot;Hello&quot;);

Integer x = mn.data; // Causes a ClassCastException to be thrown.

After type erasure, this code becomes:

MyNode mn = new MyNode(5);

Node n = (MyNode)mn; // A raw type - compiler throws an unchecked warning

n.setData(&quot;Hello&quot;);

Integer x = (String)mn.data; // Causes a ClassCastException to be thrown.
</code></pre><p>Here is what happens as the code is executed:</p><ul><li>n.setData(&quot;Hello&quot;); causes the method setData(Object) to be executed on the object of class MyNode. (The MyNode class inherited setData(Object) from Node.)</li><li>In the body of setData(Object), the data field of the object referenced by n is assigned to a String.</li><li>The data field of that same object, referenced via mn, can be accessed and is expected to be an integer (since mn is a MyNode which is a <code>Node&lt;Integer&gt;</code>.</li><li>Trying to assign a String to an Integer causes a ClassCastException from a cast inserted at the assignment by a Java compiler.</li></ul><h3>8.19.1 Bridge Methods</h3><p>When compiling a class or interface that extends a parameterized class or implements a parameterized interface, the compiler may need to create a synthetic method, called a <em>bridge method</em>, as part of the type erasure process. You normally don&#x27;t need to worry about bridge methods, but you might be puzzled if one appears in a stack trace.</p><p>After type erasure, the Node and MyNode classes become:</p><pre><code class="language-java">public class Node {

public Object data;

public Node(Object data) { this.data = data; }

public void setData(Object data) {

System.out.println(&quot;Node.setData&quot;);

this.data = data;

}

}

public class MyNode extends Node {

public MyNode(Integer data) { super(data); }

public void setData(Integer data) {

System.out.println(&quot;MyNode.setData&quot;);

super.setData(data);

}

}
</code></pre><p>After type erasure, the method signatures do not match. The Node method becomes setData(Object) and the MyNode method becomes setData(Integer). Therefore, the MyNode setData method does not override the Node setData method.</p><p>To solve this problem and preserve the <a href="https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html">polymorphism</a> of generic types after type erasure, a Java compiler generates a bridge method to ensure that subtyping works as expected. For the MyNodeclass, the compiler generates the following bridge method for setData:</p><pre><code class="language-java">class MyNode extends Node {

**// Bridge method generated by the compiler**

**//**

**public void setData(Object data) {**

**setData((Integer) data);**

**}**

public void setData(Integer data) {

System.out.println(&quot;MyNode.setData&quot;);

super.setData(data);

}

// \...

}
</code></pre><p>As you can see, the bridge method, which has the same method signature as the Node class&#x27;s setData method after type erasure, delegates to the original setData method.</p><h2>8.20 Non-Reifiable Types</h2><p>The section <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">Type Erasure</a> discusses the process where the compiler removes information related to type parameters and type arguments. Type erasure has consequences related to variable arguments (also known as <em>varargs</em> ) methods whose varargs formal parameter has a non-reifiable type. See the section <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html#varargs">Arbitrary Number of Arguments</a> in <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html">Passing Information to a Method or a Constructor</a> for more information about varargs methods.</p><p>This page covers the following topics:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#non-reifiable-types">Non-Reifiable Types</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#heap_pollution">Heap Pollution</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#vulnerabilities">Potential Vulnerabilities of Varargs Methods with Non-Reifiable Formal Parameters</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#suppressing">Preventing Warnings from Varargs Methods with Non-Reifiable Formal Parameters</a></li></ul><h3>8.20.1 Non-Reifiable Types</h3><p>A <em>reifiable</em> type is a type whose type information is fully available at runtime. This includes primitives, non-generic types, raw types, and invocations of unbound wildcards.</p><p><em>Non-reifiable types</em> are types where information has been removed at compile-time by type erasure --- invocations of generic types that are not defined as unbounded wildcards. A non-reifiable type does not have all of its information available at runtime. Examples of non-reifiable types are <code>List&lt;String&gt;</code> and <code>List&lt;Number&gt;</code>; the JVM cannot tell the difference between these types at runtime. As shown in <a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html">Restrictions on Generics</a>, there are certain situations where non-reifiable types cannot be used: in an instanceof expression, for example, or as an element in an array.</p><h3>8.20.2 Heap Pollution</h3><p><em>Heap pollution</em> occurs when a variable of a parameterized type refers to an object that is not of that parameterized type. This situation occurs if the program performed some operation that gives rise to an unchecked warning at compile-time. An <em>unchecked warning</em> is generated if, either at compile-time (within the limits of the compile-time type checking rules) or at runtime, the correctness of an operation involving a parameterized type (for example, a cast or method call) cannot be verified. For example, heap pollution occurs when mixing raw types and parameterized types, or when performing unchecked casts.</p><p>In normal situations, when all code is compiled at the same time, the compiler issues an unchecked warning to draw your attention to potential heap pollution. If you compile sections of your code separately, it is difficult to detect the potential risk of heap pollution. If you ensure that your code compiles without warnings, then no heap pollution can occur.</p><h3>8.20.3 Potential Vulnerabilities of Varargs Methods with Non-Reifiable Formal Parameters</h3><p>Generic methods that include vararg input parameters can cause heap pollution.</p><p>Consider the following ArrayBuilder class:</p><pre><code class="language-java">public class ArrayBuilder {

public static &lt;T&gt; void addToList (List&lt;T&gt; listArg, T\... elements) {

for (T x : elements) {

listArg.add(x);

}

}

public static void faultyMethod(List&lt;String&gt;\... l) {

Object[] objectArray = l; // Valid

objectArray[0] = Arrays.asList(42);

String s = l[0].get(0); // ClassCastException thrown here

}

}

The following example, HeapPollutionExample uses the ArrayBuiler class:

public class HeapPollutionExample {

public static void main(String[] args) {

List&lt;String&gt; stringListA = new ArrayList&lt;String&gt;();

List&lt;String&gt; stringListB = new ArrayList&lt;String&gt;();

ArrayBuilder.addToList(stringListA, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;);

ArrayBuilder.addToList(stringListB, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;);

List&lt;List&lt;String&gt;&gt; listOfStringLists =

new ArrayList&lt;List&lt;String&gt;&gt;();

ArrayBuilder.addToList(listOfStringLists,

stringListA, stringListB);

ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;));

}

}
</code></pre><p>When compiled, the following warning is produced by the definition of the ArrayBuilder.addToList method:</p><p>warning: <!-- -->[varargs]<!-- --> Possible heap pollution from parameterized vararg type T</p><p>When the compiler encounters a varargs method, it translates the varargs formal parameter into an array. However, the Java programming language does not permit the creation of arrays of parameterized types. In the method ArrayBuilder.addToList, the compiler translates the varargs formal parameter T<!-- -->.<!-- -->.. elements to the formal parameter T[] elements, an array. However, because of type erasure, the compiler converts the varargs formal parameter to Object[] elements. Consequently, there is a possibility of heap pollution.</p><p>The following statement assigns the varargs formal parameter l to the Object array objectArgs:</p><p>Object[] objectArray = l;</p><p>This statement can potentially introduce heap pollution. A value that does match the parameterized type of the varargs formal parameter l can be assigned to the variable objectArray, and thus can be assigned to l. However, the compiler does not generate an unchecked warning at this statement. The compiler has already generated a warning when it translated the varargs formal parameter <code>List&lt;String&gt;</code>.<!-- -->.. l to the formal parameter List[] l. This statement is valid; the variable l has the type List[], which is a subtype of Object[].</p><p>Consequently, the compiler does not issue a warning or error if you assign a List object of any type to any array component of the objectArray array as shown by this statement:</p><p>objectArray<!-- -->[0]<!-- --> = Arrays.asList(42);</p><p>This statement assigns to the first array component of the objectArray array with a List object that contains one object of type Integer.</p><p>Suppose you invoke ArrayBuilder.faultyMethod with the following statement:</p><p>ArrayBuilder.faultyMethod(Arrays.asList(&quot;Hello!&quot;), Arrays.asList(&quot;World!&quot;));</p><p>At runtime, the JVM throws a ClassCastException at the following statement:</p><p>// ClassCastException thrown here</p><p>String s = l<!-- -->[0]<!-- -->.get(0);</p><p>The object stored in the first array component of the variable l has the type <code>List&lt;Integer&gt;</code>, but this statement is expecting an object of type <code>List&lt;String&gt;</code>.</p><h3>8.20.4 Prevent Warnings from Varargs Methods with Non-Reifiable Formal Parameters</h3><p>If you declare a varargs method that has parameters of a parameterized type, and you ensure that the body of the method does not throw a ClassCastException or other similar exception due to improper handling of the varargs formal parameter, you can prevent the warning that the compiler generates for these kinds of varargs methods by adding the following annotation to static and non-constructor method declarations:</p><p>\@SafeVarargs</p><p>The \@SafeVarargs annotation is a documented part of the method&#x27;s contract; this annotation asserts that the implementation of the method will not improperly handle the varargs formal parameter.</p><p>It is also possible, though less desirable, to suppress such warnings by adding the following to the method declaration:</p><p>\@SuppressWarnings({&quot;unchecked&quot;, &quot;varargs&quot;})</p><p>However, this approach does not suppress warnings generated from the method&#x27;s call site. If you are unfamiliar with the \@SuppressWarnings syntax, see <a href="https://docs.oracle.com/javase/tutorial/java/annotations/index.html">Annotations</a>.</p><h2>8.21 Restrictions on Generics</h2><p>To use Java generics effectively, you must consider the following restrictions:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#instantiate">Cannot Instantiate Generic Types with Primitive Types</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createObjects">Cannot Create Instances of Type Parameters</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createStatic">Cannot Declare Static Fields Whose Types are Type Parameters</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotCast">Cannot Use Casts or instanceof With Parameterized Types</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createArrays">Cannot Create Arrays of Parameterized Types</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotCatch">Cannot Create, Catch, or Throw Objects of Parameterized Types</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotOverload">Cannot Overload a Method Where the Formal Parameter Types of Each Overload Erase to the Same Raw Type</a></li></ul><h3>8.21.1 Cannot Instantiate Generic Types with Primitive Types</h3><p>Consider the following parameterized type:</p><pre><code class="language-java">class Pair&lt;K, V&gt; {

private K key;

private V value;

public Pair(K key, V value) {

this.key = key;

this.value = value;

}

// \...

}
</code></pre><p>When creating a Pair object, you cannot substitute a primitive type for the type parameter K or V:</p><pre><code class="language-java">Pair&lt;**int, char**&gt; p = new Pair&lt;&gt;(8, &#x27;a&#x27;); // compile-time error
</code></pre><p>You can substitute only non-primitive types for the type parameters K and V:</p><pre><code class="language-java">Pair&lt;**Integer, Character**&gt; p = new Pair&lt;&gt;(8, &#x27;a&#x27;);
</code></pre><p>Note that the Java compiler autoboxes 8 to Integer.valueOf(8) and &#x27;a&#x27; to Character(&#x27;a&#x27;):</p><pre><code class="language-java">Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(Integer.valueOf(8), new Character(&#x27;a&#x27;));
</code></pre><p>For more information on autoboxing, see <a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">Autoboxing and Unboxing</a> in the <a href="https://docs.oracle.com/javase/tutorial/java/data/index.html">Numbers and Strings</a> lesson.</p><h3>8.21.2 Cannot Create Instances of Type Parameters</h3><p>You cannot create an instance of a type parameter. For example, the following code causes a compile-time error:</p><pre><code class="language-java">public static &lt;E&gt; void append(List&lt;E&gt; list) {

E elem = new E(); // compile-time error

list.add(elem);

}
</code></pre><p>As a workaround, you can create an object of a type parameter through reflection:</p><pre><code class="language-java">public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception {

E elem = cls.newInstance(); // OK

list.add(elem);

}
</code></pre><p>You can invoke the append method as follows:</p><pre><code class="language-java">List&lt;String&gt; ls = new ArrayList&lt;&gt;();

append(ls, String.class);
</code></pre><h3>8.21.3 Cannot Declare Static Fields Whose Types are Type Parameters</h3><p>A class&#x27;s static field is a class-level variable shared by all non-static objects of the class. Hence, static fields of type parameters are not allowed. Consider the following class:</p><pre><code class="language-java">public class MobileDevice&lt;T&gt; {

private static T os;

// \...

}
</code></pre><p>If static fields of type parameters were allowed, then the following code would be confused:</p><pre><code class="language-java">MobileDevice&lt;Smartphone&gt; phone = new MobileDevice&lt;&gt;();

MobileDevice&lt;Pager&gt; pager = new MobileDevice&lt;&gt;();

MobileDevice&lt;TabletPC&gt; pc = new MobileDevice&lt;&gt;();
</code></pre><p>Because the static field os is shared by phone, pager, and pc, what is the actual type of os? It cannot be Smartphone, Pager, and TabletPC at the same time. You cannot, therefore, create static fields of type parameters.</p><h3>8.21.4 Cannot Use Casts or instanceof with Parameterized Types</h3><p>Because the Java compiler erases all type parameters in generic code, you cannot verify which parameterized type for a generic type is being used at runtime:</p><pre><code class="language-java">public static &lt;E&gt; void rtti(List&lt;E&gt; list) {

if (list instanceof ArrayList&lt;Integer&gt;) { // compile-time error

// \...

}

}
</code></pre><p>The set of parameterized types passed to the rtti method is:</p><pre><code class="language-java">S = { ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt; LinkedList&lt;Character&gt;, \... }
</code></pre><p>The runtime does not keep track of type parameters, so it cannot tell the difference between an <code>ArrayList&lt;Integer&gt;</code> and an <code>ArrayList&lt;String&gt;</code>. The most you can do is to use an unbounded wildcard to verify that the list is an ArrayList:</p><pre><code class="language-java">public static void rtti(List&lt;?&gt; list) {

if (list instanceof ArrayList&lt;?&gt;) { // OK; instanceof requires a reifiable type

// \...

}

}
</code></pre><p>Typically, you cannot cast to a parameterized type unless it is parameterized by unbounded wildcards. For example:</p><pre><code class="language-java">List&lt;Integer&gt; li = new ArrayList&lt;&gt;();

List&lt;Number&gt; ln = (List&lt;Number&gt;) li; // compile-time error
</code></pre><p>However, in some cases the compiler knows that a type parameter is always valid and allows the cast. For example:</p><pre><code class="language-java">List&lt;String&gt; l1 = \...;

ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1; // OK
</code></pre><h3>8.21.5 Cannot Create Arrays of Parameterized Types</h3><p>You cannot create arrays of parameterized types. For example, the following code does not compile:</p><pre><code class="language-java">List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2]; // compile-time error
</code></pre><p>The following code illustrates what happens when different types are inserted into an array:</p><pre><code class="language-java">Object[] strings = new String[2];

strings[0] = &quot;hi&quot;; // OK

strings[1] = 100; // An ArrayStoreException is thrown.
</code></pre><p>If you try the same thing with a generic list, there would be a problem:</p><pre><code class="language-java">Object[] stringLists = new List&lt;String&gt;[]; // compiler error, but pretend it&#x27;s allowed

stringLists[0] = new ArrayList&lt;String&gt;(); // OK

stringLists[1] = new ArrayList&lt;Integer&gt;(); // An ArrayStoreException should be thrown,

// but the runtime can&#x27;t detect it.
</code></pre><p>If arrays of parameterized lists were allowed, the previous code would fail to throw the desired ArrayStoreException.</p><h3>8.21.6 Cannot Create, Catch, or Throw Objects of Parameterized Types</h3><p>A generic class cannot extend the Throwable class directly or indirectly. For example, the following classes will not compile:</p><pre><code class="language-java">// Extends Throwable indirectly

class MathException&lt;T&gt; extends Exception { /\* \... \*/ } // compile-time error

// Extends Throwable directly

class QueueFullException&lt;T&gt; extends Throwable { /\* \... \*/ // compile-time error
</code></pre><p>A method cannot catch an instance of a type parameter:</p><pre><code class="language-java">public static &lt;T extends Exception, J&gt; void execute(List&lt;J&gt; jobs) {

try {

for (J job : jobs)

// \...

} catch (T e) { // compile-time error

// \...

}

}
</code></pre><p>You can, however, use a type parameter in a throws clause:</p><pre><code class="language-java">class Parser&lt;T extends Exception&gt; {

public void parse(File file) throws T { // OK

// \...

}

}
</code></pre><h3>8.21.7 Cannot Overload a Method Where the Formal Parameter Types of Each Overload Erase to the Same Raw Type</h3><p>A class cannot have two overloaded methods that will have the same signature after type erasure.</p><pre><code class="language-java">public class Example {

public void print(Set&lt;String&gt; strSet) { }

public void print(Set&lt;Integer&gt; intSet) { }

}
</code></pre><p>The overloads would all share the same classfile representation and will generate a compile-time error.</p><h1>9 Packages</h1><p>This lesson explains how to bundle classes and interfaces into packages, how to use classes that are in packages, and how to arrange your file system so that the compiler can find your source files.</p><h2>9.1 Creating and Using Packages</h2><p>To make types easier to find and use, to avoid naming conflicts, and to control access, programmers bundle groups of related types into packages. A <em>package</em> is a grouping of related types providing access protection and name space management. Note that <em>types</em> refers to classes, interfaces, enumerations, and annotation types. Enumerations and annotation types are special kinds of classes and interfaces, respectively, so <em>types</em> are often referred to in this lesson simply as <em>classes and interfaces</em>.</p><p>The types that are part of the Java platform are members of various packages that bundle classes by function: fundamental classes are in java.lang, classes for reading and writing (input and output) are in java.io, and so on. You can put your types in packages too.</p><p>Suppose you write a group of classes that represent graphic objects, such as circles, rectangles, lines, and points. You also write an interface, Draggable, that classes implement if they can be dragged with the mouse.</p><pre><code class="language-java">//*in the Draggable.java file*

public interface Draggable {

\...

}

//*in the Graphic.java file*

public abstract class Graphic {

\...

}

//*in the Circle.java file*

public class Circle extends Graphic

implements Draggable {

. . .

}

//*in the Rectangle.java file*

public class Rectangle extends Graphic

implements Draggable {

. . .

}

//*in the Point.java file*

public class Point extends Graphic

implements Draggable {

. . .

}

//*in the Line.java file*

public class Line extends Graphic

implements Draggable {

. . .

}
</code></pre><p>You should bundle these classes and the interface in a package for several reasons, including the following:</p><ul><li>You and other programmers can easily determine that these types are related.</li><li>You and other programmers know where to find types that can provide graphics-related functions.</li><li>The names of your types won&#x27;t conflict with the type names in other packages because the package creates a new namespace.</li><li>You can allow types within the package to have unrestricted access to one another yet still restrict access for types outside the package.</li></ul><h2>9.2 Creating a Package</h2><p>To create a package, you choose a name for the package (naming conventions are discussed in the next section) and put a package statement with that name at the top of <em>every source file</em> that contains the types (classes, interfaces, enumerations, and annotation types) that you want to include in the package.</p><p>The package statement (for example, package graphics;) must be the first line in the source file. There can be only one package statement in each source file, and it applies to all types in the file.</p><p><strong>Note:</strong> If you put multiple types in a single source file, only one can be public, and it must have the same name as the source file. For example, you can define public class Circle in the file Circle.java, define public interface Draggable in the file Draggable.java, define public enum Day in the file Day.java, and so forth.</p><p>You can include non-public types in the same file as a public type (this is strongly discouraged, unless the non-public types are small and closely related to the public type), but only the public type will be accessible from outside of the package. All the top-level, non-public types will be <em>package private</em>.</p><p>If you put the graphics interface and classes listed in the preceding section in a package called graphics, you would need six source files, like this:</p><pre><code class="language-java">//*in the Draggable.java file*

package graphics;

public interface Draggable {

. . .

}

//*in the Graphic.java file*

package graphics;

public abstract class Graphic {

. . .

}

//*in the Circle.java file*

package graphics;

public class Circle extends Graphic

implements Draggable {

. . .

}

//*in the Rectangle.java file*

package graphics;

public class Rectangle extends Graphic

implements Draggable {

. . .

}

//*in the Point.java file*

package graphics;

public class Point extends Graphic

implements Draggable {

. . .

}

//*in the Line.java file*

package graphics;

public class Line extends Graphic

implements Draggable {

. . .

}
</code></pre><p>If you do not use a package statement, your type ends up in an unnamed package. Generally speaking, an unnamed package is only for small or temporary applications or when you are just beginning the development process. Otherwise, classes and interfaces belong in named packages.</p><h2>9.3 Naming a Package</h2><p>With programmers worldwide writing classes and interfaces using the Java programming language, it is likely that many programmers will use the same name for different types. In fact, the previous example does just that: It defines a Rectangle class when there is already a Rectangle class in the java.awt package. Still, the compiler allows both classes to have the same name if they are in different packages. The fully qualified name of each Rectangle class includes the package name. That is, the fully qualified name of the Rectangle class in the graphicspackage is graphics.Rectangle, and the fully qualified name of the Rectangle class in the java.awt package is java.awt.Rectangle.</p><p>This works well unless two independent programmers use the same name for their packages. What prevents this problem? Convention.</p><h3>9.3.1 Naming Conventions</h3><p>Package names are written in all lower case to avoid conflict with the names of classes or interfaces.</p><p>Companies use their reversed Internet domain name to begin their package names---for example, com.example.mypackage for a package named mypackage created by a programmer at example.com.</p><p>Name collisions that occur within a single company need to be handled by convention within that company, perhaps by including the region or the project name after the company name (for example, com.example.region.mypackage).</p><p>Packages in the Java language itself begin with java. or javax.</p><p>In some cases, the internet domain name may not be a valid package name. This can occur if the domain name contains a hyphen or other special character, if the package name begins with a digit or other character that is illegal to use as the beginning of a Java name, or if the package name contains a reserved Java keyword, such as &quot;int&quot;. In this event, the suggested convention is to add an underscore. For example:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Legalizing Package Names</strong></td><td></td></tr><tr><td><strong>Domain Name</strong></td><td><strong>Package Name Prefix</strong></td></tr><tr><td>hyphenated-name.example.org</td><td>org.example.hyphenated_name</td></tr><tr><td>example.int</td><td>int<!-- -->_<!-- -->.example</td></tr><tr><td>123name.example.com</td><td>com.example.<!-- -->_<!-- -->123name</td></tr></tbody></table><h2>9.4 Using Package Members</h2><p>The types that comprise a package are known as the <em>package members</em>.</p><p>To use a public package member from outside its package, you must do one of the following:</p><ul><li>Refer to the member by its fully qualified name</li><li>Import the package member</li><li>Import the member&#x27;s entire package</li></ul><p>Each is appropriate for different situations, as explained in the sections that follow.</p><h3>9.4.1 Referring to a Package Member by Its Qualified Name</h3><p>So far, most of the examples in this tutorial have referred to types by their simple names, such as Rectangle and StackOfInts. You can use a package member&#x27;s simple name if the code you are writing is in the same package as that member or if that member has been imported.</p><p>However, if you are trying to use a member from a different package and that package has not been imported, you must use the member&#x27;s fully qualified name, which includes the package name. Here is the fully qualified name for the Rectangle class declared in the graphics package in the previous example.</p><pre><code class="language-java">graphics.Rectangle
</code></pre><p>You could use this qualified name to create an instance of graphics.Rectangle:</p><pre><code class="language-java">graphics.Rectangle myRect = new graphics.Rectangle();
</code></pre><p>Qualified names are all right for infrequent use. When a name is used repetitively, however, typing the name repeatedly becomes tedious and the code becomes difficult to read. As an alternative, you can <em>import</em> the member or its package and then use its simple name.</p><h3>9.4.2 Importing a Package Member</h3><p>To import a specific member into the current file, put an import statement at the beginning of the file before any type definitions but after the package statement, if there is one. Here&#x27;s how you would import the Rectangle class from the graphics package created in the previous section.</p><pre><code class="language-java">import graphics.Rectangle;
</code></pre><p>Now you can refer to the Rectangle class by its simple name.</p><pre><code class="language-java">Rectangle myRectangle = new Rectangle();
</code></pre><p>This approach works well if you use just a few members from the graphics package. But if you use many types from a package, you should import the entire package.</p><h3>9.4.3 Importing an Entire Package</h3><p>To import all the types contained in a particular package, use the import statement with the asterisk (<!-- -->*<!-- -->) wildcard character.</p><pre><code class="language-java">import graphics.*;
</code></pre><p>Now you can refer to any class or interface in the graphics package by its simple name.</p><pre><code class="language-java">Circle myCircle = new Circle();

Rectangle myRectangle = new Rectangle();
</code></pre><p>The asterisk in the import statement can be used only to specify all the classes within a package, as shown here. It cannot be used to match a subset of the classes in a package. For example, the following does not match all the classes in the graphics package that begin with A.</p><pre><code class="language-java">// *does not work*
import graphics.A*;
</code></pre><p>Instead, it generates a compiler error. With the import statement, you generally import only a single package member or an entire package.</p><p><strong>Note:</strong> Another, less common form of import allows you to import the public nested classes of an enclosing class. For example, if the graphics.Rectangle class contained useful nested classes, such as Rectangle.DoubleWide and Rectangle.Square, you could import Rectangle and its nested classes by using the following <em>two</em> statements.</p><pre><code class="language-java">import graphics.Rectangle;

import graphics.Rectangle.*;
</code></pre><p>Be aware that the second import statement will <em>not</em> import Rectangle.
Another less common form of import, the <em>static import statement</em>, will be discussed at the end of this section.</p><p>For convenience, the Java compiler automatically imports two entire packages for each source file: (1) the java.lang package and (2) the current package (the package for the current file).</p><h3>9.4.4 Apparent Hierarchies of Packages</h3><p>At first, packages appear to be hierarchical, but they are not. For example, the Java API includes a java.awt package, a java.awt.color package, a java.awt.font package, and many others that begin with java.awt. However, the java.awt.color package, the java.awt.font package, and other java.awt.xxxx packages are <em>not included</em> in the java.awt package. The prefix java.awt (the Java Abstract Window Toolkit) is used for a number of related packages to make the relationship evident, but not to show inclusion.</p><p>Importing java.awt.<em> imports all of the types in the java.awt package, but it </em>does not import* java.awt.color, java.awt.font, or any other java.awt.xxxx packages. If you plan to use the classes and other types in java.awt.color as well as those in java.awt, you must import both packages with all their files:</p><pre><code class="language-java">import java.awt.*;

import java.awt.color.*;
</code></pre><h3>9.4.5 Name Ambiguities</h3><p>If a member in one package shares its name with a member in another package and both packages are imported, you must refer to each member by its qualified name. For example, the graphics package defined a class named Rectangle. The java.awt package also contains a Rectangle class. If both graphics and java.awt have been imported, the following is ambiguous.</p><pre><code class="language-java">Rectangle rect;
</code></pre><p>In such a situation, you have to use the member&#x27;s fully qualified name to indicate exactly which Rectangle class you want. For example,</p><pre><code class="language-java">graphics.Rectangle rect;
</code></pre><h3>9.4.6 The Static Import Statement</h3><p>There are situations where you need frequent access to static final fields (constants) and static methods from one or two classes. Prefixing the name of these classes over and over can result in cluttered code. The <em>static import</em> statement gives you a way to import the constants and static methods that you want to use so that you do not need to prefix the name of their class.</p><p>The java.lang.Math class defines the PI constant and many static methods, including methods for calculating sines, cosines, tangents, square roots, maxima, minima, exponents, and many more. For example,</p><pre><code class="language-java">public static final double PI = 3.141592653589793;
public static double cos(double a)
{
\...
}
</code></pre><p>Ordinarily, to use these objects from another class, you prefix the class name, as follows.</p><pre><code class="language-java">double r = Math.cos(Math.PI \* theta);
</code></pre><p>You can use the static import statement to import the static members of java.lang.Math so that you don&#x27;t need to prefix the class name, Math. The static members of Math can be imported either individually:</p><pre><code class="language-java">import static java.lang.Math.PI;
</code></pre><p>or as a group:</p><pre><code class="language-java">import static java.lang.Math.*;
</code></pre><p>Once they have been imported, the static members can be used without qualification. For example, the previous code snippet would become:</p><pre><code class="language-java">double r = cos(PI \* theta);
</code></pre><p>Obviously, you can write your own classes that contain constants and static methods that you use frequently, and then use the static import statement. For example,</p><pre><code class="language-java">import static mypackage.MyConstants.*;
</code></pre><p><strong>Note:</strong> Use static import very sparingly. Overusing static import can result in code that is difficult to read and maintain, because readers of the code won&#x27;t know which class defines a particular static object. Used properly, static import makes code more readable by removing class name repetition.</p><h2>9.5 Managing Source and Class Files</h2><p>Many implementations of the Java platform rely on hierarchical file systems to manage source and class files, although <em>The Java Language Specification</em> does not require this. The strategy is as follows.</p><p>Put the source code for a class, interface, enumeration, or annotation type in a text file whose name is the simple name of the type and whose extension is .java. For example:</p><pre><code class="language-java">//in the Rectangle.java file

package graphics;

public class Rectangle {

\...

}
</code></pre><p>Then, put the source file in a directory whose name reflects the name of the package to which the type belongs:</p><pre><code class="language-bash">\.....\\graphics\\Rectangle.java
</code></pre><p>The qualified name of the package member and the path name to the file are parallel, assuming the Microsoft Windows file name separator backslash (for UNIX, use the forward slash).</p><ul><li><strong>class name</strong> -- graphics.Rectangle</li><li><strong>pathname to file</strong> -- graphics<!-- -->\<!-- -->Rectangle.java</li></ul><p>As you should recall, by convention a company uses its reversed Internet domain name for its package names. The Example company, whose Internet domain name is example.com, would precede all its package names with com.example. Each component of the package name corresponds to a subdirectory. So, if the Example company had a com.example.graphics package that contained a Rectangle.java source file, it would be contained in a series of subdirectories like this:</p><p>.<!-- -->...<!-- -->\<!-- -->com<!-- -->\<!-- -->example<!-- -->\<!-- -->graphics<!-- -->\<!-- -->Rectangle.java</p><p>When you compile a source file, the compiler creates a different output file for each type defined in it. The base name of the output file is the name of the type, and its extension is .class. For example, if the source file is like this</p><pre><code class="language-java">//in the Rectangle.java file

package com.example.graphics;

public class Rectangle {

. . .

}

class Helper{

. . .

}
</code></pre><p>then the compiled files will be located at:</p><pre><code class="language-bash">&lt;path to the parent directory of the output files&gt;\\com\\example\\graphics\\Rectangle.class

&lt;path to the parent directory of the output files&gt;\\com\\example\\graphics\\Helper.class
</code></pre><p>Like the .java source files, the compiled .class files should be in a series of directories that reflect the package name. However, the path to the .class files does not have to be the same as the path to the .java source files. You can arrange your source and class directories separately, as:</p><pre><code class="language-bash">&lt;path_one&gt;\\sources\\com\\example\\graphics\\Rectangle.java

&lt;path_two&gt;\\classes\\com\\example\\graphics\\Rectangle.class
</code></pre><p>By doing this, you can give the classes directory to other programmers without revealing your sources. You also need to manage source and class files in this manner so that the compiler and the Java Virtual Machine (JVM) can find all the types your program uses.</p><p>The full path to the classes directory, <code>&lt;path_two&gt;</code>\<!-- -->classes, is called the <em>class path</em>, and is set with the CLASSPATH system variable. Both the compiler and the JVM construct the path to your .class files by adding the package name to the class path. For example, if</p><pre><code class="language-bash">&lt;path_two&gt;\\classes
</code></pre><p>is your class path, and the package name is com.example.graphics then the compiler and JVM look for .class files in</p><pre><code class="language-bash">&lt;path_two&gt;\\classes\\com\\example\\graphics.
</code></pre><p>A class path may include several paths, separated by a semicolon (Windows) or colon (UNIX). By default, the compiler and the JVM search the current directory and the JAR file containing the Java platform classes so that these directories are automatically in your class path.</p><h3>9.5.1 Setting the CLASSPATH System Variable</h3><p>To display the current CLASSPATH variable, use these commands in Windows and UNIX (Bourne shell):</p><p>In Windows:   C:<!-- -->\<!-- -->&gt; set CLASSPATH</p><p>In UNIX:      % echo \$CLASSPATH</p><p>To delete the current contents of the CLASSPATH variable, use these commands:</p><p>In Windows:   C:<!-- -->\<!-- -->&gt; set CLASSPATH=</p><p>In UNIX:      % unset CLASSPATH; export CLASSPATH</p><p>To set the CLASSPATH variable, use these commands (for example):</p><p>In Windows:   C:<!-- -->\<!-- -->&gt; set CLASSPATH=C:<!-- -->\<!-- -->users<!-- -->\<!-- -->george<!-- -->\<!-- -->java<!-- -->\<!-- -->classes</p><p>In UNIX:      % CLASSPATH=/home/george/java/classes; export CLASSPATH</p><h2>9.6 Summary of Creating and Using Packages</h2><p>To create a package for a type, put a package statement as the first statement in the source file that contains the type (class, interface, enumeration, or annotation type).</p><p>To use a public type that&#x27;s in a different package, you have three choices: (1) use the fully qualified name of the type, (2) import the type, or (3) import the entire package of which the type is a member.</p><p>The path names for a package&#x27;s source and class files mirror the name of the package.</p><p>You might have to set your CLASSPATH so that the compiler and the JVM can find the .class files for your types.</p><h1>10 Exceptions</h1><h2>10.1 What Is an Exception?</h2><p>The term <em>exception</em> is shorthand for the phrase &quot;exceptional event.&quot; An <em>exception</em> is an event, which occurs during the execution of a program, that disrupts the normal flow of the program&#x27;s instructions.</p><p>When an error occurs within a method, the method creates an object and hands it off to the runtime system. The object, called an <em>exception object</em>, contains information about the error, including its type and the state of the program when the error occurred. Creating an exception object and handing it to the runtime system is called <em>throwing an exception</em>.</p><p>After a method throws an exception, the runtime system attempts to find something to handle it. The set of possible &quot;somethings&quot; to handle the exception is the ordered list of methods that had been called to get to the method where the error occurred. The list of methods is known as the <em>call stack</em> (see the next figure).</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8bAwAI6gL1zE+pdQAAAABJRU5ErkJggg==" alt="The call stack showing three method calls, where the first method called has the exception handler."/></p><p>The call stack.</p><p>The runtime system searches the call stack for a method that contains a block of code that can handle the exception. This block of code is called an <em>exception handler</em>. The search begins with the method in which the error occurred and proceeds through the call stack in the reverse order in which the methods were called. When an appropriate handler is found, the runtime system passes the exception to the handler. An exception handler is considered appropriate if the type of the exception object thrown matches the type that can be handled by the handler.</p><p>The exception handler chosen is said to <em>catch the exception</em>. If the runtime system exhaustively searches all the methods on the call stack without finding an appropriate exception handler, as shown in the next figure, the runtime system (and, consequently, the program) terminates.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//83AwAI9AL6QlVpdgAAAABJRU5ErkJggg==" alt="The call stack showing three method calls, where the first method called has the exception handler."/></p><p>Searching the call stack for the exception handler.</p><p>Using exceptions to manage errors has some advantages over traditional error-management techniques. You can learn more in the <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html">Advantages of Exceptions</a> section.</p><h2>10.2 The Catch or Specify Requirement</h2><p>Valid Java programming language code must honor the <em>Catch or Specify Requirement</em>. This means that code that might throw certain exceptions must be enclosed by either of the following:</p><ul><li>A try statement that catches the exception. The try must provide a handler for the exception, as described in <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html">Catching and Handling Exceptions</a>.</li><li>A method that specifies that it can throw the exception. The method must provide a throws clause that lists the exception, as described in <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/declaring.html">Specifying the Exceptions Thrown by a Method</a>.</li></ul><p>Code that fails to honor the Catch or Specify Requirement will not compile.</p><p>Not all exceptions are subject to the Catch or Specify Requirement. To understand why, we need to look at the three basic categories of exceptions, only one of which is subject to the Requirement.</p><h3>10.2.1 The Three Kinds of Exceptions</h3><p>The first kind of exception is the <em>checked exception</em>. These are exceptional conditions that a well-written application should anticipate and recover from. For example, suppose an application prompts a user for an input file name, then opens the file by passing the name to the constructor for java.io.FileReader. Normally, the user provides the name of an existing, readable file, so the construction of the FileReader object succeeds, and the execution of the application proceeds normally. But sometimes the user supplies the name of a nonexistent file, and the constructor throws java.io.FileNotFoundException. A well-written program will catch this exception and notify the user of the mistake, possibly prompting for a corrected file name.</p><p>Checked exceptions <em>are subject</em> to the Catch or Specify Requirement. All exceptions are checked exceptions, except for those indicated by Error, RuntimeException, and their subclasses.</p><p>The second kind of exception is the <em>error</em>. These are exceptional conditions that are external to the application, and that the application usually cannot anticipate or recover from. For example, suppose that an application successfully opens a file for input, but is unable to read the file because of a hardware or system malfunction. The unsuccessful read will throw java.io.IOError. An application might choose to catch this exception, in order to notify the user of the problem --- but it also might make sense for the program to print a stack trace and exit.</p><p>Errors <em>are not subject</em> to the Catch or Specify Requirement. Errors are those exceptions indicated by Error and its subclasses.</p><p>The third kind of exception is the <em>runtime exception</em>. These are exceptional conditions that are internal to the application, and that the application usually cannot anticipate or recover from. These usually indicate programming bugs, such as logic errors or improper use of an API. For example, consider the application described previously that passes a file name to the constructor for FileReader. If a logic error causes a null to be passed to the constructor, the constructor will throw NullPointerException. The application can catch this exception, but it probably makes more sense to eliminate the bug that caused the exception to occur.</p><p>Runtime exceptions <em>are not subject</em> to the Catch or Specify Requirement. Runtime exceptions are those indicated by RuntimeException and its subclasses.</p><p>Errors and runtime exceptions are collectively known as <em>unchecked exceptions</em>.</p><h3>10.2.2 Bypassing Catch or Specify</h3><p>Some programmers consider the Catch or Specify Requirement a serious flaw in the exception mechanism and bypass it by using unchecked exceptions in place of checked exceptions. In general, this is not recommended. The section <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html">Unchecked Exceptions --- The Controversy</a> talks about when it is appropriate to use unchecked exceptions.</p><h2>10.3 Catching and Handling Exceptions</h2><p>This section describes how to use the three exception handler components --- the try, catch, and finally blocks --- to write an exception handler. Then, the try-with-resources statement, introduced in Java SE 7, is explained. The try-with-resources statement is particularly suited to situations that use Closeable resources, such as streams.</p><p>The last part of this section walks through an example and analyzes what occurs during various scenarios.</p><p>The following example defines and implements a class named ListOfNumbers. When constructed, ListOfNumbers creates an ArrayList that contains 10 Integer elements with sequential values 0 through 9. The ListOfNumbers class also defines a method named writeList, which writes the list of numbers into a text file called OutFile.txt. This example uses output classes defined in java.io, which are covered in <a href="https://docs.oracle.com/javase/tutorial/essential/io/index.html">Basic I/O</a>.</p><p>// Note: This class will not compile yet.</p><pre><code class="language-java">import java.io.*;

import java.util.List;

import java.util.ArrayList;

public class ListOfNumbers {

private List&lt;Integer&gt; list;

private static final int SIZE = 10;

public ListOfNumbers () {

list = new ArrayList&lt;Integer&gt;(SIZE);

for (int i = 0; i &lt; SIZE; i++) {

list.add(new Integer(i));

}

}

public void writeList() {

// The FileWriter constructor throws IOException, which must be caught.

PrintWriter out = new PrintWriter(**new FileWriter(&quot;OutFile.txt&quot;)**);

for (int i = 0; i &lt; SIZE; i++) {

// The get(int) method throws IndexOutOfBoundsException, which must be caught.

out.println(&quot;Value at: &quot; + i + &quot; = &quot; + **list.get(i)**);

}

out.close();

}

}
</code></pre><p>The first line in boldface is a call to a constructor. The constructor initializes an output stream on a file. If the file cannot be opened, the constructor throws an IOException. The second boldface line is a call to the ArrayList class&#x27;s get method, which throws an IndexOutOfBoundsException if the value of its argument is too small (less than 0) or too large (more than the number of elements currently contained by the ArrayList).</p><p>If you try to compile the <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/examples/ListOfNumbers.java">ListOfNumbers</a> class, the compiler prints an error message about the exception thrown by the FileWriter constructor. However, it does not display an error message about the exception thrown by get. The reason is that the exception thrown by the constructor, IOException, is a checked exception, and the one thrown by the get method, IndexOutOfBoundsException, is an unchecked exception.</p><p>Now that you&#x27;re familiar with the ListOfNumbers class and where the exceptions can be thrown within it, you&#x27;re ready to write exception handlers to catch and handle those exceptions.</p><h2>10.4 The try Block</h2><p>The first step in constructing an exception handler is to enclose the code that might throw an exception within a try block. In general, a try block looks like the following:</p><pre><code class="language-java">try {
*code*
}
*catch and finally blocks . . .*
</code></pre><p>The segment in the example labeled <em>code</em> contains one or more legal lines of code that could throw an exception. (The catch and finally blocks are explained in the next two subsections.)</p><p>To construct an exception handler for the writeList method from the ListOfNumbers class, enclose the exception-throwing statements of the writeList method within a try block. There is more than one way to do this. You can put each line of code that might throw an exception within its own try block and provide separate exception handlers for each. Or, you can put all the writeList code within a single try block and associate multiple handlers with it. The following listing uses one try block for the entire method because the code in question is very short.</p><pre><code class="language-java">private List&lt;Integer&gt; list;
private static final int SIZE = 10;
public void writeList() {
PrintWriter out = null;
try {
System.out.println(&quot;Entered try statement&quot;);
out = new PrintWriter(new FileWriter(&quot;OutFile.txt&quot;));
for (int i = 0; i &lt; SIZE; i++) {
out.println(&quot;Value at: &quot; + i + &quot; = &quot; + list.get(i));
}
}
// catch and finally blocks . . .
}
</code></pre><p>If an exception occurs within the try block, that exception is handled by an exception handler associated with it. To associate an exception handler with a try block, you must put a catch block after it; the next section, <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html">The catch Blocks</a>, shows you how.</p><h2>10.5 The catch Blocks</h2><p>You associate exception handlers with a try block by providing one or more catch blocks directly after the try block. No code can be between the end of the try block and the beginning of the first catch block.</p><pre><code class="language-java">try {

} catch (*ExceptionType name*) {

} catch (*ExceptionType name*) {

}
</code></pre><p>Each catch block is an exception handler that handles the type of exception indicated by its argument. The argument type, <em>ExceptionType</em>, declares the type of exception that the handler can handle and must be the name of a class that inherits from the Throwable class. The handler can refer to the exception with <em>name</em>.</p><p>The catch block contains code that is executed if and when the exception handler is invoked. The runtime system invokes the exception handler when the handler is the first one in the call stack whose <em>ExceptionType</em> matches the type of the exception thrown. The system considers it a match if the thrown object can legally be assigned to the exception handler&#x27;s argument.</p><p>The following are two exception handlers for the writeList method:</p><pre><code class="language-java">try {

} catch (IndexOutOfBoundsException e) {

System.err.println(&quot;IndexOutOfBoundsException: &quot; + e.getMessage());

} catch (IOException e) {

System.err.println(&quot;Caught IOException: &quot; + e.getMessage());

}
</code></pre><p>Exception handlers can do more than just print error messages or halt the program. They can do error recovery, prompt the user to make a decision, or propagate the error up to a higher-level handler using chained exceptions, as described in the <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/chained.html">Chained Exceptions</a> section.</p><h3>10.5.1 Catching More Than One Type of Exception with One Exception Handler</h3><p>In Java SE 7 and later, a single catch block can handle more than one type of exception. This feature can reduce code duplication and lessen the temptation to catch an overly broad exception.</p><p>In the catch clause, specify the types of exceptions that block can handle, and separate each exception type with a vertical bar (<!-- -->|<!-- -->):</p><pre><code class="language-java">catch (IOException\|SQLException ex) {
logger.log(ex);
throw ex;
}
</code></pre><p><strong>Note</strong>: If a catch block handles more than one exception type, then the catch parameter is implicitly final. In this example, the catch parameter ex is final and therefore you cannot assign any values to it within the catch block.</p><h2>10.6 The finally Block</h2><p>The finally block <em>always</em> executes when the try block exits. This ensures that the finally block is executed even if an unexpected exception occurs. But finally is useful for more than just exception handling --- it allows the programmer to avoid having cleanup code accidentally bypassed by a return, continue, or break. Putting cleanup code in a finally block is always a good practice, even when no exceptions are anticipated.</p><p><strong>Note:</strong> If the JVM exits while the try or catch code is being executed, then the finally block may not execute. Likewise, if the thread executing the try or catch code is interrupted or killed, the finally block may not execute even though the application as a whole continues.</p><p>The try block of the writeList method that you&#x27;ve been working with here opens a PrintWriter. The program should close that stream before exiting the writeList method. This poses a somewhat complicated problem because writeList&#x27;s try block can exit in one of three ways.</p><ol><li>The new FileWriter statement fails and throws an IOException.</li><li>The list.get(i) statement fails and throws an IndexOutOfBoundsException.</li><li>Everything succeeds and the try block exits normally.</li></ol><p>The runtime system always executes the statements within the finally block regardless of what happens within the try block. So it&#x27;s the perfect place to perform cleanup.</p><p>The following finally block for the writeList method cleans up and then closes the PrintWriter.</p><p>finally {</p><p>if (out != null) {</p><p>System.out.println(&quot;Closing PrintWriter&quot;);</p><p>out.close();</p><p>} else {</p><p>System.out.println(&quot;PrintWriter not open&quot;);</p><p>}</p><p>}</p><p><strong>Important:</strong> The finally block is a key tool for preventing resource leaks. When closing a file or otherwise recovering resources, place the code in a finally block to ensure that resource is <em>always</em> recovered.</p><p>Consider using the try-with-resources statement in these situations, which automatically releases system resources when no longer needed. The <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">The try-with-resources Statement</a>section has more information.</p><h2>10.7 The try-with-resources Statement</h2><p>The try-with-resources statement is a try statement that declares one or more resources. A <em>resource</em> is an object that must be closed after the program is finished with it. The try-with-resources statement ensures that each resource is closed at the end of the statement. Any object that implements java.lang.AutoCloseable, which includes all objects which implement java.io.Closeable, can be used as a resource.</p><p>The following example reads the first line from a file. It uses an instance of BufferedReader to read data from the file. BufferedReader is a resource that must be closed after the program is finished with it:</p><p>static String readFirstLineFromFile(String path) throws IOException {</p><p><strong>try (BufferedReader br =</strong></p><p><strong>new BufferedReader(new FileReader(path)))</strong> {</p><p>return br.readLine();</p><p>}</p><p>}</p><p>In this example, the resource declared in the try-with-resources statement is a BufferedReader. The declaration statement appears within parentheses immediately after the try keyword. The class BufferedReader, in Java SE 7 and later, implements the interface java.lang.AutoCloseable. Because the BufferedReader instance is declared in a try-with-resource statement, it will be closed regardless of whether the try statement completes normally or abruptly (as a result of the method BufferedReader.readLine throwing an IOException).</p><p>Prior to Java SE 7, you can use a finally block to ensure that a resource is closed regardless of whether the try statement completes normally or abruptly. The following example uses a finally block instead of a try-with-resources statement:</p><p>static String readFirstLineFromFileWithFinallyBlock(String path)</p><p>throws IOException {</p><p>BufferedReader br = new BufferedReader(new FileReader(path));</p><p>try {</p><p>return br.readLine();</p><p>} finally {</p><p>if (br != null) br.close();</p><p>}</p><p>}</p><p>However, in this example, if the methods readLine and close both throw exceptions, then the method readFirstLineFromFileWithFinallyBlock throws the exception thrown from the finally block; the exception thrown from the try block is suppressed. In contrast, in the example readFirstLineFromFile, if exceptions are thrown from both the try block and the try-with-resources statement, then the method readFirstLineFromFile throws the exception thrown from the try block; the exception thrown from the try-with-resources block is suppressed. In Java SE 7 and later, you can retrieve suppressed exceptions; see the section <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html#suppressed-exceptions">Suppressed Exceptions</a> for more information.</p><p>You may declare one or more resources in a try-with-resources statement. The following example retrieves the names of the files packaged in the zip file zipFileName and creates a text file that contains the names of these files:</p><p>public static void writeToFileZipFileContents(String zipFileName,</p><p>String outputFileName)</p><p>throws java.io.IOException {</p><p>java.nio.charset.Charset charset =</p><p>java.nio.charset.StandardCharsets.US_ASCII;</p><p>java.nio.file.Path outputFilePath =</p><p>java.nio.file.Paths.get(outputFileName);</p><p>// Open zip file and create output file with</p><p>// try-with-resources statement</p><p><strong>try (</strong></p><p><strong>java.util.zip.ZipFile zf =</strong></p><p><strong>new java.util.zip.ZipFile(zipFileName);</strong></p><p><strong>java.io.BufferedWriter writer =</strong></p><p><strong>java.nio.file.Files.newBufferedWriter(outputFilePath, charset)</strong></p><p><strong>)</strong> {</p><p>// Enumerate each entry</p><p>for (java.util.Enumeration entries =</p><p>zf.entries(); entries.hasMoreElements();) {</p><p>// Get the entry name and write it to the output file</p><p>String newLine = System.getProperty(&quot;line.separator&quot;);</p><p>String zipEntryName =</p><p>((java.util.zip.ZipEntry)entries.nextElement()).getName() +</p><p>newLine;</p><p>writer.write(zipEntryName, 0, zipEntryName.length());</p><p>}</p><p>}</p><p>}</p><p>In this example, the try-with-resources statement contains two declarations that are separated by a semicolon: ZipFile and BufferedWriter. When the block of code that directly follows it terminates, either normally or because of an exception, the close methods of the BufferedWriter and ZipFile objects are automatically called in this order. Note that the close methods of resources are called in the <em>opposite</em> order of their creation.</p><p>The following example uses a try-with-resources statement to automatically close a java.sql.Statement object:</p><p>public static void viewTable(Connection con) throws SQLException {</p><p>String query = &quot;select COF_NAME, SUP_ID, PRICE, SALES, TOTAL from COFFEES&quot;;</p><p><strong>try (Statement stmt = con.createStatement())</strong> {</p><p>ResultSet rs = stmt.executeQuery(query);</p><p>while (rs.next()) {</p><p>String coffeeName = rs.getString(&quot;COF_NAME&quot;);</p><p>int supplierID = rs.getInt(&quot;SUP_ID&quot;);</p><p>float price = rs.getFloat(&quot;PRICE&quot;);</p><p>int sales = rs.getInt(&quot;SALES&quot;);</p><p>int total = rs.getInt(&quot;TOTAL&quot;);</p><p>System.out.println(coffeeName + &quot;, &quot; + supplierID + &quot;, &quot; +</p><p>price + &quot;, &quot; + sales + &quot;, &quot; + total);</p><p>}</p><p>} catch (SQLException e) {</p><p>JDBCTutorialUtilities.printSQLException(e);</p><p>}</p><p>}</p><p>The resource java.sql.Statement used in this example is part of the JDBC 4.1 and later API.</p><p><strong>Note</strong>: A try-with-resources statement can have catch and finally blocks just like an ordinary try statement. In a try-with-resources statement, any catch or finally block is run after the resources declared have been closed.</p><h3>10.7.1 Suppressed Exceptions</h3><p>An exception can be thrown from the block of code associated with the try-with-resources statement. In the example writeToFileZipFileContents, an exception can be thrown from the try block, and up to two exceptions can be thrown from the try-with-resources statement when it tries to close the ZipFile and BufferedWriter objects. If an exception is thrown from the try block and one or more exceptions are thrown from the try-with-resources statement, then those exceptions thrown from the try-with-resources statement are suppressed, and the exception thrown by the block is the one that is thrown by the writeToFileZipFileContents method. You can retrieve these suppressed exceptions by calling the Throwable.getSuppressed method from the exception thrown by the try block.</p><h3>10.7.2 Classes That Implement the AutoCloseable or Closeable Interface</h3><p>See the Javadoc of the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html">AutoCloseable</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html">Closeable</a> interfaces for a list of classes that implement either of these interfaces. The Closeable interface extends the AutoCloseableinterface. The close method of the Closeable interface throws exceptions of type IOException while the close method of the AutoCloseable interface throws exceptions of type Exception. Consequently, subclasses of the AutoCloseable interface can override this behavior of the close method to throw specialized exceptions, such as IOException, or no exception at all.</p><h2>10.8 Putting It All Together</h2><p>The previous sections described how to construct the try, catch, and finally code blocks for the writeList method in the ListOfNumbers class. Now, let&#x27;s walk through the code and investigate what can happen.</p><p>When all the components are put together, the writeList method looks like the following.</p><p>public void writeList() {</p><p>PrintWriter out = null;</p><p>try {</p><p>System.out.println(&quot;Entering&quot; + &quot; try statement&quot;);</p><p>out = new PrintWriter(new FileWriter(&quot;OutFile.txt&quot;));</p><p>for (int i = 0; i &lt; SIZE; i++) {</p><p>out.println(&quot;Value at: &quot; + i + &quot; = &quot; + list.get(i));</p><p>}</p><p>} catch (IndexOutOfBoundsException e) {</p><p>System.err.println(&quot;Caught IndexOutOfBoundsException: &quot;</p><ul><li>e.getMessage());</li></ul><p>} catch (IOException e) {</p><p>System.err.println(&quot;Caught IOException: &quot; + e.getMessage());</p><p>} finally {</p><p>if (out != null) {</p><p>System.out.println(&quot;Closing PrintWriter&quot;);</p><p>out.close();</p><p>}</p><p>else {</p><p>System.out.println(&quot;PrintWriter not open&quot;);</p><p>}</p><p>}</p><p>}</p><p>As mentioned previously, this method&#x27;s try block has three different exit possibilities; here are two of them.</p><ol><li>Code in the try statement fails and throws an exception. This could be an IOException caused by the new FileWriter statement or an IndexOutOfBoundsException caused by a wrong index value in the for loop.</li><li>Everything succeeds and the try statement exits normally.</li></ol><p>Let&#x27;s look at what happens in the writeList method during these two exit possibilities.</p><h3>10.8.1 Scenario 1: An Exception Occurs</h3><p>The statement that creates a FileWriter can fail for a number of reasons. For example, the constructor for the FileWriter throws an IOException if the program cannot create or write to the file indicated.</p><p>When FileWriter throws an IOException, the runtime system immediately stops executing the try block; method calls being executed are not completed. The runtime system then starts searching at the top of the method call stack for an appropriate exception handler. In this example, when the IOException occurs, the FileWriter constructor is at the top of the call stack. However, the FileWriter constructor doesn&#x27;t have an appropriate exception handler, so the runtime system checks the next method --- the writeList method --- in the method call stack. The writeList method has two exception handlers: one for IOException and one for IndexOutOfBoundsException.</p><p>The runtime system checks writeList&#x27;s handlers in the order in which they appear after the try statement. The argument to the first exception handler is IndexOutOfBoundsException. This does not match the type of exception thrown, so the runtime system checks the next exception handler --- IOException. This matches the type of exception that was thrown, so the runtime system ends its search for an appropriate exception handler. Now that the runtime has found an appropriate handler, the code in that catch block is executed.</p><p>After the exception handler executes, the runtime system passes control to the finally block. Code in the finally block executes regardless of the exception caught above it. In this scenario, the FileWriter was never opened and doesn&#x27;t need to be closed. After the finally block finishes executing, the program continues with the first statement after the finally block.</p><p>Here&#x27;s the complete output from the ListOfNumbers program that appears when an IOException is thrown.</p><p>Entering try statement</p><p>Caught IOException: OutFile.txt</p><p>PrintWriter not open</p><p>The boldface code in the following listing shows the statements that get executed during this scenario:</p><p>public void writeList() {</p><p><strong>PrintWriter out = null;</strong></p><p><strong>try {</strong></p><p><strong>System.out.println(&quot;Entering try statement&quot;);</strong></p><p><strong>out = new PrintWriter(new FileWriter(&quot;OutFile.txt&quot;));</strong></p><p>for (int i = 0; i &lt; SIZE; i++)</p><p>out.println(&quot;Value at: &quot; + i + &quot; = &quot; + list.get(i));</p><p>} catch (IndexOutOfBoundsException e) {</p><p>System.err.println(&quot;Caught IndexOutOfBoundsException: &quot;</p><ul><li>e.getMessage());</li></ul><p>} <strong>catch (IOException e) {</strong></p><p><strong>System.err.println(&quot;Caught IOException: &quot; + e.getMessage());</strong></p><p><strong>} finally {</strong></p><p><strong>if (out != null) {</strong></p><p>System.out.println(&quot;Closing PrintWriter&quot;);</p><p>out.close();</p><p>}</p><p><strong>else {</strong></p><p><strong>System.out.println(&quot;PrintWriter not open&quot;);</strong></p><p><strong>}</strong></p><p>}</p><p>}</p><h3>10.8.2 Scenario 2: The try Block Exits Normally</h3><p>In this scenario, all the statements within the scope of the try block execute successfully and throw no exceptions. Execution falls off the end of the try block, and the runtime system passes control to the finally block. Because everything was successful, the PrintWriter is open when control reaches the finally block, which closes the PrintWriter. Again, after the finally block finishes executing, the program continues with the first statement after the finally block.</p><p>Here is the output from the ListOfNumbers program when no exceptions are thrown.</p><p>Entering try statement</p><p>Closing PrintWriter</p><p>The boldface code in the following sample shows the statements that get executed during this scenario.</p><p>public void writeList() {</p><p><strong>PrintWriter out = null;</strong></p><p><strong>try {</strong></p><p><strong>System.out.println(&quot;Entering try statement&quot;);</strong></p><p><strong>out = new PrintWriter(new FileWriter(&quot;OutFile.txt&quot;));</strong></p><p><strong>for (int i = 0; i &lt; SIZE; i++)</strong></p><p><strong>out.println(&quot;Value at: &quot; + i + &quot; = &quot; + list.get(i));</strong></p><p><strong>}</strong> catch (IndexOutOfBoundsException e) {</p><p>System.err.println(&quot;Caught IndexOutOfBoundsException: &quot;</p><ul><li>e.getMessage());</li></ul><p>} catch (IOException e) {</p><p>System.err.println(&quot;Caught IOException: &quot; + e.getMessage());</p><p>} <strong>finally {</strong></p><p><strong>if (out != null) {</strong></p><p><strong>System.out.println(&quot;Closing PrintWriter&quot;);</strong></p><p><strong>out.close();</strong></p><p><strong>}</strong></p><p>else {</p><p>System.out.println(&quot;PrintWriter not open&quot;);</p><p>}</p><p>}</p><p>}</p><h2>10.9 Specifying the Exceptions Thrown by a Method</h2><p>The previous section showed how to write an exception handler for the writeList method in the ListOfNumbers class. Sometimes, it&#x27;s appropriate for code to catch exceptions that can occur within it. In other cases, however, it&#x27;s better to let a method further up the call stack handle the exception. For example, if you were providing the ListOfNumbers class as part of a package of classes, you probably couldn&#x27;t anticipate the needs of all the users of your package. In this case, it&#x27;s better to <em>not</em> catch the exception and to allow a method further up the call stack to handle it.</p><p>If the writeList method doesn&#x27;t catch the checked exceptions that can occur within it, the writeList method must specify that it can throw these exceptions. Let&#x27;s modify the original writeList method to specify the exceptions it can throw instead of catching them. To remind you, here&#x27;s the original version of the writeList method that won&#x27;t compile.</p><p>public void writeList() {</p><p>PrintWriter out = new PrintWriter(new FileWriter(&quot;OutFile.txt&quot;));</p><p>for (int i = 0; i &lt; SIZE; i++) {</p><p>out.println(&quot;Value at: &quot; + i + &quot; = &quot; + list.get(i));</p><p>}</p><p>out.close();</p><p>}</p><p>To specify that writeList can throw two exceptions, add a throws clause to the method declaration for the writeList method. The throws clause comprises the throws keyword followed by a comma-separated list of all the exceptions thrown by that method. The clause goes after the method name and argument list and before the brace that defines the scope of the method; here&#x27;s an example.</p><p>public void writeList() <strong>throws IOException, IndexOutOfBoundsException</strong> {</p><p>Remember that IndexOutOfBoundsException is an unchecked exception; including it in the throws clause is not mandatory. You could just write the following.</p><p>public void writeList() <strong>throws IOException</strong> {</p><h2>10.10 How to Throw Exceptions</h2><p>Before you can catch an exception, some code somewhere must throw one. Any code can throw an exception: your code, code from a package written by someone else such as the packages that come with the Java platform, or the Java runtime environment. Regardless of what throws the exception, it&#x27;s always thrown with the throw statement.</p><p>As you have probably noticed, the Java platform provides numerous exception classes. All the classes are descendants of the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html">Throwable</a> class, and all allow programs to differentiate among the various types of exceptions that can occur during the execution of a program.</p><p>You can also create your own exception classes to represent problems that can occur within the classes you write. In fact, if you are a package developer, you might have to create your own set of exception classes to allow users to differentiate an error that can occur in your package from errors that occur in the Java platform or other packages.</p><p>You can also create <em>chained</em> exceptions. For more information, see the <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/chained.html">Chained Exceptions</a> section.</p><h3>10.10.1 The throw Statement</h3><p>All methods use the throw statement to throw an exception. The throw statement requires a single argument: a throwable object. Throwable objects are instances of any subclass of the Throwable class. Here&#x27;s an example of a throw statement.</p><p>throw <em>someThrowableObject</em>;</p><p>Let&#x27;s look at the throw statement in context. The following pop method is taken from a class that implements a common stack object. The method removes the top element from the stack and returns the object.</p><p>public Object pop() {</p><p>Object obj;</p><p>if (size == 0) {</p><p><strong>throw new EmptyStackException();</strong></p><p>}</p><p>obj = objectAt(size - 1);</p><p>setObjectAt(size - 1, null);</p><p>size--;</p><p>return obj;</p><p>}</p><p>The pop method checks to see whether any elements are on the stack. If the stack is empty (its size is equal to 0), pop instantiates a new EmptyStackException object (a member of java.util) and throws it. The <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/creating.html">Creating Exception Classes</a> section in this chapter explains how to create your own exception classes. For now, all you need to remember is that you can throw only objects that inherit from the java.lang.Throwable class.</p><p>Note that the declaration of the pop method does not contain a throws clause. EmptyStackException is not a checked exception, so pop is not required to state that it might occur.</p><h3>10.10.2 Throwable Class and Its Subclasses</h3><p>The objects that inherit from the Throwable class include direct descendants (objects that inherit directly from the Throwable class) and indirect descendants (objects that inherit from children or grandchildren of the Throwable class). The figure below illustrates the class hierarchy of the Throwable class and its most significant subclasses. As you can see, Throwable has two direct descendants: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html">Error</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html">Exception</a>.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8HAwAI7gL3hTaWPwAAAABJRU5ErkJggg==" alt="The Throwable class and its most significant subclasses."/></p><p>The Throwable class.</p><h3>10.10.3 Error Class</h3><p>When a dynamic linking failure or other hard failure in the Java virtual machine occurs, the virtual machine throws an Error. Simple programs typically do <em>not</em> catch or throw Errors.</p><h3>10.10.4 Exception Class</h3><p>Most programs throw and catch objects that derive from the Exception class. An Exception indicates that a problem occurred, but it is not a serious system problem. Most programs you write will throw and catch Exceptions as opposed to Errors.</p><p>The Java platform defines the many descendants of the Exception class. These descendants indicate various types of exceptions that can occur. For example, IllegalAccessExceptionsignals that a particular method could not be found, and NegativeArraySizeException indicates that a program attempted to create an array with a negative size.</p><p>One Exception subclass, RuntimeException, is reserved for exceptions that indicate incorrect use of an API. An example of a runtime exception is NullPointerException, which occurs when a method tries to access a member of an object through a null reference. The section <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html">Unchecked Exceptions --- The Controversy</a> discusses why most applications shouldn&#x27;t throw runtime exceptions or subclass RuntimeException.</p><h2>10.11 Chained Exceptions</h2><p>An application often responds to an exception by throwing another exception. In effect, the first exception <em>causes</em> the second exception. It can be very helpful to know when one exception causes another. <em>Chained Exceptions</em> help the programmer do this.</p><p>The following are the methods and constructors in Throwable that support chained exceptions.</p><p>Throwable getCause()</p><p>Throwable initCause(Throwable)</p><p>Throwable(String, Throwable)</p><p>Throwable(Throwable)</p><p>The Throwable argument to initCause and the Throwable constructors is the exception that caused the current exception. getCause returns the exception that caused the current exception, and initCause sets the current exception&#x27;s cause.</p><p>The following example shows how to use a chained exception.</p><p>try {</p><p>} catch (IOException e) {</p><p>throw new SampleException(&quot;Other IOException&quot;, e);</p><p>}</p><p>In this example, when an IOException is caught, a new SampleException exception is created with the original cause attached and the chain of exceptions is thrown up to the next higher level exception handler.[]{#bookmark=id.104agfo}</p><h3>10.11.1 Accessing Stack Trace Information</h3><p>Now let&#x27;s suppose that the higher-level exception handler wants to dump the stack trace in its own format.</p><p><strong>Definition:</strong> A <em>stack trace</em> provides information on the execution history of the current thread and lists the names of the classes and methods that were called at the point when the exception occurred. A stack trace is a useful debugging tool that you&#x27;ll normally take advantage of when an exception has been thrown.</p><p>The following code shows how to call the getStackTrace method on the exception object.</p><p>catch (Exception cause) {</p><p>StackTraceElement elements[] = cause.getStackTrace();</p><p>for (int i = 0, n = elements.length; i &lt; n; i++) {</p><p>System.err.println(elements<!-- -->[i]<!-- -->.getFileName()</p><ul><li><p>&quot;:&quot; + elements<!-- -->[i]<!-- -->.getLineNumber()</p></li><li><p>&quot;&gt;&gt; &quot;</p></li><li><p>elements<!-- -->[i]<!-- -->.getMethodName() + &quot;()&quot;);</p></li></ul><p>}</p><p>}</p><h3>10.11.2 Logging API</h3><p>The next code snippet logs where an exception occurred from within the catch block. However, rather than manually parsing the stack trace and sending the output to System.err(), it sends the output to a file using the logging facility in the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/logging/package-summary.html">java.util.logging</a> package.</p><p>try {</p><p>Handler handler = new FileHandler(&quot;OutFile.log&quot;);</p><p>Logger.getLogger(&quot;&quot;).addHandler(handler);</p><p>} catch (IOException e) {</p><p>Logger logger = Logger.getLogger(&quot;<em>package.name</em>&quot;);</p><p>StackTraceElement elements[] = e.getStackTrace();</p><p>for (int i = 0, n = elements.length; i &lt; n; i++) {</p><p>logger.log(Level.WARNING, elements<!-- -->[i]<!-- -->.getMethodName());</p><p>}</p><p>}</p><h2>10.12 Creating Exception Classes</h2><p>When faced with choosing the type of exception to throw, you can either use one written by someone else --- the Java platform provides a lot of exception classes you can use --- or you can write one of your own. You should write your own exception classes if you answer yes to any of the following questions; otherwise, you can probably use someone else&#x27;s.</p><ul><li>Do you need an exception type that isn&#x27;t represented by those in the Java platform?</li><li>Would it help users if they could differentiate your exceptions from those thrown by classes written by other vendors?</li><li>Does your code throw more than one related exception?</li><li>If you use someone else&#x27;s exceptions, will users have access to those exceptions? A similar question is, should your package be independent and self-contained?</li></ul><h3>10.12.1 An Example</h3><p>Suppose you are writing a linked list class. The class supports the following methods, among others:</p><ul><li><strong>objectAt(int n)</strong> --- Returns the object in the nth position in the list. Throws an exception if the argument is less than 0 or more than the number of objects currently in the list.</li><li><strong>firstObject()</strong> --- Returns the first object in the list. Throws an exception if the list contains no objects.</li><li><strong>indexOf(Object o)</strong> --- Searches the list for the specified Object and returns its position in the list. Throws an exception if the object passed into the method is not in the list.</li></ul><p>The linked list class can throw multiple exceptions, and it would be convenient to be able to catch all exceptions thrown by the linked list with one exception handler. Also, if you plan to distribute your linked list in a package, all related code should be packaged together. Thus, the linked list should provide its own set of exception classes.</p><p>The next figure illustrates one possible class hierarchy for the exceptions thrown by the linked list.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8+AwAIvALelUcUDAAAAABJRU5ErkJggg==" alt="A possible class hierarchy for the exceptions thrown by a linked list."/></p><p>Example exception class hierarchy.</p><h3>10.12.2 Choosing a Superclass</h3><p>Any Exception subclass can be used as the parent class of LinkedListException. However, a quick perusal of those subclasses shows that they are inappropriate because they are either too specialized or completely unrelated to LinkedListException. Therefore, the parent class of LinkedListException should be Exception.</p><p>Most applets and applications you write will throw objects that are Exceptions. Errors are normally used for serious, hard errors in the system, such as those that prevent the JVM from running.</p><p><strong>Note:</strong> For readable code, it&#x27;s good practice to append the string Exception to the names of all classes that inherit (directly or indirectly) from the Exception class.</p><h2>10.13 Unchecked Exceptions --- The Controversy</h2><p>Because the Java programming language does not require methods to catch or to specify unchecked exceptions (RuntimeException, Error, and their subclasses), programmers may be tempted to write code that throws only unchecked exceptions or to make all their exception subclasses inherit from RuntimeException. Both of these shortcuts allow programmers to write code without bothering with compiler errors and without bothering to specify or to catch any exceptions. Although this may seem convenient to the programmer, it sidesteps the intent of the catch or specify requirement and can cause problems for others using your classes.</p><p>Why did the designers decide to force a method to specify all uncaught checked exceptions that can be thrown within its scope? Any Exception that can be thrown by a method is part of the method&#x27;s public programming interface. Those who call a method must know about the exceptions that a method can throw so that they can decide what to do about them. These exceptions are as much a part of that method&#x27;s programming interface as its parameters and return value.</p><p>The next question might be: &quot;If it&#x27;s so good to document a method&#x27;s API, including the exceptions it can throw, why not specify runtime exceptions too?&quot; Runtime exceptions represent problems that are the result of a programming problem, and as such, the API client code cannot reasonably be expected to recover from them or to handle them in any way. Such problems include arithmetic exceptions, such as dividing by zero; pointer exceptions, such as trying to access an object through a null reference; and indexing exceptions, such as attempting to access an array element through an index that is too large or too small.</p><p>Runtime exceptions can occur anywhere in a program, and in a typical one they can be very numerous. Having to add runtime exceptions in every method declaration would reduce a program&#x27;s clarity. Thus, the compiler does not require that you catch or specify runtime exceptions (although you can).</p><p>One case where it is common practice to throw a RuntimeException is when the user calls a method incorrectly. For example, a method can check if one of its arguments is incorrectly null. If an argument is null, the method might throw a NullPointerException, which is an <em>unchecked</em> exception.</p><p>Generally speaking, do not throw a RuntimeException or create a subclass of RuntimeException simply because you don&#x27;t want to be bothered with specifying the exceptions your methods can throw.</p><p>Here&#x27;s the bottom line guideline: If a client can reasonably be expected to recover from an exception, make it a checked exception. If a client cannot do anything to recover from the exception, make it an unchecked exception.</p><h2>10.14 Advantages of Exceptions</h2><p>Now that you know what exceptions are and how to use them, it&#x27;s time to learn the advantages of using exceptions in your programs.</p><h3>10.14.1 Advantage 1: Separating Error-Handling Code from &quot;Regular&quot; Code</h3><p>Exceptions provide the means to separate the details of what to do when something out of the ordinary happens from the main logic of a program. In traditional programming, error detection, reporting, and handling often lead to confusing spaghetti code. For example, consider the pseudocode method here that reads an entire file into memory.</p><p>readFile {</p><p><strong><em>open the file;</em></strong></p><p><strong><em>determine its size;</em></strong></p><p><strong><em>allocate that much memory;</em></strong></p><p><strong><em>read the file into memory;</em></strong></p><p><strong><em>close the file;</em></strong></p><p>}</p><p>At first glance, this function seems simple enough, but it ignores all the following potential errors.</p><ul><li>What happens if the file can&#x27;t be opened?</li><li>What happens if the length of the file can&#x27;t be determined?</li><li>What happens if enough memory can&#x27;t be allocated?</li><li>What happens if the read fails?</li><li>What happens if the file can&#x27;t be closed?</li></ul><p>To handle such cases, the readFile function must have more code to do error detection, reporting, and handling. Here is an example of what the function might look like.</p><p>errorCodeType <strong>readFile {</strong></p><p>initialize errorCode = 0;</p><p><strong><em>open the file;</em></strong></p><p>if (<em>theFileIsOpen</em>) {</p><p><strong><em>determine the length of the file;</em></strong></p><p>if (<em>gotTheFileLength</em>) {</p><p><strong><em>allocate that much memory;</em></strong></p><p>if (<em>gotEnoughMemory</em>) {</p><p><strong><em>read the file into memory;</em></strong></p><p>if (<em>readFailed</em>) {</p><p>errorCode = -1;</p><p>}</p><p>} else {</p><p>errorCode = -2;</p><p>}</p><p>} else {</p><p>errorCode = -3;</p><p>}</p><p><strong><em>close the file;</em></strong></p><p>if (<em>theFileDidntClose</em> &amp;&amp; <em>errorCode</em> == 0) {</p><p>errorCode = -4;</p><p>} else {</p><p>errorCode = errorCode and -4;</p><p>}</p><p>} else {</p><p>errorCode = -5;</p><p>}</p><p>return errorCode;</p><p>}</p><p>There&#x27;s so much error detection, reporting, and returning here that the original seven lines of code are lost in the clutter. Worse yet, the logical flow of the code has also been lost, thus making it difficult to tell whether the code is doing the right thing: Is the file really being closed if the function fails to allocate enough memory? It&#x27;s even more difficult to ensure that the code continues to do the right thing when you modify the method three months after writing it. Many programmers solve this problem by simply ignoring it --- errors are reported when their programs crash.</p><p>Exceptions enable you to write the main flow of your code and to deal with the exceptional cases elsewhere. If the readFile function used exceptions instead of traditional error-management techniques, it would look more like the following.</p><p><strong><em>readFile</em></strong> {</p><p>try {</p><p><strong><em>open the file;</em></strong></p><p><strong><em>determine its size;</em></strong></p><p><strong><em>allocate that much memory;</em></strong></p><p><strong><em>read the file into memory;</em></strong></p><p><strong><em>close the file;</em></strong></p><p>} catch (<em>fileOpenFailed</em>) {</p><p><strong><em>doSomething;</em></strong></p><p>} catch (<em>sizeDeterminationFailed</em>) {</p><p><strong><em>doSomething;</em></strong></p><p>} catch (<em>memoryAllocationFailed</em>) {</p><p><strong><em>doSomething;</em></strong></p><p>} catch (<em>readFailed</em>) {</p><p><strong><em>doSomething;</em></strong></p><p>} catch (<em>fileCloseFailed</em>) {</p><p><strong><em>doSomething;</em></strong></p><p>}</p><p>}</p><p>Note that exceptions don&#x27;t spare you the effort of doing the work of detecting, reporting, and handling errors, but they do help you organize the work more effectively.</p><h3>10.14.2 Advantage 2: Propagating Errors Up the Call Stack</h3><p>A second advantage of exceptions is the ability to propagate error reporting up the call stack of methods. Suppose that the readFile method is the fourth method in a series of nested method calls made by the main program: method1 calls method2, which calls method3, which finally calls readFile.</p><p>method1 {</p><p><strong><em>call method2;</em></strong></p><p>}</p><p>method2 {</p><p><strong><em>call method3;</em></strong></p><p>}</p><p>method3 {</p><p><strong><em>call readFile;</em></strong></p><p>}</p><p>Suppose also that method1 is the only method interested in the errors that might occur within readFile. Traditional error-notification techniques force method2 and method3 to propagate the error codes returned by readFile up the call stack until the error codes finally reach method1---the only method that is interested in them.</p><p><strong>method1</strong> {</p><p>errorCodeType error;</p><p>error = <strong><em>call method2;</em></strong></p><p>if (error)</p><p><strong><em>doErrorProcessing;</em></strong></p><p>else</p><p><strong><em>proceed;</em></strong></p><p><strong>}</strong></p><p>errorCodeType <strong>method2 {</strong></p><p>errorCodeType error;</p><p>error = call <strong>method3;</strong></p><p>if (error)</p><p>return error;</p><p>else</p><p><strong><em>proceed;</em></strong></p><p><strong>}</strong></p><p>errorCodeType <strong>method3 {</strong></p><p>errorCodeType error;</p><p>error = <strong>call readFile;</strong></p><p>if (error)</p><p>return error;</p><p>else</p><p><strong><em>proceed;</em></strong></p><p><strong>}</strong></p><p>Recall that the Java runtime environment searches backward through the call stack to find any methods that are interested in handling a particular exception. A method can duck any exceptions thrown within it, thereby allowing a method farther up the call stack to catch it. Hence, only the methods that care about errors have to worry about detecting errors.</p><p><strong>method1</strong> {</p><p>try {</p><p><strong><em>call method2;</em></strong></p><p>} catch (<em>exception</em> e) {</p><p><strong><em>doErrorProcessing;</em></strong></p><p>}</p><p>}</p><p><strong>method2</strong> throws <em>exception</em> {</p><p><strong><em>call method3;</em></strong></p><p>}</p><p><strong>method3</strong> throws exception <strong>{</strong></p><p><strong><em>call readFile;</em></strong></p><p><strong>}</strong></p><p>However, as the pseudocode shows, ducking an exception requires some effort on the part of the middleman methods. Any checked exceptions that can be thrown within a method must be specified in its throws clause.</p><h3>10.14.3 Advantage 3: Grouping and Differentiating Error Types</h3><p>Because all exceptions thrown within a program are objects, the grouping or categorizing of exceptions is a natural outcome of the class hierarchy. An example of a group of related exception classes in the Java platform are those defined in java.io --- IOException and its descendants. IOException is the most general and represents any type of error that can occur when performing I/O. Its descendants represent more specific errors. For example, FileNotFoundException means that a file could not be located on disk.</p><p>A method can write specific handlers that can handle a very specific exception. The FileNotFoundException class has no descendants, so the following handler can handle only one type of exception.</p><p>catch (FileNotFoundException e) {</p><p>.<!-- -->..</p><p>}</p><p>A method can catch an exception based on its group or general type by specifying any of the exception&#x27;s superclasses in the catch statement. For example, to catch all I/O exceptions, regardless of their specific type, an exception handler specifies an IOException argument.</p><p>catch (IOException e) {</p><p>.<!-- -->..</p><p>}</p><p>This handler will be able to catch all I/O exceptions, including FileNotFoundException, EOFException, and so on. You can find details about what occurred by querying the argument passed to the exception handler. For example, use the following to print the stack trace.</p><p>catch (IOException e) {</p><p>// Output goes to System.err.</p><p>e.printStackTrace();</p><p>// Send trace to stdout.</p><p>e.printStackTrace(System.out);</p><p>}</p><p>You could even set up an exception handler that handles any Exception with the handler here.</p><p>// <em>A (too) general exception handler</em></p><p>catch (Exception e) {</p><p>.<!-- -->..</p><p>}</p><p>The Exception class is close to the top of the Throwable class hierarchy. Therefore, this handler will catch many other exceptions in addition to those that the handler is intended to catch. You may want to handle exceptions this way if all you want your program to do, for example, is print out an error message for the user and then exit.</p><p>In most situations, however, you want exception handlers to be as specific as possible. The reason is that the first thing a handler must do is determine what type of exception occurred before it can decide on the best recovery strategy. In effect, by not catching specific errors, the handler must accommodate any possibility. Exception handlers that are too general can make code more error-prone by catching and handling exceptions that weren&#x27;t anticipated by the programmer and for which the handler was not intended.</p><p>As noted, you can create groups of exceptions and handle exceptions in a general fashion, or you can use the specific exception type to differentiate exceptions and handle exceptions in an exact fashion.</p><h2>10.15 Summary</h2><p>A program can use exceptions to indicate that an error occurred. To throw an exception, use the throw statement and provide it with an exception object --- a descendant of Throwable --- to provide information about the specific error that occurred. A method that throws an uncaught, checked exception must include a throws clause in its declaration.</p><p>A program can catch exceptions by using a combination of the try, catch, and finally blocks.</p><ul><li>The try block identifies a block of code in which an exception can occur.</li><li>The catch block identifies a block of code, known as an exception handler, that can handle a particular type of exception.</li><li>The finally block identifies a block of code that is guaranteed to execute, and is the right place to close files, recover resources, and otherwise clean up after the code enclosed in the try block.</li></ul><p>The try statement should contain at least one catch block or a finally block and may have multiple catch blocks.</p><p>The class of the exception object indicates the type of exception thrown. The exception object can contain further information about the error, including an error message. With exception chaining, an exception can point to the exception that caused it, which can in turn point to the exception that caused <em>it</em>, and so on.</p><h1>11 Documenting Java Code</h1><pre><code class="language-java">Documentation for java code is often generated using javadoc. Javadoc was created by Sun Microsystems for the purpose of generating API documentation in HTML format from java source code. Using the HTML format gives the convenience of being able to hyperlink related documents together. Section 6.1: Building Javadocs From the Command Line Many IDEs provide support for generating HTML from Javadocs automatically; some build tools (Maven and Gradle, for example) also have plugins that can handle the HTML creation. However, these tools are not required to generate the Javadoc HTML; this can be done using the command line javadoc tool. The most basic usage of the tool is: javadoc JavaFile.java Which will generate HTML from the Javadoc comments in JavaFile.java. A more practical use of the command line tool, which will recursively read all java files in [source-directory], create documentation for [package.name] and all sub-packages, and place the generated HTML in the [docsdirectory] is: javadoc -d [docs-directory] -subpackages -sourcepath [source-directory] [package.name] Section 6.2: Class Documentation All Javadoc comments begin with a block comment followed by an asterisk (/\*\*) and end when the block comment does (\*/). Optionally, each line can begin with arbitrary whitespace and a single asterisk; these are ignored when the documentation files are generated. /\*\* \* Brief summary of this class, ending with a period. \* \* It is common to leave a blank line between the summary and further details. \* The summary (everything before the first period) is used in the class or package \* overview section. \* \* The following inline tags can be used (not an exhaustive list): \* {\@link some.other.class.Documentation} for linking to other docs or symbols \* {\@link some.other.class.Documentation Some Display Name} the link&#x27;s appearance can be \* customized by adding a display name after the doc or symbol locator \* {\@code code goes here} for formatting as code \* {\@literal &lt;&gt;[]()foo} for interpreting literal text without converting to HTML markup \* or other tags. \* \* Optionally, the following tags may be used at the end of class documentation \* (not an exhaustive list): \* \* \@author John Doe \* \@version 1.0 \* \@since 5/10/15 \* \@see some.other.class.Documentation \* \@deprecated This class has been replaced by some.other.package.BetterFileReader \* GoalKicker.com -- Java® Notes for Professionals 19 \* You can also have custom tags for displaying additional information. \* Using the \@custom. tag and the -tag custom.:htmltag:&quot;context&quot; \* command line option, you can create a custom tag. \* \* Example custom tag and generation: \* \@custom.updated 2.0 \* Javadoc flag: -tag custom.updated:a:&quot;Updated in version:&quot; \* The above flag will display the value of \@custom.updated under &quot;Updated in version:&quot; \* \*/ public class FileReader { } The same tags and format used for Classes can be used for Enums and Interfaces as well. Section 6.3: Method Documentation All Javadoc comments begin with a block comment followed by an asterisk (/\*\*) and end when the block comment does (\*/). Optionally, each line can begin with arbitrary whitespace and a single asterisk; these are ignored when the documentation files are generated. /\*\* \* Brief summary of method, ending with a period. \* \* Further description of method and what it does, including as much detail as is \* appropriate. Inline tags such as \* {\@code code here}, {\@link some.other.Docs}, and {\@literal text here} can be used. \* \* If a method overrides a superclass method, {\@inheritDoc} can be used to copy the \* documentation \* from the superclass method \* \* \@param stream Describe this parameter. Include as much detail as is appropriate \* Parameter docs are commonly aligned as here, but this is optional. \* As with other docs, the documentation before the first period is \* used as a summary. \* \* \@return Describe the return values. Include as much detail as is appropriate \* Return type docs are commonly aligned as here, but this is optional. \* As with other docs, the documentation before the first period is used as a \* summary. \* \* \@throws IOException Describe when and why this exception can be thrown. \* Exception docs are commonly aligned as here, but this is \* optional. \* As with other docs, the documentation before the first period \* is used as a summary. \* Instead of \@throws, \@exception can also be used. \* \* \@since 2.1.0 \* \@see some.other.class.Documentation \* \@deprecated Describe why this method is outdated. A replacement can also be specified. \*/ public String[] read(InputStream stream) throws IOException { return null; } GoalKicker.com -- Java® Notes for Professionals 20 Section 6.4: Package Documentation Version ≥ Java SE 5 It is possible to create package-level documentation in Javadocs using a file called package-info.java. This file must be formatted as below. Leading whitespace and asterisks optional, typically present in each line for formatting reason /\*\* \* Package documentation goes here; any documentation before the first period will \* be used as a summary. \* \* It is common practice to leave a blank line between the summary and the rest \* of the documentation; use this space to describe the package in as much detail \* as is appropriate. \* \* Inline tags such as {\@code code here}, {\@link reference.to.other.Documentation}, \* and {\@literal text here} can be used in this documentation. \*/ package com.example.foo; // The rest of the file must be empty. In the above case, you must put this file package-info.java inside the folder of the Java package com.example.foo. Section 6.5: Links Linking to other Javadocs is done with the \@link tag: /\*\* \* You can link to the javadoc of an already imported class using {\@link ClassName}. \* \* You can also use the fully-qualified name, if the class is not already imported: \* {\@link some.other.ClassName} \* \* You can link to members (fields or methods) of a class like so: \* {\@link ClassName\#someMethod()} \* {\@link ClassName\#someMethodWithParameters(int, String)} \* {\@link ClassName\#someField} \* {\@link \#someMethodInThisClass()} - used to link to members in the current class \* \* You can add a label to a linked javadoc like so: \* {\@link ClassName\#someMethod() link text} \*/ GoalKicker.com -- Java® Notes for Professionals 21 With the \@see tag you can add elements to the See also section. Like \@param or \@return the place where they appear is not relevant. The spec says you should write it after \@return. /\*\* \* This method has a nice explanation but you might found further \* information at the bottom. \* \* \@see ClassName\#someMethod() \*/ If you want to add links to external resources you can just use the HTML tag. You can use it inline anywhere or inside both \@link and \@see tags. /\*\* \* Wondering how this works? You might want \* to check this [great service](http://stackoverflow.com/). \* \* \@see [Stack Overflow](http://stackoverflow.com/) \*/ Section 6.6: Code snippets inside documentation The canonical way of writing code inside documentation is with the {\@code } construct. If you have multiline code wrap inside
</code></pre><p>. /<!-- -->*<!-- -->*<!-- --> <!-- -->*<!-- --> The Class TestUtils. <!-- -->*</p><p>*<!-- --> This is an {\@code inline(&quot;code example&quot;)}. <!-- -->*</p><p>*<!-- --> You should wrap it in pre tags when writing multiline code. <!-- -->*</p><p>{\@code</p><p>*<!-- --> Example example1 = new FirstLineExample();</p><p>*<!-- --> example1.butYouCanHaveMoreThanOneLine();</p><p>*<!-- --> }</p><p>*</p><p>*<!-- --> Thanks for reading. <!-- -->*<!-- -->/ class TestUtils { Sometimes you may need to put some complex code inside the javadoc comment. The @ sign is specially problematic. The use of the old tag alongside the {\@literal } construct solves the problem. /<!-- -->*<!-- -->*<!-- --> <!-- -->*<!-- --> Usage: <!-- -->*</p><p>*<!-- --> class SomethingTest {</p><p>*<!-- --> {\@literal @}Rule</p><p>*<!-- --> public SingleTestRule singleTestRule = new SingleTestRule(&quot;test1&quot;);</p><p>*</p><p>*<!-- --> {\@literal @}Test</p><p>*<!-- --> public void test1() {</p><p>*<!-- --> // only this test will be executed</p><p>*<!-- --> }</p><p>*</p><p>*<!-- --> <!-- -->.<!-- -->..</p><p>*<!-- --> }</p><p>*</p><p>*<!-- -->/ class SingleTestRule implements TestRule { } Section 6.7: Field Documentation All Javadoc comments begin with a block comment followed by an asterisk (/<!-- -->*<!-- -->*<!-- -->) and end when the block comment does (<!-- -->*<!-- -->/). Optionally, each line can begin with arbitrary whitespace and a single asterisk; these are ignored when the documentation files are generated. /<!-- -->*<!-- -->*<!-- --> <!-- -->*<!-- --> Fields can be documented as well. <!-- -->*<!-- --> <!-- -->*<!-- --> As with other javadocs, the documentation before the first period is used as a <!-- -->*<!-- --> summary, and is usually separated from the rest of the documentation by a blank <!-- -->*<!-- --> line. <!-- -->*<!-- --> <!-- -->*<!-- --> Documentation for fields can use inline tags, such as: <!-- -->*<!-- --> {\@code code here} <!-- -->*<!-- --> {\@literal text here} <!-- -->*<!-- --> {\@link other.docs.Here} <!-- -->*<!-- --> <!-- -->*<!-- --> Field documentation can also make use of the following tags: <!-- -->*<!-- --> <!-- -->*<!-- --> \@since 2.1.0 <!-- -->*<!-- --> \@see some.other.class.Documentation <!-- -->*<!-- --> \@deprecated Describe why this field is outdated <!-- -->*<!-- -->/ public static final String CONSTANT_STRING = &quot;foo&quot;; Section 6.8: Inline Code Documentation Apart from the Javadoc documentation code can be documented inline. Single Line comments are started by // and may be positioned after a statement on the same line, but not before. public void method() { //single line comment someMethodCall(); //single line comment after statement } Multi-Line comments are defined between /<!-- -->*<!-- --> and <!-- -->*<!-- -->/. They can span multiple lines and may even been positioned between statements. public void method(Object object) { /<!-- -->*<!-- --> GoalKicker.com -- Java® Notes for Professionals 23 multi line comment <!-- -->*<!-- -->/ object/<!-- -->*<!-- -->inner-line-comment<!-- -->*<!-- -->/.method(); } JavaDocs are a special form of multi-line comments, starting with /<!-- -->*<!-- -->*<!-- -->. As too many inline comments may decrease readability of code, they should be used sparsely in case the code isn&#x27;t self-explanatory enough or the design decision isn&#x27;t obvious. An additional use case for single-line comments is the use of TAGs, which are short, convention driven keywords. Some development environments recognize certain conventions for such single-comments. Common examples are //TODO //FIXME Or issue references, i.e. for Jira //PRJ-1234</p><h1>12 Basic I/O</h1><p>This lesson covers the Java platform classes used for basic I/O. It first focuses on <em>I/O Streams</em>, a powerful concept that greatly simplifies I/O operations. The lesson also looks at serialization, which lets a program write whole objects out to streams and read them back again. Then the lesson looks at file I/O and file system operations, including random access files.</p><p>Most of the classes covered in the I/O Streams section are in the java.io package. Most of the classes covered in the File I/O section are in the java.nio.file package.</p><h2><a href="https://docs.oracle.com/javase/tutorial/essential/io/streams.html">12.1 I/O Streams</a></h2><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/bytestreams.html">Byte Streams</a> handle I/O of raw binary data.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/charstreams.html">Character Streams</a> handle I/O of character data, automatically handling translation to and from the local character set.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/buffers.html">Buffered Streams</a> optimize input and output by reducing the number of calls to the native API.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/scanfor.html">Scanning and Formatting</a> allows a program to read and write formatted text.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/cl.html">I/O from the Command Line</a> describes the Standard Streams and the Console object.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/datastreams.html">Data Streams</a> handle binary I/O of primitive data type and String values.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/objectstreams.html">Object Streams</a> handle binary I/O of objects.</li></ul><h2><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileio.html">12.2 File I/O (Featuring NIO.2)</a></h2><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/path.html">What is a Path?</a> examines the concept of a path on a file system.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathClass.html">The Path Class</a> introduces the cornerstone class of the java.nio.file package.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html">Path Operations</a> looks at methods in the Path class that deal with syntactic operations.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html">File Operations</a> introduces concepts common to many of the file I/O methods.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/check.html">Checking a File or Directory</a> shows how to check a file&#x27;s existence and its level of accessibility.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/delete.html">Deleting a File or Directory</a>.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/copy.html">Copying a File or Directory</a>.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/move.html">Moving a File or Directory</a>.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html">Managing Metadata</a> explains how to read and set file attributes.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html">Reading, Writing and Creating Files</a> shows the stream and channel methods for reading and writing files.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/rafs.html">Random Access Files</a> shows how to read or write files in a non-sequentially manner.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html">Creating and Reading Directories</a> covers API specific to directories, such as how to list a directory&#x27;s contents.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/links.html">Links, Symbolic or Otherwise</a> covers issues specific to symbolic and hard links.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html">Walking the File Tree</a> demonstrates how to recursively visit each file and directory in a file tree.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/find.html">Finding Files</a> shows how to search for files using pattern matching.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html">Watching a Directory for Changes</a> shows how to use the watch service to detect files that are added, removed or updated in one or more directories.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/misc.html">Other Useful Methods</a> covers important API that didn&#x27;t fit elsewhere in the lesson.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/legacy.html">Legacy File I/O Code</a> shows how to leverage Path functionality if you have older code using the java.io.File class. A table mapping java.io.File API to java.nio.file API is provided.</li></ul><h2>12.3 I/O Streams</h2><p>An <em>I/O Stream</em> represents an input source or an output destination. A stream can represent many different kinds of sources and destinations, including disk files, devices, other programs, and memory arrays.</p><p>Streams support many different kinds of data, including simple bytes, primitive data types, localized characters, and objects. Some streams simply pass on data; others manipulate and transform the data in useful ways.</p><p>No matter how they work internally, all streams present the same simple model to programs that use them: A stream is a sequence of data. A program uses an <em>input stream</em> to read data from a source, one item at a time:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8vAwAI+AL89h3njgAAAABJRU5ErkJggg==" alt="Reading information into a program."/></p><p>Reading information into a program.</p><p>A program uses an <em>output stream</em> to write data to a destination, one item at time:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8XAwAI8gL5EGx94gAAAABJRU5ErkJggg==" alt="Writing information from a program."/></p><p>Writing information from a program.</p><p>In this lesson, we&#x27;ll see streams that can handle all kinds of data, from primitive values to advanced objects.</p><p>The data source and data destination pictured above can be anything that holds, generates, or consumes data. Obviously this includes disk files, but a source or destination can also be another program, a peripheral device, a network socket, or an array.</p><p>In the next section, we&#x27;ll use the most basic kind of streams, byte streams, to demonstrate the common operations of Stream I/O. For sample input, we&#x27;ll use the example file <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/xanadu.txt">xanadu.txt</a>, which contains the following verse:</p><p>In Xanadu did Kubla Khan</p><p>A stately pleasure-dome decree:</p><p>Where Alph, the sacred river, ran</p><p>Through caverns measureless to man</p><p>Down to a sunless sea.</p><h2>12.4 Byte Streams</h2><p>Programs use <em>byte streams</em> to perform input and output of 8-bit bytes. All byte stream classes are descended from <a href="https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html">InputStream</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html">OutputStream</a>.</p><p>There are many byte stream classes. To demonstrate how byte streams work, we&#x27;ll focus on the file I/O byte streams, <a href="https://docs.oracle.com/javase/8/docs/api/java/io/FileInputStream.html">FileInputStream</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/io/FileOutputStream.html">FileOutputStream</a>. Other kinds of byte streams are used in much the same way; they differ mainly in the way they are constructed.</p><h3>12.4.1 Using Byte Streams</h3><p>We&#x27;ll explore FileInputStream and FileOutputStream by examining an example program named <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/CopyBytes.java">CopyBytes</a>, which uses byte streams to copy xanadu.txt, one byte at a time.</p><pre><code class="language-java">import java.io.FileInputStream;

import java.io.FileOutputStream;

import java.io.IOException;

public class CopyBytes {

public static void main(String[] args) throws IOException {

FileInputStream in = null;

FileOutputStream out = null;

try {

in = new FileInputStream(&quot;xanadu.txt&quot;);

out = new FileOutputStream(&quot;outagain.txt&quot;);

int c;

while ((c = in.read()) != -1) {

out.write(c);

}

} finally {

if (in != null) {

in.close();

}

if (out != null) {

out.close();

}

}

}

}
</code></pre><p>CopyBytes spends most of its time in a simple loop that reads the input stream and writes the output stream, one byte at a time, as shown in the following figure.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8hAwAIwALgmFt0tAAAAABJRU5ErkJggg==" alt="Simple byte stream input and output."/></p><p>Simple byte stream input and output.</p><h3>12.4.2 Always Close Streams</h3><p>Closing a stream when it&#x27;s no longer needed is very important --- so important that CopyBytes uses a finally block to guarantee that both streams will be closed even if an error occurs. This practice helps avoid serious resource leaks.</p><p>One possible error is that CopyBytes was unable to open one or both files. When that happens, the stream variable corresponding to the file never changes from its initial null value. That&#x27;s why CopyBytes makes sure that each stream variable contains an object reference before invoking close.</p><h3>12.4.3 When Not to Use Byte Streams</h3><p>CopyBytes seems like a normal program, but it actually represents a kind of low-level I/O that you should avoid. Since xanadu.txt contains character data, the best approach is to use <a href="https://docs.oracle.com/javase/tutorial/essential/io/charstreams.html">character streams</a>, as discussed in the next section. There are also streams for more complicated data types. Byte streams should only be used for the most primitive I/O.</p><p>So why talk about byte streams? Because all other stream types are built on byte streams.</p><h2>12.5 Character Streams</h2><p>The Java platform stores character values using Unicode conventions. Character stream I/O automatically translates this internal format to and from the local character set. In Western locales, the local character set is usually an 8-bit superset of ASCII.</p><p>For most applications, I/O with character streams is no more complicated than I/O with byte streams. Input and output done with stream classes automatically translates to and from the local character set. A program that uses character streams in place of byte streams automatically adapts to the local character set and is ready for internationalization --- all without extra effort by the programmer.</p><p>If internationalization isn&#x27;t a priority, you can simply use the character stream classes without paying much attention to character set issues. Later, if internationalization becomes a priority, your program can be adapted without extensive recoding. See the <a href="https://docs.oracle.com/javase/tutorial/i18n/index.html">Internationalization</a> trail for more information.</p><h3>12.5.1 Using Character Streams</h3><p>All character stream classes are descended from <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html">Reader</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Writer.html">Writer</a>. As with byte streams, there are character stream classes that specialize in file I/O: <a href="https://docs.oracle.com/javase/8/docs/api/java/io/FileReader.html">FileReader</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/io/FileWriter.html">FileWriter</a>. The<a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/CopyCharacters.java">CopyCharacters</a> example illustrates these classes.</p><pre><code class="language-java">import java.io.FileReader;

import java.io.FileWriter;

import java.io.IOException;

public class CopyCharacters {

public static void main(String[] args) throws IOException {

FileReader inputStream = null;

FileWriter outputStream = null;

try {

inputStream = new FileReader(&quot;xanadu.txt&quot;);

outputStream = new FileWriter(&quot;characteroutput.txt&quot;);

int c;

while ((c = inputStream.read()) != -1) {

outputStream.write(c);

}

} finally {

if (inputStream != null) {

inputStream.close();

}

if (outputStream != null) {

outputStream.close();

}

}

}

}
</code></pre><p>CopyCharacters is very similar to CopyBytes. The most important difference is that CopyCharacters uses FileReader and FileWriter for input and output in place of FileInputStream and FileOutputStream. Notice that both CopyBytes and CopyCharacters use an int variable to read to and write from. However, in CopyCharacters, the intvariable holds a character value in its last 16 bits; in CopyBytes, the int variable holds a byte value in its last 8 bits.</p><h4>12.5.1.1 Character Streams that Use Byte Streams</h4><p>Character streams are often &quot;wrappers&quot; for byte streams. The character stream uses the byte stream to perform the physical I/O, while the character stream handles translation between characters and bytes. FileReader, for example, uses FileInputStream, while FileWriter uses FileOutputStream.</p><p>There are two general-purpose byte-to-character &quot;bridge&quot; streams: <a href="https://docs.oracle.com/javase/8/docs/api/java/io/InputStreamReader.html">InputStreamReader</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/io/OutputStreamWriter.html">OutputStreamWriter</a>. Use them to create character streams when there are no prepackaged character stream classes that meet your needs. The <a href="https://docs.oracle.com/javase/tutorial/networking/sockets/readingWriting.html">sockets lesson</a> in the <a href="https://docs.oracle.com/javase/tutorial/networking/index.html">networking trail</a> shows how to create character streams from the byte streams provided by socket classes.</p><h3>12.5.2 Line-Oriented I/O</h3><p>Character I/O usually occurs in bigger units than single characters. One common unit is the line: a string of characters with a line terminator at the end. A line terminator can be a carriage-return/line-feed sequence (&quot;<!-- -->\<!-- -->r<!-- -->\<!-- -->n&quot;), a single carriage-return (&quot;<!-- -->\<!-- -->r&quot;), or a single line-feed (&quot;<!-- -->\<!-- -->n&quot;). Supporting all possible line terminators allows programs to read text files created on any of the widely used operating systems.</p><p>Let&#x27;s modify the CopyCharacters example to use line-oriented I/O. To do this, we have to use two classes we haven&#x27;t seen before, <a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html">BufferedReader</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html">PrintWriter</a>. We&#x27;ll explore these classes in greater depth in <a href="https://docs.oracle.com/javase/tutorial/essential/io/buffers.html">Buffered I/O</a> and <a href="https://docs.oracle.com/javase/tutorial/essential/io/formatting.html">Formatting</a>. Right now, we&#x27;re just interested in their support for line-oriented I/O.</p><p>The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/CopyLines.java">CopyLines</a> example invokes BufferedReader.readLine and PrintWriter.println to do input and output one line at a time.</p><pre><code class="language-java">import java.io.FileReader;

import java.io.FileWriter;

import java.io.BufferedReader;

import java.io.PrintWriter;

import java.io.IOException;

public class CopyLines {

public static void main(String[] args) throws IOException {

BufferedReader inputStream = null;

PrintWriter outputStream = null;

try {

inputStream = new BufferedReader(new FileReader(&quot;xanadu.txt&quot;));

outputStream = new PrintWriter(new FileWriter(&quot;characteroutput.txt&quot;));

String l;

while ((l = inputStream.readLine()) != null) {

outputStream.println(l);

}

} finally {

if (inputStream != null) {

inputStream.close();

}

if (outputStream != null) {

outputStream.close();

}

}

}

}
</code></pre><p>Invoking readLine returns a line of text with the line. CopyLines outputs each line using println, which appends the line terminator for the current operating system. This might not be the same line terminator that was used in the input file.</p><p>There are many ways to structure text input and output beyond characters and lines. For more information, see <a href="https://docs.oracle.com/javase/tutorial/essential/io/scanfor.html">Scanning and Formatting</a>.</p><h2>12.6 Buffered Streams</h2><p>Most of the examples we&#x27;ve seen so far use <em>unbuffered</em> I/O. This means each read or write request is handled directly by the underlying OS. This can make a program much less efficient, since each such request often triggers disk access, network activity, or some other operation that is relatively expensive.</p><p>To reduce this kind of overhead, the Java platform implements <em>buffered</em> I/O streams. Buffered input streams read data from a memory area known as a <em>buffer</em>; the native input API is called only when the buffer is empty. Similarly, buffered output streams write data to a buffer, and the native output API is called only when the buffer is full.</p><p>A program can convert an unbuffered stream into a buffered stream using the wrapping idiom we&#x27;ve used several times now, where the unbuffered stream object is passed to the constructor for a buffered stream class. Here&#x27;s how you might modify the constructor invocations in the CopyCharacters example to use buffered I/O:</p><p>inputStream = new BufferedReader(new FileReader(&quot;xanadu.txt&quot;));</p><p>outputStream = new BufferedWriter(new FileWriter(&quot;characteroutput.txt&quot;));</p><p>There are four buffered stream classes used to wrap unbuffered streams: <a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedInputStream.html">BufferedInputStream</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedOutputStream.html">BufferedOutputStream</a> create buffered byte streams, while <a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html">BufferedReader</a> and<a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedWriter.html">BufferedWriter</a> create buffered character streams.</p><h3>12.6.1 Flushing Buffered Streams</h3><p>It often makes sense to write out a buffer at critical points, without waiting for it to fill. This is known as <em>flushing</em> the buffer.</p><p>Some buffered output classes support <em>autoflush</em>, specified by an optional constructor argument. When autoflush is enabled, certain key events cause the buffer to be flushed. For example, an autoflush PrintWriter object flushes the buffer on every invocation of println or format. See <a href="https://docs.oracle.com/javase/tutorial/essential/io/formatting.html">Formatting</a> for more on these methods.</p><p>To flush a stream manually, invoke its flush method. The flush method is valid on any output stream, but has no effect unless the stream is buffered.</p><h2>12.7 Scanning and Formatting</h2><p>Programming I/O often involves translating to and from the neatly formatted data humans like to work with. To assist you with these chores, the Java platform provides two APIs. The <a href="https://docs.oracle.com/javase/tutorial/essential/io/scanning.html">scanner</a> API breaks input into individual tokens associated with bits of data. The <a href="https://docs.oracle.com/javase/tutorial/essential/io/formatting.html">formatting</a> API assembles data into nicely formatted, human-readable form.</p><h3>12.7.1 Scanning</h3><p>Objects of type <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html">Scanner</a> are useful for breaking down formatted input into tokens and translating individual tokens according to their data type.</p><h4>12.7.1.1 Breaking Input into Tokens</h4><p>By default, a scanner uses white space to separate tokens. (White space characters include blanks, tabs, and line terminators. For the full list, refer to the documentation for<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isWhitespace-char-">Character.isWhitespace</a>.) To see how scanning works, let&#x27;s look at <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/ScanXan.java">ScanXan</a>, a program that reads the individual words in xanadu.txt and prints them out, one per line.</p><pre><code class="language-java">import java.io.*;

import java.util.Scanner;

public class ScanXan {

public static void main(String[] args) throws IOException {

Scanner s = null;

try {

s = new Scanner(new BufferedReader(new FileReader(&quot;xanadu.txt&quot;)));

while (s.hasNext()) {

System.out.println(s.next());

}

} finally {

if (s != null) {

s.close();

}

}

}

}
</code></pre><p>Notice that ScanXan invokes Scanner&#x27;s close method when it is done with the scanner object. Even though a scanner is not a stream, you need to close it to indicate that you&#x27;re done with its underlying stream.</p><p>The output of ScanXan looks like this:</p><p>In</p><p>Xanadu</p><p>did</p><p>Kubla</p><p>Khan</p><p>A</p><p>stately</p><p>pleasure-dome</p><p>.<!-- -->..</p><p>To use a different token separator, invoke useDelimiter(), specifying a regular expression. For example, suppose you wanted the token separator to be a comma, optionally followed by white space. You would invoke,</p><pre><code class="language-java">s.useDelimiter(&quot;,\\\\s\*&quot;);
</code></pre><h4>12.7.1.2 Translating Individual Tokens</h4><p>The ScanXan example treats all input tokens as simple String values. Scanner also supports tokens for all of the Java language&#x27;s primitive types (except for char), as well as BigIntegerand BigDecimal. Also, numeric values can use thousands separators. Thus, in a US locale, Scanner correctly reads the string &quot;32,767&quot; as representing an integer value.</p><p>We have to mention the locale, because thousands separators and decimal symbols are locale specific. So, the following example would not work correctly in all locales if we didn&#x27;t specify that the scanner should use the US locale. That&#x27;s not something you usually have to worry about, because your input data usually comes from sources that use the same locale as you do. But this example is part of the Java Tutorial and gets distributed all over the world.</p><p>The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/ScanSum.java">ScanSum</a> example reads a list of double values and adds them up. Here&#x27;s the source:</p><pre><code class="language-java">import java.io.FileReader;

import java.io.BufferedReader;

import java.io.IOException;

import java.util.Scanner;

import java.util.Locale;

public class ScanSum {

public static void main(String[] args) throws IOException {

Scanner s = null;

double sum = 0;

try {

s = new Scanner(new BufferedReader(new FileReader(&quot;usnumbers.txt&quot;)));

s.useLocale(Locale.US);

while (s.hasNext()) {

if (s.hasNextDouble()) {

sum += s.nextDouble();

} else {

s.next();

}

}

} finally {

s.close();

}

System.out.println(sum);

}

}
</code></pre><p>And here&#x27;s the sample input file, <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/usnumbers.txt">usnumbers.txt</a></p><p>8.5</p><p>32,767</p><p>3.14159</p><p>1,000,000.1</p><p>The output string is &quot;1032778.74159&quot;. The period will be a different character in some locales, because System.out is a PrintStream object, and that class doesn&#x27;t provide a way to override the default locale. We could override the locale for the whole program --- or we could just use formatting, as described in the next topic, <a href="https://docs.oracle.com/javase/tutorial/essential/io/formatting.html">Formatting</a>.</p><h3>12.7.2 Formatting</h3><p>Stream objects that implement formatting are instances of either <a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html">PrintWriter</a>, a character stream class, or <a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html">PrintStream</a>, a byte stream class.</p><p><strong>Note:</strong> The only PrintStream objects you are likely to need are <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#out">System.out</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#err">System.err</a>. (See <a href="https://docs.oracle.com/javase/tutorial/essential/io/cl.html">I/O from the Command Line</a> for more on these objects.) When you need to create a formatted output stream, instantiate PrintWriter, not PrintStream.</p><p>Like all byte and character stream objects, instances of PrintStream and PrintWriter implement a standard set of write methods for simple byte and character output. In addition, both PrintStream and PrintWriter implement the same set of methods for converting internal data into formatted output. Two levels of formatting are provided:</p><ul><li>print and println format individual values in a standard way.</li><li>format formats almost any number of values based on a format string, with many options for precise formatting.</li></ul><h4>12.7.2.1 The print and println Methods</h4><p>Invoking print or println outputs a single value after converting the value using the appropriate toString method. We can see this in the <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Root.java">Root</a> example:</p><pre><code class="language-java">public class Root {

public static void main(String[] args) {

int i = 2;

double r = Math.sqrt(i);

System.out.print(&quot;The square root of &quot;);

System.out.print(i);

System.out.print(&quot; is &quot;);

System.out.print(r);

System.out.println(&quot;.&quot;);

i = 5;

r = Math.sqrt(i);

System.out.println(&quot;The square root of &quot; + i + &quot; is &quot; + r + &quot;.&quot;);

}

}
</code></pre><p>Here is the output of Root:
The square root of 2 is 1.4142135623730951.
The square root of 5 is 2.23606797749979.</p><p>The i and r variables are formatted twice: the first time using code in an overload of print, the second time by conversion code automatically generated by the Java compiler, which also utilizes toString. You can format any value this way, but you don&#x27;t have much control over the results.</p><h4>12.7.2.2 The format Method</h4><p>The format method formats multiple arguments based on a <em>format string</em>. The format string consists of static text embedded with <em>format specifiers</em>; except for the format specifiers, the format string is output unchanged.</p><p>Format strings support many features. In this tutorial, we&#x27;ll just cover some basics. For a complete description, see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">format string syntax</a> in the API specification.</p><p>The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Root2.java">Root2</a> example formats two values with a single format invocation:</p><pre><code class="language-java">public class Root2 {

public static void main(String[] args) {

int i = 2;

double r = Math.sqrt(i);

System.out.format(&quot;The square root of %d is %f.%n&quot;, i, r);

}

}
</code></pre><p>Here is the output:
The square root of 2 is 1.414214.</p><p>Like the three used in this example, all format specifiers begin with a % and end with a 1- or 2-character <em>conversion</em> that specifies the kind of formatted output being generated. The three conversions used here are:</p><ul><li>d formats an integer value as a decimal value.</li><li>f formats a floating point value as a decimal value.</li><li>n outputs a platform-specific line terminator.</li></ul><p>Here are some other conversions:</p><ul><li>x formats an integer as a hexadecimal value.</li><li>s formats any value as a string.</li><li>tB formats an integer as a locale-specific month name.</li></ul><p>There are many other conversions.</p><p><strong>Note:</strong> </p><p>Except for %% and %n, all format specifiers must match an argument. If they don&#x27;t, an exception is thrown.</p><p>In the Java programming language, the <!-- -->\<!-- -->n escape always generates the linefeed character (<!-- -->\<!-- -->u000A). Don&#x27;t use <!-- -->\<!-- -->n unless you specifically want a linefeed character. To get the correct line separator for the local platform, use %n.</p><p>In addition to the conversion, a format specifier can contain several additional elements that further customize the formatted output. Here&#x27;s an example, <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Format.java">Format</a>, that uses every possible kind of element.</p><pre><code class="language-java">public class Format {

public static void main(String[] args) {

System.out.format(&quot;%f, %1\$+020.10f %n&quot;, Math.PI);

}

}
</code></pre><p>Here&#x27;s the output:
3.141593, +00000003.1415926536</p><p>The additional elements are all optional. The following figure shows how the longer specifier breaks down into elements.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//89AwAI3ALuyqH1HQAAAABJRU5ErkJggg==" alt="Elements of a format specifier"/></p><p>Elements of a Format Specifier.</p><p>The elements must appear in the order shown. Working from the right, the optional elements are:</p><ul><li><strong>Precision</strong>. For floating point values, this is the mathematical precision of the formatted value. For s and other general conversions, this is the maximum width of the formatted value; the value is right-truncated if necessary.</li><li><strong>Width</strong>. The minimum width of the formatted value; the value is padded if necessary. By default the value is left-padded with blanks.</li><li><strong>Flags</strong> specify additional formatting options. In the Format example, the + flag specifies that the number should always be formatted with a sign, and the 0 flag specifies that 0 is the padding character. Other flags include - (pad on the right) and , (format number with locale-specific thousands separators). Note that some flags cannot be used with certain other flags or with certain conversions.</li><li>The <strong>Argument Index</strong> allows you to explicitly match a designated argument. You can also specify &lt; to match the same argument as the previous specifier. Thus the example could have said: System.out.format(&quot;%f, %&lt;+020.10f %n&quot;, Math.PI);</li></ul><h2>12.8 I/O from the Command Line</h2><p>A program is often run from the command line and interacts with the user in the command line environment. The Java platform supports this kind of interaction in two ways: through the Standard Streams and through the Console.</p><h3>12.8.1 Standard Streams</h3><p>Standard Streams are a feature of many operating systems. By default, they read input from the keyboard and write output to the display. They also support I/O on files and between programs, but that feature is controlled by the command line interpreter, not the program.</p><p>The Java platform supports three Standard Streams: <em>Standard Input</em>, accessed through System.in; <em>Standard Output</em>, accessed through System.out; and <em>Standard Error</em>, accessed through System.err. These objects are defined automatically and do not need to be opened. Standard Output and Standard Error are both for output; having error output separately allows the user to divert regular output to a file and still be able to read error messages. For more information, refer to the documentation for your command line interpreter.</p><p>You might expect the Standard Streams to be character streams, but, for historical reasons, they are byte streams. System.out and System.err are defined as <a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html">PrintStream</a> objects. Although it is technically a byte stream, PrintStream utilizes an internal character stream object to emulate many of the features of character streams.</p><p>By contrast, System.in is a byte stream with no character stream features. To use Standard Input as a character stream, wrap System.in in InputStreamReader.</p><p>InputStreamReader cin = new InputStreamReader(System.in);</p><h3>12.8.2 The Console</h3><p>A more advanced alternative to the Standard Streams is the Console. This is a single, predefined object of type <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Console.html">Console</a> that has most of the features provided by the Standard Streams, and others besides. The Console is particularly useful for secure password entry. The Console object also provides input and output streams that are true character streams, through its reader and writer methods.</p><p>Before a program can use the Console, it must attempt to retrieve the Console object by invoking System.console(). If the Console object is available, this method returns it. If System.console returns NULL, then Console operations are not permitted, either because the OS doesn&#x27;t support them or because the program was launched in a noninteractive environment.</p><p>The Console object supports secure password entry through its readPassword method. This method helps secure password entry in two ways. First, it suppresses echoing, so the password is not visible on the user&#x27;s screen. Second, readPassword returns a character array, not a String, so the password can be overwritten, removing it from memory as soon as it is no longer needed.</p><p>The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Password.java">Password</a> example is a prototype program for changing a user&#x27;s password. It demonstrates several Console methods.</p><pre><code class="language-java">import java.io.Console;

import java.util.Arrays;

import java.io.IOException;

public class Password {

public static void main (String args[]) throws IOException {

Console c = System.console();

if (c == null) {

System.err.println(&quot;No console.&quot;);

System.exit(1);

}

String login = c.readLine(&quot;Enter your login: &quot;);

char [] oldPassword = c.readPassword(&quot;Enter your old password: &quot;);

if (verify(login, oldPassword)) {

boolean noMatch;

do {

char [] newPassword1 = c.readPassword(&quot;Enter your new password: &quot;);

char [] newPassword2 = c.readPassword(&quot;Enter new password again: &quot;);

noMatch = ! Arrays.equals(newPassword1, newPassword2);

if (noMatch) {

c.format(&quot;Passwords don&#x27;t match. Try again.%n&quot;);

} else {

change(login, newPassword1);

c.format(&quot;Password for %s changed.%n&quot;, login);

}

Arrays.fill(newPassword1, &#x27; &#x27;);

Arrays.fill(newPassword2, &#x27; &#x27;);

} while (noMatch);

}

Arrays.fill(oldPassword, &#x27; &#x27;);

}

// Dummy change method.

static boolean verify(String login, char[] password) {

// This method always returns

// true in this example.

// Modify this method to verify

// password according to your rules.

return true;

}

// Dummy change method.

static void change(String login, char[] password) {

// Modify this method to change

// password according to your rules.

}

}
</code></pre><p>The Password class follows these steps:</p><ol><li>Attempt to retrieve the Console object. If the object is not available, abort.</li><li>Invoke Console.readLine to prompt for and read the user&#x27;s login name.</li><li>Invoke Console.readPassword to prompt for and read the user&#x27;s existing password.</li><li>Invoke verify to confirm that the user is authorized to change the password. (In this example, verify is a dummy method that always returns true.)</li><li>Repeat the following steps until the user enters the same password twice:<ol><li>Invoke Console.readPassword twice to prompt for and read a new password.</li><li>If the user entered the same password both times, invoke change to change it. (Again, change is a dummy method.)</li><li>Overwrite both passwords with blanks.</li></ol></li><li>Overwrite the old password with blanks.</li></ol><h2>12.9 Data Streams</h2><p>Data streams support binary I/O of primitive data type values (boolean, char, byte, short, int, long, float, and double) as well as String values. All data streams implement either the<a href="https://docs.oracle.com/javase/8/docs/api/java/io/DataInput.html">DataInput</a> interface or the <a href="https://docs.oracle.com/javase/8/docs/api/java/io/DataOutput.html">DataOutput</a> interface. This section focuses on the most widely-used implementations of these interfaces, <a href="https://docs.oracle.com/javase/8/docs/api/java/io/DataInputStream.html">DataInputStream</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/io/DataOutputStream.html">DataOutputStream</a>.</p><p>The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/DataStreams.java">DataStreams</a> example demonstrates data streams by writing out a set of data records, and then reading them in again. Each record consists of three values related to an item on an invoice, as shown in the following table:</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>Order in record</strong></td><td><strong>Data type</strong></td><td><strong>Data description</strong></td><td><strong>Output Method</strong></td><td><strong>Input Method</strong></td><td><strong>Sample Value</strong></td></tr><tr><td>1</td><td>double</td><td>Item price</td><td>DataOutputStream.writeDouble</td><td>DataInputStream.readDouble</td><td>19.99</td></tr><tr><td>2</td><td>int</td><td>Unit count</td><td>DataOutputStream.writeInt</td><td>DataInputStream.readInt</td><td>12</td></tr><tr><td>3</td><td>String</td><td>Item description</td><td>DataOutputStream.writeUTF</td><td>DataInputStream.readUTF</td><td>&quot;Java T-Shirt&quot;</td></tr></tbody></table><p>Let&#x27;s examine crucial code in DataStreams. First, the program defines some constants containing the name of the data file and the data that will be written to it:</p><pre><code class="language-java">static final String dataFile = &quot;invoicedata&quot;;

static final double[] prices = { 19.99, 9.99, 15.99, 3.99, 4.99 };

static final int[] units = { 12, 8, 13, 29, 50 };

static final String[] descs = {

&quot;Java T-shirt&quot;,

&quot;Java Mug&quot;,

&quot;Duke Juggling Dolls&quot;,

&quot;Java Pin&quot;,

&quot;Java Key Chain&quot;

};
</code></pre><p>Then DataStreams opens an output stream. Since a DataOutputStream can only be created as a wrapper for an existing byte stream object, DataStreams provides a buffered file output byte stream.</p><pre><code class="language-java">out = new DataOutputStream(new BufferedOutputStream(

new FileOutputStream(dataFile)));
</code></pre><p>DataStreams writes out the records and closes the output stream.</p><pre><code class="language-java">for (int i = 0; i &lt; prices.length; i ++) {

out.writeDouble(prices[i]);

out.writeInt(units[i]);

out.writeUTF(descs[i]);

}
</code></pre><p>The writeUTF method writes out String values in a modified form of UTF-8. This is a variable-width character encoding that only needs a single byte for common Western characters.</p><p>Now DataStreams reads the data back in again. First it must provide an input stream, and variables to hold the input data. Like DataOutputStream, DataInputStream must be constructed as a wrapper for a byte stream.</p><pre><code class="language-java">in = new DataInputStream(new

BufferedInputStream(new FileInputStream(dataFile)));

double price;

int unit;

String desc;

double total = 0.0;
</code></pre><p>Now DataStreams can read each record in the stream, reporting on the data it encounters.</p><pre><code class="language-java">try {

while (true) {

price = in.readDouble();

unit = in.readInt();

desc = in.readUTF();

System.out.format(&quot;You ordered %d&quot; + &quot; units of %s at \$%.2f%n&quot;,

unit, desc, price);

total += unit \* price;

}

} catch (EOFException e) {

}
</code></pre><p>Notice that DataStreams detects an end-of-file condition by catching <a href="https://docs.oracle.com/javase/8/docs/api/java/io/EOFException.html">EOFException</a>, instead of testing for an invalid return value. All implementations of DataInput methods use EOFException instead of return values.</p><p>Also notice that each specialized write in DataStreams is exactly matched by the corresponding specialized read. It is up to the programmer to make sure that output types and input types are matched in this way: The input stream consists of simple binary data, with nothing to indicate the type of individual values, or where they begin in the stream.</p><p>DataStreams uses one very bad programming technique: it uses floating point numbers to represent monetary values. In general, floating point is bad for precise values. It&#x27;s particularly bad for decimal fractions, because common values (such as 0.1) do not have a binary representation.</p><p>The correct type to use for currency values is <a href="https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html">java.math.BigDecimal</a>. Unfortunately, BigDecimal is an object type, so it won&#x27;t work with data streams. However, BigDecimal <em>will</em> work with object streams, which are covered in the next section.</p><h2>12.10 Object Streams</h2><p>Just as data streams support I/O of primitive data types, object streams support I/O of objects. Most, but not all, standard classes support serialization of their objects. Those that do implement the marker interface <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html">Serializable</a>.</p><p>The object stream classes are <a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInputStream.html">ObjectInputStream</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutputStream.html">ObjectOutputStream</a>. These classes implement <a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInput.html">ObjectInput</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutput.html">ObjectOutput</a>, which are subinterfaces of DataInput and DataOutput. That means that all the primitive data I/O methods covered in <a href="https://docs.oracle.com/javase/tutorial/essential/io/datastreams.html">Data Streams</a> are also implemented in object streams. So an object stream can contain a mixture of primitive and object values. The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/ObjectStreams.java">ObjectStreams</a> example illustrates this. ObjectStreams creates the same application as DataStreams, with a couple of changes. First, prices are now<a href="https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html">BigDecimal</a>objects, to better represent fractional values. Second, a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html">Calendar</a> object is written to the data file, indicating an invoice date.</p><p>If readObject() doesn&#x27;t return the object type expected, attempting to cast it to the correct type may throw a <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassNotFoundException.html">ClassNotFoundException</a>. In this simple example, that can&#x27;t happen, so we don&#x27;t try to catch the exception. Instead, we notify the compiler that we&#x27;re aware of the issue by adding ClassNotFoundException to the main method&#x27;s throws clause.</p><h3>12.10.1 Output and Input of Complex Objects</h3><p>The writeObject and readObject methods are simple to use, but they contain some very sophisticated object management logic. This isn&#x27;t important for a class like Calendar, which just encapsulates primitive values. But many objects contain references to other objects. If readObject is to reconstitute an object from a stream, it has to be able to reconstitute all of the objects the original object referred to. These additional objects might have their own references, and so on. In this situation, writeObject traverses the entire web of object references and writes all objects in that web onto the stream. Thus a single invocation of writeObject can cause a large number of objects to be written to the stream.</p><p>This is demonstrated in the following figure, where writeObject is invoked to write a single object named <strong>a</strong>. This object contains references to objects <strong>b</strong> and <strong>c</strong>, while <strong>b</strong> contains references to <strong>d</strong>and <strong>e</strong>. Invoking writeobject(a) writes not just <strong>a</strong>, but all the objects necessary to reconstitute <strong>a</strong>, so the other four objects in this web are written also. When <strong>a</strong> is read back by readObject, the other four objects are read back as well, and all the original object references are preserved.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8eAwAIugLdx34AmAAAAABJRU5ErkJggg==" alt="I/O of multiple referred-to objects"/></p><p>I/O of multiple referred-to objects</p><p>You might wonder what happens if two objects on the same stream both contain references to a single object. Will they both refer to a single object when they&#x27;re read back? The answer is &quot;yes.&quot; A stream can only contain one copy of an object, though it can contain any number of references to it. Thus if you explicitly write an object to a stream twice, you&#x27;re really writing only the reference twice. For example, if the following code writes an object ob twice to a stream:</p><pre><code class="language-java">Object ob = new Object();
out.writeObject(ob);
out.writeObject(ob);
</code></pre><p>Each writeObject has to be matched by a readObject, so the code that reads the stream back will look something like this:</p><pre><code class="language-java">Object ob1 = in.readObject();
Object ob2 = in.readObject();
</code></pre><p>This results in two variables, ob1 and ob2, that are references to a single object.</p><p>However, if a single object is written to two different streams, it is effectively duplicated --- a single program reading both streams back will see two distinct objects.</p><h2>12.11 File I/O (Featuring NIO.2)</h2><p><strong>Note:</strong> This tutorial reflects the file I/O mechanism introduced in the JDK 7 release. The Java SE 6 version of the File I/O tutorial was brief, but you can download the <a href="http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-tutorials-419421.html#tutorial-2008_03_14-oth-JPR">Java SE Tutorial 2008-03-14</a>version of the tutorial which contains the earlier File I/O content.</p><p>The java.nio.file package and its related package, java.nio.file.attribute, provide comprehensive support for file I/O and for accessing the default file system. Though the API has many classes, you need to focus on only a few entry points. You will see that this API is very intuitive and easy to use.</p><p>The tutorial starts by asking <a href="https://docs.oracle.com/javase/tutorial/essential/io/path.html">what is a path?</a> Then, the <a href="https://docs.oracle.com/javase/tutorial/essential/io/pathClass.html">Path class</a>, the primary entry point for the package, is introduced. Methods in the Path class relating to <a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html">syntactic operations</a> are explained. The tutorial then moves on to the other primary class in the package, the Files class, which contains methods that deal with file operations. First, some concepts common to many <a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html">file operations</a>are introduced. The tutorial then covers methods for <a href="https://docs.oracle.com/javase/tutorial/essential/io/check.html">checking</a>, <a href="https://docs.oracle.com/javase/tutorial/essential/io/delete.html">deleting</a>, <a href="https://docs.oracle.com/javase/tutorial/essential/io/copy.html">copying</a>, and <a href="https://docs.oracle.com/javase/tutorial/essential/io/move.html">moving</a> files.</p><p>The tutorial shows how <a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html">metadata</a> is managed, before moving on to <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html">file I/O</a> and <a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html">directory I/O</a>. <a href="https://docs.oracle.com/javase/tutorial/essential/io/rafs.html">Random access files</a> are explained and issues specific to <a href="https://docs.oracle.com/javase/tutorial/essential/io/links.html">symbolic and hard links</a> are examined.</p><p>Next, some of the very powerful, but more advanced, topics are covered. First, the capability to <a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html">recursively walk the file tree</a> is demonstrated, followed by information about how to <a href="https://docs.oracle.com/javase/tutorial/essential/io/find.html">search for files using wild cards</a>. Next, how to <a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html">watch a directory for changes</a> is explained and demonstrated. Then, <a href="https://docs.oracle.com/javase/tutorial/essential/io/misc.html">methods that didn&#x27;t fit elsewhere</a> are given some attention.</p><p>Finally, if you have file I/O code written prior to the Java SE 7 release, there is a <a href="https://docs.oracle.com/javase/tutorial/essential/io/legacy.html#mapping">map from the old API to the new API</a>, as well as important information about the File.toPath method for developers who would like to <a href="https://docs.oracle.com/javase/tutorial/essential/io/legacy.html#interop">leverage the new API without rewriting existing code</a>.</p><h3>12.11.1 What Is a Path? (And Other File System Facts)</h3><p>A file system stores and organizes files on some form of media, generally one or more hard drives, in such a way that they can be easily retrieved. Most file systems in use today store the files in a tree (or <em>hierarchical</em>) structure. At the top of the tree is one (or more) root nodes. Under the root node, there are files and directories (<em>folders</em> in Microsoft Windows). Each directory can contain files and subdirectories, which in turn can contain files and subdirectories, and so on, potentially to an almost limitless depth.</p><p>This section covers the following:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/path.html#path">What Is a Path?</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/path.html#relative">Relative or Absolute?</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/path.html#symlink">Symbolic Links</a></li></ul><h4>12.11.1.1 What Is a Path?</h4><p>The following figure shows a sample directory tree containing a single root node. Microsoft Windows supports multiple root nodes. Each root node maps to a volume, such as C:<!-- -->\<!-- --> or D:<!-- -->\<!-- -->. The Solaris OS supports a single root node, which is denoted by the slash character, /.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8VAwAI0gLpogk6TwAAAABJRU5ErkJggg==" alt="Sample directory structure"/></p><p>Sample Directory Structure</p><p>A file is identified by its path through the file system, beginning from the root node. For example, the statusReport file in the previous figure is described by the following notation in the Solaris OS:</p><p>/home/sally/statusReport</p><p>In Microsoft Windows, statusReport is described by the following notation:</p><p>C:<!-- -->\<!-- -->home<!-- -->\<!-- -->sally<!-- -->\<!-- -->statusReport</p><p>The character used to separate the directory names (also called the <em>delimiter</em>) is specific to the file system: The Solaris OS uses the forward slash (/), and Microsoft Windows uses the backslash slash (<!-- -->\<!-- -->).</p><h4>12.11.1.2 Relative or Absolute?</h4><p>A path is either <em>relative</em> or <em>absolute</em>. An absolute path always contains the root element and the complete directory list required to locate the file. For example, /home/sally/statusReport is an absolute path. All of the information needed to locate the file is contained in the path string.</p><p>A relative path needs to be combined with another path in order to access a file. For example, joe/foo is a relative path. Without more information, a program cannot reliably locate the joe/foo directory in the file system.</p><h4>12.11.1.3 Symbolic Links</h4><p>File system objects are most typically directories or files. Everyone is familiar with these objects. But some file systems also support the notion of symbolic links. A symbolic link is also referred to as a <em>symlink</em> or a <em>soft link</em>.</p><p>A <em>symbolic link</em> is a special file that serves as a reference to another file. For the most part, symbolic links are transparent to applications, and operations on symbolic links are automatically redirected to the target of the link. (The file or directory being pointed to is called the <em>target</em> of the link.) Exceptions are when a symbolic link is deleted, or renamed in which case the link itself is deleted, or renamed and not the target of the link.</p><p>In the following figure, logFile appears to be a regular file to the user, but it is actually a symbolic link to dir/logs/HomeLogFile. HomeLogFile is the target of the link.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8lAwAI0ALoful75QAAAABJRU5ErkJggg==" alt="Sample symbolic link"/></p><p>Example of a Symbolic Link.</p><p>A symbolic link is usually transparent to the user. Reading or writing to a symbolic link is the same as reading or writing to any other file or directory.</p><p>The phrase <em>resolving a link</em> means to substitute the actual location in the file system for the symbolic link. In the example, resolving logFile yields dir/logs/HomeLogFile.</p><p>In real-world scenarios, most file systems make liberal use of symbolic links. Occasionally, a carelessly created symbolic link can cause a circular reference. A circular reference occurs when the target of a link points back to the original link. The circular reference might be indirect: directory a points to directory b, which points to directory c, which contains a subdirectory pointing back to directory a. Circular references can cause havoc when a program is recursively walking a directory structure. However, this scenario has been accounted for and will not cause your program to loop infinitely.</p><p>The next page discusses the heart of file I/O support in the Java programming language, the Path class.</p><h3>12.11.2 The Path Class</h3><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html">Path</a> class, introduced in the Java SE 7 release, is one of the primary entrypoints of the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/package-summary.html">java.nio.file</a> package. If your application uses file I/O, you will want to learn about the powerful features of this class.</p><p><strong>Version Note:</strong> If you have pre-JDK7 code that uses java.io.File, you can still take advantage of the Path class functionality by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/io/File.html#toPath--">File.toPath</a> method. See <a href="https://docs.oracle.com/javase/tutorial/essential/io/legacy.html">Legacy File I/O Code</a> for more information.</p><p>As its name implies, the Path class is a programmatic representation of a path in the file system. A Path object contains the file name and directory list used to construct the path, and is used to examine, locate, and manipulate files.</p><p>A Path instance reflects the underlying platform. In the Solaris OS, a Path uses the Solaris syntax (/home/joe/foo) and in Microsoft Windows, a Path uses the Windows syntax (C:<!-- -->\<!-- -->home<!-- -->\<!-- -->joe<!-- -->\<!-- -->foo). A Path is not system independent. You cannot compare a Path from a Solaris file system and expect it to match a Path from a Windows file system, even if the directory structure is identical and both instances locate the same relative file.</p><p>The file or directory corresponding to the Path might not exist. You can create a Path instance and manipulate it in various ways: you can append to it, extract pieces of it, compare it to another path. At the appropriate time, you can use the methods in the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html">Files</a> class to check the existence of the file corresponding to the Path, create the file, open it, delete it, change its permissions, and so on.</p><p>The next page examines the Path class in detail.</p><h3>12.11.3 Path Operations</h3><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html">Path</a> class includes various methods that can be used to obtain information about the path, access elements of the path, convert the path to other forms, or extract portions of a path. There are also methods for matching the path string and methods for removing redundancies in a path. This lesson addresses these Path methods, sometimes called <em>syntactic</em> operations, because they operate on the path itself and don&#x27;t access the file system.</p><p>This section covers the following:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#create">Creating a Path</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#info">Retrieving Information About a Path</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#normal">Removing Redundancies from a Path</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#convert">Converting a Path</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#resolve">Joining Two Paths</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#relativize">Creating a Path Between Two Paths</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#compare">Comparing Two Paths</a></li></ul><h4>12.11.3.1 Creating a Path</h4><p>A Path instance contains the information used to specify the location of a file or directory. At the time it is defined, a Path is provided with a series of one or more names. A root element or a file name might be included, but neither are required. A Path might consist of just a single directory or file name.</p><p>You can easily create a Path object by using one of the following get methods from the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Paths.html">Paths</a> (note the plural) helper class:</p><p>Path p1 = Paths.get(&quot;/tmp/foo&quot;);</p><p>Path p2 = Paths.get(args<!-- -->[0]<!-- -->);</p><p>Path p3 = Paths.get(URI.create(&quot;file:///Users/joe/FileTest.java&quot;));</p><p>The Paths.get method is shorthand for the following code:</p><p>Path p4 = FileSystems.getDefault().getPath(&quot;/users/sally&quot;);</p><p>The following example creates /u/joe/logs/foo.log assuming your home directory is /u/joe, or C:<!-- -->\<!-- -->joe<!-- -->\<!-- -->logs<!-- -->\<!-- -->foo.log if you are on Windows.</p><p>Path p5 = Paths.get(System.getProperty(&quot;user.home&quot;),&quot;logs&quot;, &quot;foo.log&quot;);</p><h4>12.11.3.2 Retrieving Information about a Path</h4><p>You can think of the Path as storing these name elements as a sequence. The highest element in the directory structure would be located at index 0. The lowest element in the directory structure would be located at index <!-- -->[n-1]<!-- -->, where n is the number of name elements in the Path. Methods are available for retrieving individual elements or a subsequence of the Path using these indexes.</p><p>The examples in this lesson use the following directory structure.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8fAwAI+gL9Kv2mJAAAAABJRU5ErkJggg==" alt="Sample directory structure"/></p><p>Sample Directory Structure</p><p>The following code snippet defines a Path instance and then invokes several methods to obtain information about the path:</p><p>// None of these methods requires that the file corresponding</p><p>// to the Path exists.</p><p>// Microsoft Windows syntax</p><p>Path path = Paths.get(&quot;C:<!-- -->\<!-- -->\<!-- -->home<!-- -->\<!-- -->\<!-- -->joe<!-- -->\<!-- -->\<!-- -->foo&quot;);</p><p>// Solaris syntax</p><p>Path path = Paths.get(&quot;/home/joe/foo&quot;);</p><p>System.out.format(&quot;toString: %s%n&quot;, path.toString());</p><p>System.out.format(&quot;getFileName: %s%n&quot;, path.getFileName());</p><p>System.out.format(&quot;getName(0): %s%n&quot;, path.getName(0));</p><p>System.out.format(&quot;getNameCount: %d%n&quot;, path.getNameCount());</p><p>System.out.format(&quot;subpath(0,2): %s%n&quot;, path.subpath(0,2));</p><p>System.out.format(&quot;getParent: %s%n&quot;, path.getParent());</p><p>System.out.format(&quot;getRoot: %s%n&quot;, path.getRoot());</p><p>Here is the output for both Windows and the Solaris OS:</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>Method Invoked</strong></td><td><strong>Returns in the Solaris OS</strong></td><td><strong>Returns in Microsoft Windows</strong></td><td><strong>Comment</strong></td></tr><tr><td>toString</td><td>/home/joe/foo</td><td>C:<!-- -->\<!-- -->home<!-- -->\<!-- -->joe<!-- -->\<!-- -->foo</td><td>Returns the string representation of the Path. If the path was created using Filesystems.getDefault().getPath(String) or Paths.get (the latter is a convenience method for getPath), the method performs minor syntactic cleanup. For example, in a UNIX operating system, it will correct the input string //home/joe/foo to /home/joe/foo.</td></tr><tr><td>getFileName</td><td>foo</td><td>foo</td><td>Returns the file name or the last element of the sequence of name elements.</td></tr><tr><td>getName(0)</td><td>home</td><td>home</td><td>Returns the path element corresponding to the specified index. The 0th element is the path element closest to the root.</td></tr><tr><td>getNameCount</td><td>3</td><td>3</td><td>Returns the number of elements in the path.</td></tr><tr><td>subpath(0,2)</td><td>home/joe</td><td>home<!-- -->\<!-- -->joe</td><td>Returns the subsequence of the Path (not including a root element) as specified by the beginning and ending indexes.</td></tr><tr><td>getParent</td><td>/home/joe</td><td>\<!-- -->home<!-- -->\<!-- -->joe</td><td>Returns the path of the parent directory.</td></tr><tr><td>getRoot</td><td>/</td><td>C:<!-- -->\</td><td>Returns the root of the path.</td></tr></tbody></table><p>The previous example shows the output for an absolute path. In the following example, a relative path is specified:</p><p>// Solaris syntax</p><p>Path path = Paths.get(&quot;sally/bar&quot;);</p><p>or</p><p>// Microsoft Windows syntax</p><p>Path path = Paths.get(&quot;sally<!-- -->\<!-- -->\<!-- -->bar&quot;);</p><p>Here is the output for Windows and the Solaris OS:</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>Method Invoked</strong></td><td><strong>Returns in the Solaris OS</strong></td><td><strong>Returns in Microsoft Windows</strong></td></tr><tr><td>toString</td><td>sally/bar</td><td>sally<!-- -->\<!-- -->bar</td></tr><tr><td>getFileName</td><td>bar</td><td>bar</td></tr><tr><td>getName(0)</td><td>sally</td><td>sally</td></tr><tr><td>getNameCount</td><td>2</td><td>2</td></tr><tr><td>subpath(0,1)</td><td>sally</td><td>sally</td></tr><tr><td>getParent</td><td>sally</td><td>sally</td></tr><tr><td>getRoot</td><td>null</td><td>null</td></tr></tbody></table><h4>12.11.3.3 Removing Redundancies From a Path</h4><p>Many file systems use &quot;.&quot; notation to denote the current directory and &quot;..&quot; to denote the parent directory. You might have a situation where a Path contains redundant directory information. Perhaps a server is configured to save its log files in the &quot;/dir/logs/.&quot; directory, and you want to delete the trailing &quot;/.&quot; notation from the path.</p><p>The following examples both include redundancies:</p><p>/home/./joe/foo</p><p>/home/sally/../joe/foo</p><p>The normalize method removes any redundant elements, which includes any &quot;.&quot; or &quot;<em>directory</em>/..&quot; occurrences. Both of the preceding examples normalize to /home/joe/foo.</p><p>It is important to note that normalize doesn&#x27;t check at the file system when it cleans up a path. It is a purely syntactic operation. In the second example, if sally were a symbolic link, removing sally/.. might result in a Path that no longer locates the intended file.</p><p>To clean up a path while ensuring that the result locates the correct file, you can use the toRealPath method. This method is described in the next section, <a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#convert">Converting a Path</a>.</p><h4>12.11.3.4 Converting a Path</h4><p>You can use three methods to convert the Path. If you need to convert the path to a string that can be opened from a browser, you can use <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#toUri--">toUri</a>. For example:</p><p>Path p1 = Paths.get(&quot;/home/logfile&quot;);</p><p>// Result is <strong>file:///home/logfile</strong></p><p>System.out.format(&quot;%s%n&quot;, p1.toUri());</p><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#toAbsolutePath--">toAbsolutePath</a> method converts a path to an absolute path. If the passed-in path is already absolute, it returns the same Path object. The toAbsolutePath method can be very helpful when processing user-entered file names. For example:</p><p>public class FileTest {</p><p>public static void main(String[] args) {</p><p>if (args.length &lt; 1) {</p><p>System.out.println(&quot;usage: FileTest file&quot;);</p><p>System.exit(-1);</p><p>}</p><p>// Converts the input string to a Path object.</p><p>Path inputPath = Paths.get(args<!-- -->[0]<!-- -->);</p><p><strong>// Converts the input Path</strong></p><p><strong>// to an absolute path.</strong></p><p><strong>// Generally, this means prepending</strong></p><p><strong>// the current working</strong></p><p><strong>// directory. If this example</strong></p><p><strong>// were called like this:</strong></p><p><strong>// java FileTest foo</strong></p><p><strong>// the getRoot and getParent methods</strong></p><p><strong>// would return null</strong></p><p><strong>// on the original &quot;inputPath&quot;</strong></p><p><strong>// instance. Invoking getRoot and</strong></p><p><strong>// getParent on the &quot;fullPath&quot;</strong></p><p><strong>// instance returns expected values.</strong></p><p><strong>Path fullPath = inputPath.toAbsolutePath();</strong></p><p>}</p><p>}</p><p>The toAbsolutePath method converts the user input and returns a Path that returns useful values when queried. The file does not need to exist for this method to work.</p><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#toRealPath-java.nio.file.LinkOption...-">toRealPath</a> method returns the <em>real</em> path of an existing file. This method performs several operations in one:</p><ul><li>If true is passed to this method and the file system supports symbolic links, this method resolves any symbolic links in the path.</li><li>If the Path is relative, it returns an absolute path.</li><li>If the Path contains any redundant elements, it returns a path with those elements removed.</li></ul><p>This method throws an exception if the file does not exist or cannot be accessed. You can catch the exception when you want to handle any of these cases. For example:</p><p>try {</p><p>Path fp = path.toRealPath();</p><p>} catch (NoSuchFileException x) {</p><p>System.err.format(&quot;%s: no such&quot; + &quot; file or directory%n&quot;, path);</p><p>// Logic for case when file doesn&#x27;t exist.</p><p>} catch (IOException x) {</p><p>System.err.format(&quot;%s%n&quot;, x);</p><p>// Logic for other sort of file error.</p><p>}</p><h4>12.11.3.5 Joining Two Paths</h4><p>You can combine paths by using the resolve method. You pass in a <em>partial path</em> , which is a path that does not include a root element, and that partial path is appended to the original path.</p><p>For example, consider the following code snippet:</p><p>// Solaris</p><p>Path p1 = Paths.get(&quot;/home/joe/foo&quot;);</p><p>// Result is <strong>/home/joe/foo/bar</strong></p><p>System.out.format(&quot;%s%n&quot;, p1.resolve(&quot;bar&quot;));</p><p>or</p><p>// Microsoft Windows</p><p>Path p1 = Paths.get(&quot;C:<!-- -->\<!-- -->\<!-- -->home<!-- -->\<!-- -->\<!-- -->joe<!-- -->\<!-- -->\<!-- -->foo&quot;);</p><p>// Result is <strong>C:<!-- -->\<!-- -->home<!-- -->\<!-- -->joe<!-- -->\<!-- -->foo<!-- -->\<!-- -->bar</strong></p><p>System.out.format(&quot;%s%n&quot;, p1.resolve(&quot;bar&quot;));</p><p>Passing an absolute path to the resolve method returns the passed-in path:</p><p>// Result is <strong>/home/joe</strong></p><p>Paths.get(&quot;foo&quot;).resolve(&quot;/home/joe&quot;);</p><h4>12.11.3.6 Creating a Path Between Two Paths</h4><p>A common requirement when you are writing file I/O code is the capability to construct a path from one location in the file system to another location. You can meet this using the relativizemethod. This method constructs a path originating from the original path and ending at the location specified by the passed-in path. The new path is <em>relative</em> to the original path.</p><p>For example, consider two relative paths defined as joe and sally:</p><p>Path p1 = Paths.get(&quot;joe&quot;);</p><p>Path p2 = Paths.get(&quot;sally&quot;);</p><p>In the absence of any other information, it is assumed that joe and sally are siblings, meaning nodes that reside at the same level in the tree structure. To navigate from joe to sally, you would expect to first navigate one level up to the parent node and then down to sally:</p><p>// Result is <strong>../sally</strong></p><p>Path p1_to_p2 = p1.relativize(p2);</p><p>// Result is <strong>../joe</strong></p><p>Path p2_to_p1 = p2.relativize(p1);</p><p>Consider a slightly more complicated example:</p><p>Path p1 = Paths.get(&quot;home&quot;);</p><p>Path p3 = Paths.get(&quot;home/sally/bar&quot;);</p><p>// Result is <strong>sally/bar</strong></p><p>Path p1_to_p3 = p1.relativize(p3);</p><p>// Result is <strong>../..</strong></p><p>Path p3_to_p1 = p3.relativize(p1);</p><p>In this example, the two paths share the same node, home. To navigate from home to bar, you first navigate one level down to sally and then one more level down to bar. Navigating from barto home requires moving up two levels.</p><p>A relative path cannot be constructed if only one of the paths includes a root element. If both paths include a root element, the capability to construct a relative path is system dependent.</p><p>The recursive <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Copy.java">Copy</a> example uses the relativize and resolve methods.</p><h4>12.11.3.7 Comparing Two Paths</h4><p>The Path class supports <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#equals-java.lang.Object-">equals</a>, enabling you to test two paths for equality. The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#startsWith-java.nio.file.Path-">startsWith</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#endsWith-java.nio.file.Path-">endsWith</a> methods enable you to test whether a path begins or ends with a particular string. These methods are easy to use. For example:</p><p>Path path = <!-- -->.<!-- -->..;</p><p>Path otherPath = <!-- -->.<!-- -->..;</p><p>Path beginning = Paths.get(&quot;/home&quot;);</p><p>Path ending = Paths.get(&quot;foo&quot;);</p><p>if (path.equals(otherPath)) {</p><p>// <em>equality logic here</em></p><p>} else if (path.startsWith(beginning)) {</p><p>// <em>path begins with &quot;/home&quot;</em></p><p>} else if (path.endsWith(ending)) {</p><p>// <em>path ends with &quot;foo&quot;</em></p><p>}</p><p>The Path class implements the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html">Iterable</a> interface. The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#iterator--">iterator</a> method returns an object that enables you to iterate over the name elements in the path. The first element returned is that closest to the root in the directory tree. The following code snippet iterates over a path, printing each name element:</p><p>Path path = <!-- -->.<!-- -->..;</p><p>for (Path name: path) {</p><p>System.out.println(name);</p><p>}</p><p>The Path class also implements the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">Comparable</a> interface. You can compare Path objects by using compareTo which is useful for sorting.</p><p>You can also put Path objects into a Collection. See the <a href="https://docs.oracle.com/javase/tutorial/collections/index.html">Collections</a> trail for more information about this powerful feature.</p><p>When you want to verify that two Path objects locate the same file, you can use the isSameFile method, as described in <a href="https://docs.oracle.com/javase/tutorial/essential/io/check.html#same">Checking Whether Two Paths Locate the Same File</a>.</p><h3>12.11.4 File Operations</h3><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html">Files</a> class is the other primary entrypoint of the java.nio.file package. This class offers a rich set of static methods for reading, writing, and manipulating files and directories. The Files methods work on instances of Path objects. Before proceeding to the remaining sections, you should familiarize yourself with the following common concepts:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#resources">Releasing System Resources</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#exception">Catching Exceptions</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#varargs">Varargs</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#atomic">Atomic Operations</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#chaining">Method Chaining</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob">What <em>Is</em> a Glob?</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#linkaware">Link Awareness</a></li></ul><h4>12.11.4.1 Releasing System Resources</h4><p>Many of the resources that are used in this API, such as streams or channels, implement or extend the <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html">java.io.Closeable</a> interface. A requirement of a Closeable resource is that the close method must be invoked to release the resource when no longer required. Neglecting to close a resource can have a negative implication on an application&#x27;s performance. The try-with-resources statement, described in the next section, handles this step for you.</p><h4>12.11.4.2 Catching Exceptions</h4><p>With file I/O, unexpected conditions are a fact of life: a file exists (or doesn&#x27;t exist) when expected, the program doesn&#x27;t have access to the file system, the default file system implementation does not support a particular function, and so on. Numerous errors can be encountered.</p><p>All methods that access the file system can throw an IOException. It is best practice to catch these exceptions by embedding these methods into a try-with-resources statement, introduced in the Java SE 7 release. The try-with-resources statement has the advantage that the compiler automatically generates the code to close the resource(s) when no longer required. The following code shows how this might look:</p><p>Charset charset = Charset.forName(&quot;US-ASCII&quot;);</p><p>String s = <!-- -->.<!-- -->..;</p><p>try (BufferedWriter writer = Files.newBufferedWriter(file, charset)) {</p><p>writer.write(s, 0, s.length());</p><p>} catch (IOException x) {</p><p>System.err.format(&quot;IOException: %s%n&quot;, x);</p><p>}</p><p>For more information, see <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">The try-with-resources Statement</a>.</p><p>Alternatively, you can embed the file I/O methods in a try block and then catch any exceptions in a catch block. If your code has opened any streams or channels, you should close them in a finally block. The previous example would look something like the following using the try-catch-finally approach:</p><p>Charset charset = Charset.forName(&quot;US-ASCII&quot;);</p><p>String s = <!-- -->.<!-- -->..;</p><p>BufferedWriter writer = null;</p><p>try {</p><p>writer = Files.newBufferedWriter(file, charset);</p><p>writer.write(s, 0, s.length());</p><p>} catch (IOException x) {</p><p>System.err.format(&quot;IOException: %s%n&quot;, x);</p><p>} finally {</p><p>if (writer != null) writer.close();</p><p>}</p><p>For more information, see <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html">Catching and Handling Exceptions</a>.</p><p>In addition to IOException, many specific exceptions extend <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html">FileSystemException</a>. This class has some useful methods that return the file involved <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getFile--">(getFile)</a>, the detailed message string<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getMessage--">(getMessage)</a>, the reason why the file system operation failed <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getReason--">(getReason)</a>, and the &quot;other&quot; file involved, if any <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getOtherFile--">(getOtherFile)</a>.</p><p>The following code snippet shows how the getFile method might be used:</p><p>try (<!-- -->.<!-- -->..) {</p><p>.<!-- -->..</p><p>} catch (NoSuchFileException x) {</p><p>System.err.format(&quot;%s does not exist<!-- -->\<!-- -->n&quot;, x.getFile());</p><p>}</p><p>For purposes of clarity, the file I/O examples in this lesson may not show exception handling, but your code should always include it.</p><h4>12.11.4.3 Varargs</h4><p>Several Files methods accept an arbitrary number of arguments when flags are specified. For example, in the following method signature, the ellipses notation after the CopyOption argument indicates that the method accepts a variable number of arguments, or <em>varargs</em>, as they are typically called:</p><p>Path Files.move(Path, Path, <strong>CopyOption<!-- -->.<!-- -->..</strong>)</p><p>When a method accepts a varargs argument, you can pass it a comma-separated list of values or an array (CopyOption[]) of values.</p><p>In the move example, the method can be invoked as follows:</p><pre><code class="language-java">import static java.nio.file.StandardCopyOption.*;

Path source = \...;

Path target = \...;

Files.move(source,

target,

REPLACE_EXISTING,

ATOMIC_MOVE);
</code></pre><p>For more information about varargs syntax, see <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html#varargs">Arbitrary Number of Arguments</a>.</p><h4>12.11.4.4 Atomic Operations</h4><p>Several Files methods, such as move, can perform certain operations atomically in some file systems.</p><p>An <em>atomic file operation</em> is an operation that cannot be interrupted or &quot;partially&quot; performed. Either the entire operation is performed or the operation fails. This is important when you have multiple processes operating on the same area of the file system, and you need to guarantee that each process accesses a complete file.</p><h4>12.11.4.5 Method Chaining</h4><p>Many of the file I/O methods support the concept of <em>method chaining</em>.</p><p>You first invoke a method that returns an object. You then immediately invoke a method on <em>that</em> object, which returns yet another object, and so on. Many of the I/O examples use the following technique:</p><p>String value = Charset.defaultCharset().decode(buf).toString();</p><p>UserPrincipal group =</p><p>file.getFileSystem().getUserPrincipalLookupService().</p><p>lookupPrincipalByName(&quot;me&quot;);</p><p>This technique produces compact code and enables you to avoid declaring temporary variables that you don&#x27;t need.</p><h4>12.11.4.6 What Is a Glob?</h4><p>Two methods in the Files class accept a glob argument, but what is a <em>glob</em>?</p><p>You can use glob syntax to specify pattern-matching behavior.</p><p>A glob pattern is specified as a string and is matched against other strings, such as directory or file names. Glob syntax follows several simple rules:</p><ul><li>An asterisk, <!-- -->*<!-- -->, matches any number of characters (including none).</li><li>Two asterisks, <!-- -->*<!-- -->*<!-- -->, works like <!-- -->*<!-- --> but crosses directory boundaries. This syntax is generally used for matching complete paths.</li><li>A question mark, ?, matches exactly one character.</li><li>Braces specify a collection of subpatterns. For example:<ul><li>{sun,moon,stars} matches &quot;sun&quot;, &quot;moon&quot;, or &quot;stars&quot;.</li><li>{temp<!-- -->*<!-- -->,tmp<!-- -->*<!-- -->} matches all strings beginning with &quot;temp&quot; or &quot;tmp&quot;.</li></ul></li><li>Square brackets convey a set of single characters or, when the hyphen character (-) is used, a range of characters. For example:<ul><li>[aeiou]<!-- --> matches any lowercase vowel.</li><li>[0-9]<!-- --> matches any digit.</li><li>[A-Z]<!-- --> matches any uppercase letter.</li><li>[a-z,A-Z]<!-- --> matches any uppercase or lowercase letter.</li></ul></li></ul><p>Within the square brackets, <!-- -->*<!-- -->, ?, and <!-- -->\<!-- --> match themselves.</p><ul><li>All other characters match themselves.</li><li>To match <!-- -->*<!-- -->, ?, or the other special characters, you can escape them by using the backslash character, <!-- -->\<!-- -->. For example: <!-- -->\<!-- -->\<!-- --> matches a single backslash, and <!-- -->\<!-- -->? matches the question mark.</li></ul><p>Here are some examples of glob syntax:</p><ul><li>*<!-- -->.html -- Matches all strings that end in <em>.html</em></li><li>??? -- Matches all strings with exactly three letters or digits</li><li>*<!-- -->[0-9]<!-- -->*<!-- --> -- Matches all strings containing a numeric value</li><li>*<!-- -->.{htm,html,pdf} -- Matches any string ending with <em>.htm</em>, <em>.html</em> or <em>.pdf</em></li><li>a?<!-- -->*<!-- -->.java -- Matches any string beginning with a, followed by at least one letter or digit, and ending with <em>.java</em></li><li>{foo<!-- -->*<!-- -->,<!-- -->*<!-- -->[0-9]<!-- -->*<!-- -->} -- Matches any string beginning with <em>foo</em> or any string containing a numeric value</li></ul><p><strong>Note:</strong> If you are typing the glob pattern at the keyboard and it contains one of the special characters, you must put the pattern in quotes (&quot;<!-- -->*<!-- -->&quot;), use the backslash (<!-- -->\<!-- -->*<!-- -->), or use whatever escape mechanism is supported at the command line.</p><p>The glob syntax is powerful and easy to use. However, if it is not sufficient for your needs, you can also use a regular expression. For more information, see the <a href="https://docs.oracle.com/javase/tutorial/essential/regex/index.html">Regular Expressions</a> lesson.</p><p>For more information about the glob sytnax, see the API specification for the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-">getPathMatcher</a> method in the FileSystem class.</p><h4>12.11.4.7 Link Awareness</h4><p>The Files class is &quot;link aware.&quot; Every Files method either detects what to do when a symbolic link is encountered, or it provides an option enabling you to configure the behavior when a symbolic link is encountered.</p><h3>12.11.5 Checking a File or Directory</h3><p>You have a Path instance representing a file or directory, but does that file exist on the file system? Is it readable? Writable? Executable?</p><h4>12.11.5.1 Verifying the Existence of a File or Directory</h4><p>The methods in the Path class are syntactic, meaning that they operate on the Path instance. But eventually you must access the file system to verify that a particular Path exists, or does not exist. You can do so with the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#exists-java.nio.file.Path-java.nio.file.LinkOption...-">exists(Path, LinkOption<!-- -->.<!-- -->..)</a> and the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#notExists-java.nio.file.Path-java.nio.file.LinkOption...-">notExists(Path, LinkOption<!-- -->.<!-- -->..)</a> methods. Note that !Files.exists(path) is not equivalent to Files.notExists(path). When you are testing a file&#x27;s existence, three results are possible:</p><ul><li>The file is verified to exist.</li><li>The file is verified to not exist.</li><li>The file&#x27;s status is unknown. This result can occur when the program does not have access to the file.</li></ul><p>If both exists and notExists return false, the existence of the file cannot be verified.</p><h4>12.11.5.2 Checking File Accessibility</h4><p>To verify that the program can access a file as needed, you can use the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isReadable-java.nio.file.Path-">isReadable(Path)</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isWritable-java.nio.file.Path-">isWritable(Path)</a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isExecutable-java.nio.file.Path-">isExecutable(Path)</a> methods.</p><p>The following code snippet verifies that a particular file exists and that the program has the ability to execute the file.</p><pre><code class="language-java">Path file = \...;
boolean isRegularExecutableFile = Files.isRegularFile(file) &amp;
Files.isReadable(file) &amp; Files.isExecutable(file);
</code></pre><p><strong>Note:</strong> Once any of these methods completes, there is no guarantee that the file can be accessed. A common security flaw in many applications is to perform a check and then access the file. For more information, use your favorite search engine to look up TOCTTOU (pronounced <em>TOCK-too</em>).</p><h4>12.11.5.3 Checking Whether Two Paths Locate the Same File</h4><p>When you have a file system that uses symbolic links, it is possible to have two different paths that locate the same file. The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isSameFile-java.nio.file.Path-java.nio.file.Path-">isSameFile(Path, Path)</a> method compares two paths to determine if they locate the same file on the file system. For example:</p><pre><code class="language-java">Path p1 = \...;

Path p2 = \...;

if (Files.isSameFile(p1, p2)) {

// Logic when the paths locate the same file

}
</code></pre><h3>12.11.6 Deleting a File or Directory</h3><p>You can delete files, directories or links. With symbolic links, the link is deleted and not the target of the link. With directories, the directory must be empty, or the deletion fails.</p><p>The Files class provides two deletion methods.</p><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#delete-java.nio.file.Path-">delete(Path)</a> method deletes the file or throws an exception if the deletion fails. For example, if the file does not exist a NoSuchFileException is thrown. You can catch the exception to determine why the delete failed as follows:</p><pre><code class="language-java">try {

Files.delete(path);

} catch (NoSuchFileException x) {

System.err.format(&quot;%s: no such&quot; + &quot; file or directory%n&quot;, path);

} catch (DirectoryNotEmptyException x) {

System.err.format(&quot;%s not empty%n&quot;, path);

} catch (IOException x) {

// File permission problems are caught here.

System.err.println(x);

}
</code></pre><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#deleteIfExists-java.nio.file.Path-">deleteIfExists(Path)</a> method also deletes the file, but if the file does not exist, no exception is thrown. Failing silently is useful when you have multiple threads deleting files and you don&#x27;t want to throw an exception just because one thread did so first.</p><h3>12.11.7 Copying a File or Directory</h3><p>You can copy a file or directory by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-">copy(Path, Path, CopyOption<!-- -->.<!-- -->..)</a> method. The copy fails if the target file exists, unless the REPLACE_EXISTING option is specified.</p><p>Directories can be copied. However, files inside the directory are not copied, so the new directory is empty even when the original directory contains files.</p><p>When copying a symbolic link, the target of the link is copied. If you want to copy the link itself, and not the contents of the link, specify either the NOFOLLOW_LINKS or REPLACE_EXISTINGoption.</p><p>This method takes a varargs argument. The following StandardCopyOption and LinkOption enums are supported:</p><ul><li>REPLACE_EXISTING -- Performs the copy even when the target file already exists. If the target is a symbolic link, the link itself is copied (and not the target of the link). If the target is a non-empty directory, the copy fails with the FileAlreadyExistsException exception.</li><li>COPY_ATTRIBUTES -- Copies the file attributes associated with the file to the target file. The exact file attributes supported are file system and platform dependent, but last-modified-time is supported across platforms and is copied to the target file.</li><li>NOFOLLOW_LINKS -- Indicates that symbolic links should not be followed. If the file to be copied is a symbolic link, the link is copied (and not the target of the link).</li></ul><p>If you are not familiar with enums, see <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html">Enum Types</a>.</p><p>The following shows how to use the copy method:</p><pre><code class="language-java">import static java.nio.file.StandardCopyOption.*;.

Files.copy(source, target, REPLACE_EXISTING);
</code></pre><p>In addition to file copy, the Files class also defines methods that may be used to copy between a file and a stream. The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.io.InputStream-java.nio.file.Path-java.nio.file.CopyOption...-">copy(InputStream, Path, CopyOptions<!-- -->.<!-- -->..)</a> method may be used to copy all bytes from an input stream to a file. The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.nio.file.Path-java.io.OutputStream-">copy(Path, OutputStream)</a> method may be used to copy all bytes from a file to an output stream.</p><p>The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Copy.java">Copy</a> example uses the copy and Files.walkFileTree methods to support a recursive copy. See <a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html">Walking the File Tree</a> for more information.</p><h3>12.11.8 Moving a File or Directory</h3><p>You can move a file or directory by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#move-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-">move(Path, Path, CopyOption<!-- -->.<!-- -->..)</a> method. The move fails if the target file exists, unless the REPLACE_EXISTING option is specified.</p><p>Empty directories can be moved. If the directory is not empty, the move is allowed when the directory can be moved without moving the contents of that directory. On UNIX systems, moving a directory within the same partition generally consists of renaming the directory. In that situation, this method works even when the directory contains files.</p><p>This method takes a varargs argument -- the following StandardCopyOption enums are supported:</p><ul><li>REPLACE_EXISTING -- Performs the move even when the target file already exists. If the target is a symbolic link, the symbolic link is replaced but what it points to is not affected.</li><li>ATOMIC_MOVE -- Performs the move as an atomic file operation. If the file system does not support an atomic move, an exception is thrown. With an ATOMIC_MOVE you can move a file into a directory and be guaranteed that any process watching the directory accesses a complete file.</li></ul><p>The following shows how to use the move method:</p><pre><code class="language-java">import static java.nio.file.StandardCopyOption.*;
Files.move(source, target, REPLACE_EXISTING);
</code></pre><p>Though you can implement the move method on a single directory as shown, the method is most often used with the file tree recursion mechanism. For more information, see <a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html">Walking the File Tree</a>.</p><h3>12.11.9 Managing Metadata (File and File Store Attributes)</h3><p>The definition of <em>metadata</em> is &quot;data about other data.&quot; With a file system, the data is contained in its files and directories, and the metadata tracks information about each of these objects: Is it a regular file, a directory, or a link? What is its size, creation date, last modified date, file owner, group owner, and access permissions?</p><p>A file system&#x27;s metadata is typically referred to as its <em>file attributes</em>. The Files class includes methods that can be used to obtain a single attribute of a file, or to set an attribute.</p><p>+-----------------------------------+-----------------------------------+
| <strong>Methods</strong>                       | <strong>Comment</strong>                       |
+-----------------------------------+-----------------------------------+
| <!-- -->[size(                            | Returns the size of the specified |
| Path)]<!-- -->(<a href="https://docs.oracle.com/ja">https://docs.oracle.com/ja</a> | file in bytes.                    |
| vase/8/docs/api/java/nio/file/Fil |                                   |
| es.html#size-java.nio.file.Path-) |                                   |
+-----------------------------------+-----------------------------------+
| <!-- -->[isDirectory(Path,                | Returns true if the               |
| LinkOpti                          | specified Path locates a file     |
| on)]<!-- -->(<a href="https://docs.oracle.com/java">https://docs.oracle.com/java</a> | that is a directory.              |
| se/8/docs/api/java/nio/file/Files |                                   |
| .html#isDirectory-java.nio.file.P |                                   |
| ath-java.nio.file.LinkOption...-) |                                   |
+-----------------------------------+-----------------------------------+
| <!-- -->[isRegularFile(Path,              | Returns true if the               |
| LinkOption<!-- -->.<!-- -->..                    | specified Path locates a file     |
| )]<!-- -->(<a href="https://docs.oracle.com/javase">https://docs.oracle.com/javase</a> | that is a regular file.           |
| /8/docs/api/java/nio/file/Files.h |                                   |
| tml#isRegularFile-java.nio.file.P |                                   |
| ath-java.nio.file.LinkOption...-) |                                   |
+-----------------------------------+-----------------------------------+
| <!-- -->[isSymbolicLink(Path)]<!-- -->(htt        | Returns true if the               |
| ps://docs.oracle.com/javase/8/doc | specified Path locates a file     |
| s/api/java/nio/file/Files.html#is | that is a symbolic link.          |
| SymbolicLink-java.nio.file.Path-) |                                   |
+-----------------------------------+-----------------------------------+
| <!-- -->[isHidden(Path                    | Returns true if the               |
| )]<!-- -->(<a href="https://docs.oracle.com/javase">https://docs.oracle.com/javase</a> | specified Path locates a file     |
| /8/docs/api/java/nio/file/Files.h | that is considered hidden by the  |
| tml#isHidden-java.nio.file.Path-) | file system.                      |
+-----------------------------------+-----------------------------------+
| <!-- -->[getLastModifiedTime(Path,        | Returns or sets the specified     |
| LinkOption<!-- -->.<!-- -->..)]<!-- -->(http             | file&#x27;s last modified time.       |
| s://docs.oracle.com/javase/8/docs |                                   |
| /api/java/nio/file/Files.html#get |                                   |
| LastModifiedTime-java.nio.file.Pa |                                   |
| th-java.nio.file.LinkOption...-)\ |                                   |
| <!-- -->[setLastModifiedTime(Path,        |                                   |
| FileTime)]<!-- -->(https://               |                                   |
| docs.oracle.com/javase/8/docs/api |                                   |
| /java/nio/file/Files.html#setLast |                                   |
| ModifiedTime-java.nio.file.Path-j |                                   |
| ava.nio.file.attribute.FileTime-) |                                   |
+-----------------------------------+-----------------------------------+
| <!-- -->[getOwner(Path,                   | Returns or sets the owner of the  |
| LinkOption                        | file.                             |
| <!-- -->.<!-- -->..)]<!-- -->(<a href="https://docs.oracle.com/ja">https://docs.oracle.com/ja</a> |                                   |
| vase/8/docs/api/java/nio/file/Fil |                                   |
| es.html#getOwner-java.nio.file.Pa |                                   |
| th-java.nio.file.LinkOption...-)\ |                                   |
| <!-- -->[setOwner(Path,                   |                                   |
| UserPrincipal)]<!-- -->(ht                |                                   |
| tps://docs.oracle.com/javase/8/do |                                   |
| cs/api/java/nio/file/Files.html#s |                                   |
| etOwner-java.nio.file.Path-java.n |                                   |
| io.file.attribute.UserPrincipal-) |                                   |
+-----------------------------------+-----------------------------------+
| <!-- -->[getPosixFilePermissions(Path,    | Returns or sets a file&#x27;s POSIX   |
| LinkOption<!-- -->.<!-- -->..)]<!-- -->(https://         | file permissions.                 |
| docs.oracle.com/javase/8/docs/api |                                   |
| /java/nio/file/Files.html#getPosi |                                   |
| xFilePermissions-java.nio.file.Pa |                                   |
| th-java.nio.file.LinkOption...-)\ |                                   |
| <!-- -->[setPosixFilePermissions(Path,    |                                   |
| Set&lt;PosixFilePermissi            |                                   |
| on&gt;)]<!-- -->(<a href="https://docs.oracle.com/ja">https://docs.oracle.com/ja</a> |                                   |
| vase/8/docs/api/java/nio/file/Fil |                                   |
| es.html#setPosixFilePermissions-j |                                   |
| ava.nio.file.Path-java.util.Set-) |                                   |
+-----------------------------------+-----------------------------------+
| <!-- -->[getAttribute(Path, String,       | Returns or sets the value of a    |
| LinkOption<!-- -->.<!-- -->..)]<!-- -->(<a href="https://docs.o">https://docs.o</a>   | file attribute.                   |
| racle.com/javase/8/docs/api/java/ |                                   |
| nio/file/Files.html#getAttribute- |                                   |
| java.nio.file.Path-java.lang.Stri |                                   |
| ng-java.nio.file.LinkOption...-)\ |                                   |
| <!-- -->[setAttribute(Path, String,       |                                   |
| Object,                           |                                   |
| LinkOption<!-- -->.<!-- -->..                    |                                   |
| )]<!-- -->(<a href="https://docs.oracle.com/javase">https://docs.oracle.com/javase</a> |                                   |
| /8/docs/api/java/nio/file/Files.h |                                   |
| tml#setAttribute-java.nio.file.Pa |                                   |
| th-java.lang.String-java.lang.Obj |                                   |
| ect-java.nio.file.LinkOption...-) |                                   |
+-----------------------------------+-----------------------------------+</p><p>If a program needs multiple file attributes around the same time, it can be inefficient to use methods that retrieve a single attribute. Repeatedly accessing the file system to retrieve a single attribute can adversely affect performance. For this reason, the Files class provides two readAttributes methods to fetch a file&#x27;s attributes in one bulk operation.</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Method</strong></td><td><strong>Comment</strong></td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAttributes-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-">readAttributes(Path, String, LinkOption<!-- -->.<!-- -->..)</a></td><td>Reads a file&#x27;s attributes as a bulk operation. The String parameter identifies the attributes to be read.</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-"><code>readAttributes(Path, Class&lt;A&gt;, LinkOption\...)</code></a></td><td>Reads a file&#x27;s attributes as a bulk operation. The <code>Class&lt;A&gt;</code> parameter is the type of attributes requested and the method returns an object of that class.</td></tr></tbody></table><p>Before showing examples of the readAttributes methods, it should be mentioned that different file systems have different notions about which attributes should be tracked. For this reason, related file attributes are grouped together into views. A <em>view</em> maps to a particular file system implementation, such as POSIX or DOS, or to a common functionality, such as file ownership.</p><p>The supported views are as follows:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/BasicFileAttributeView.html">BasicFileAttributeView</a> -- Provides a view of basic attributes that are required to be supported by all file system implementations.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/DosFileAttributeView.html">DosFileAttributeView</a> -- Extends the basic attribute view with the standard four bits supported on file systems that support the DOS attributes.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFileAttributeView.html">PosixFileAttributeView</a> -- Extends the basic attribute view with attributes supported on file systems that support the POSIX family of standards, such as UNIX. These attributes include file owner, group owner, and the nine related access permissions.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/FileOwnerAttributeView.html">FileOwnerAttributeView</a> -- Supported by any file system implementation that supports the concept of a file owner.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/AclFileAttributeView.html">AclFileAttributeView</a> -- Supports reading or updating a file&#x27;s Access Control Lists (ACL). The NFSv4 ACL model is supported. Any ACL model, such as the Windows ACL model, that has a well-defined mapping to the NFSv4 model might also be supported.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/UserDefinedFileAttributeView.html">UserDefinedFileAttributeView</a> -- Enables support of metadata that is user defined. This view can be mapped to any extension mechanisms that a system supports. In the Solaris OS, for example, you can use this view to store the MIME type of a file.</li></ul><p>A specific file system implementation might support only the basic file attribute view, or it may support several of these file attribute views. A file system implementation might support other attribute views not included in this API.</p><p>In most instances, you should not have to deal directly with any of the FileAttributeView interfaces. (If you do need to work directly with the FileAttributeView, you can access it via the<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getFileAttributeView-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-"><code>getFileAttributeView(Path, Class&lt;V&gt;, LinkOption\...)</code></a> method.)</p><p>The readAttributes methods use generics and can be used to read the attributes for any of the file attributes views. The examples in the rest of this page use the readAttributes methods.</p><p>The remainder of this section covers the following topics:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#basic">Basic File Attributes</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#time">Setting Time Stamps</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#dos">DOS File Attributes</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#posix">POSIX File Permissions</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#lookup">Setting a File or Group Owner</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#user">User-Defined File Attributes</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#store">File Store Attributes</a></li></ul><h4>12.11.9.1 Basic File Attributes</h4><p>As mentioned previously, to read the basic attributes of a file, you can use one of the Files.readAttributes methods, which reads all the basic attributes in one bulk operation. This is far more efficient than accessing the file system separately to read each individual attribute. The varargs argument currently supports the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/LinkOption.html">LinkOption</a> enum, NOFOLLOW_LINKS. Use this option when you do not want symbolic links to be followed.</p><p><strong>A word about time stamps:</strong> The set of basic attributes includes three time stamps: creationTime, lastModifiedTime, and lastAccessTime. Any of these time stamps might not be supported in a particular implementation, in which case the corresponding accessor method returns an implementation-specific value. When supported, the time stamp is returned as an <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/FileTime.html">FileTime</a> object.</p><p>The following code snippet reads and prints the basic file attributes for a given file and uses the methods in the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/BasicFileAttributes.html">BasicFileAttributes</a> class.</p><p>Path file = <!-- -->.<!-- -->..;</p><p>BasicFileAttributes attr = Files.readAttributes(file, BasicFileAttributes.class);</p><p>System.out.println(&quot;creationTime: &quot; + attr.creationTime());</p><p>System.out.println(&quot;lastAccessTime: &quot; + attr.lastAccessTime());</p><p>System.out.println(&quot;lastModifiedTime: &quot; + attr.lastModifiedTime());</p><p>System.out.println(&quot;isDirectory: &quot; + attr.isDirectory());</p><p>System.out.println(&quot;isOther: &quot; + attr.isOther());</p><p>System.out.println(&quot;isRegularFile: &quot; + attr.isRegularFile());</p><p>System.out.println(&quot;isSymbolicLink: &quot; + attr.isSymbolicLink());</p><p>System.out.println(&quot;size: &quot; + attr.size());</p><p>In addition to the accessor methods shown in this example, there is a fileKey method that returns either an object that uniquely identifies the file or null if no file key is available.</p><h4>12.11.9.2 Setting Time Stamps</h4><p>The following code snippet sets the last modified time in milliseconds:</p><p>Path file = <!-- -->.<!-- -->..;</p><p>BasicFileAttributes attr =</p><p>Files.readAttributes(file, BasicFileAttributes.class);</p><p>long currentTime = System.currentTimeMillis();</p><p>FileTime ft = FileTime.fromMillis(currentTime);</p><p>Files.setLastModifiedTime(file, ft);</p><p>}</p><h4>12.11.9.3 DOS File Attributes</h4><p>DOS file attributes are also supported on file systems other than DOS, such as Samba. The following snippet uses the methods of the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/DosFileAttributes.html">DosFileAttributes</a> class.</p><p>Path file = <!-- -->.<!-- -->..;</p><p>try {</p><p>DosFileAttributes attr =</p><p>Files.readAttributes(file, DosFileAttributes.class);</p><p>System.out.println(&quot;isReadOnly is &quot; + attr.isReadOnly());</p><p>System.out.println(&quot;isHidden is &quot; + attr.isHidden());</p><p>System.out.println(&quot;isArchive is &quot; + attr.isArchive());</p><p>System.out.println(&quot;isSystem is &quot; + attr.isSystem());</p><p>} catch (UnsupportedOperationException x) {</p><p>System.err.println(&quot;DOS file&quot; +</p><p>&quot; attributes not supported:&quot; + x);</p><p>}</p><p>However, you can set a DOS attribute using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-">setAttribute(Path, String, Object, LinkOption<!-- -->.<!-- -->..)</a> method, as follows:</p><p>Path file = <!-- -->.<!-- -->..;</p><p>Files.setAttribute(file, &quot;dos:hidden&quot;, true);</p><h4>12.11.9.4 POSIX File Permissions</h4><p><em>POSIX</em> is an acronym for Portable Operating System Interface for UNIX and is a set of IEEE and ISO standards designed to ensure interoperability among different flavors of UNIX. If a program conforms to these POSIX standards, it should be easily ported to other POSIX-compliant operating systems.</p><p>Besides file owner and group owner, POSIX supports nine file permissions: read, write, and execute permissions for the file owner, members of the same group, and &quot;everyone else.&quot;</p><p>The following code snippet reads the POSIX file attributes for a given file and prints them to standard output. The code uses the methods in the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFileAttributes.html">PosixFileAttributes</a> class.</p><p>Path file = <!-- -->.<!-- -->..;</p><p>PosixFileAttributes attr =</p><p>Files.readAttributes(file, PosixFileAttributes.class);</p><p>System.out.format(&quot;%s %s %s%n&quot;,</p><p>attr.owner().getName(),</p><p>attr.group().getName(),</p><p>PosixFilePermissions.toString(attr.permissions()));</p><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFilePermissions.html">PosixFilePermissions</a> helper class provides several useful methods, as follows:</p><ul><li>The toString method, used in the previous code snippet, converts the file permissions to a string (for example, rw-r--r--).</li><li>The fromString method accepts a string representing the file permissions and constructs a Set of file permissions.</li><li>The asFileAttribute method accepts a Set of file permissions and constructs a file attribute that can be passed to the Path.createFile or Path.createDirectory method.</li></ul><p>The following code snippet reads the attributes from one file and creates a new file, assigning the attributes from the original file to the new file:</p><pre><code class="language-java">Path sourceFile = \...;

Path newFile = \...;

PosixFileAttributes attrs =

Files.readAttributes(sourceFile, PosixFileAttributes.class);

FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; attr =

PosixFilePermissions.asFileAttribute(attrs.permissions());

Files.createFile(file, attr);
</code></pre><p>The asFileAttribute method wraps the permissions as a FileAttribute. The code then attempts to create a new file with those permissions. Note that the umask also applies, so the new file might be more secure than the permissions that were requested.</p><p>To set a file&#x27;s permissions to values represented as a hard-coded string, you can use the following code:</p><pre><code class="language-java">Path file = \...;

Set&lt;PosixFilePermission&gt; perms =

PosixFilePermissions.fromString(&quot;rw-------&quot;);

FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; attr =

PosixFilePermissions.asFileAttribute(perms);

Files.setPosixFilePermissions(file, perms);
</code></pre><p>The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Chmod.java">Chmod</a> example recursively changes the permissions of files in a manner similar to the chmod utility.</p><h4>12.11.9.5 Setting a File or Group Owner</h4><p>To translate a name into an object you can store as a file owner or a group owner, you can use the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/UserPrincipalLookupService.html">UserPrincipalLookupService</a> service. This service looks up a name or group name as a string and returns a UserPrincipal object representing that string. You can obtain the user principal look-up service for the default file system by using the<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getUserPrincipalLookupService--">FileSystem.getUserPrincipalLookupService</a> method.</p><p>The following code snippet shows how to set the file owner by using the setOwner method:</p><p>Path file = <!-- -->.<!-- -->..;</p><p>UserPrincipal owner = file.GetFileSystem().getUserPrincipalLookupService()</p><p>.lookupPrincipalByName(&quot;sally&quot;);</p><p>Files.setOwner(file, owner);</p><p>There is no special-purpose method in the Files class for setting a group owner. However, a safe way to do so directly is through the POSIX file attribute view, as follows:</p><p>Path file = <!-- -->.<!-- -->..;</p><p>GroupPrincipal group =</p><p>file.getFileSystem().getUserPrincipalLookupService()</p><p>.lookupPrincipalByGroupName(&quot;green&quot;);</p><p>Files.getFileAttributeView(file, PosixFileAttributeView.class)</p><p>.setGroup(group);</p><h4>12.11.9.6 User-Defined File Attributes</h4><p>If the file attributes supported by your file system implementation aren&#x27;t sufficient for your needs, you can use the UserDefinedAttributeView to create and track your own file attributes.</p><p>Some implementations map this concept to features like NTFS Alternative Data Streams and extended attributes on file systems such as ext3 and ZFS. Most implementations impose restrictions on the size of the value, for example, ext3 limits the size to 4 kilobytes.</p><p>A file&#x27;s MIME type can be stored as a user-defined attribute by using this code snippet:</p><p>Path file = <!-- -->.<!-- -->..;</p><p>UserDefinedFileAttributeView view = Files</p><p>.getFileAttributeView(file, UserDefinedFileAttributeView.class);</p><p>view.write(&quot;user.mimetype&quot;,</p><p>Charset.defaultCharset().encode(&quot;text/html&quot;);</p><p>To read the MIME type attribute, you would use this code snippet:</p><p>Path file = <!-- -->.<!-- -->..;</p><p>UserDefinedFileAttributeView view = Files</p><p>.getFileAttributeView(file,UserDefinedFileAttributeView.class);</p><p>String name = &quot;user.mimetype&quot;;</p><p>ByteBuffer buf = ByteBuffer.allocate(view.size(name));</p><p>view.read(name, buf);</p><p>buf.flip();</p><p>String value = Charset.defaultCharset().decode(buf).toString();</p><p>The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Xdd.java">Xdd</a> example shows how to get, set, and delete a user-defined attribute.</p><p><strong>Note:</strong> In Linux, you might have to enable extended attributes for user-defined attributes to work. If you receive an UnsupportedOperationException when trying to access the user-defined attribute view, you need to remount the file system. The following command remounts the root partition with extended attributes for the ext3 file system. If this command does not work for your flavor of Linux, consult the documentation.</p><p>\$ sudo mount -o remount,user_xattr /</p><p>If you want to make the change permanent, add an entry to /etc/fstab.</p><h4>12.11.9.7 File Store Attributes</h4><p>You can use the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileStore.html">FileStore</a> class to learn information about a file store, such as how much space is available. The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getFileStore-java.nio.file.Path-">getFileStore(Path)</a> method fetches the file store for the specified file.</p><p>The following code snippet prints the space usage for the file store where a particular file resides:</p><p>Path file = <!-- -->.<!-- -->..;</p><p>FileStore store = Files.getFileStore(file);</p><p>long total = store.getTotalSpace() / 1024;</p><p>long used = (store.getTotalSpace() -</p><p>store.getUnallocatedSpace()) / 1024;</p><p>long avail = store.getUsableSpace() / 1024;</p><p>The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/DiskUsage.java">DiskUsage</a> example uses this API to print disk space information for all the stores in the default file system. This example uses the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getFileStores--">getFileStores</a> method in the FileSystem class to fetch all the file stores for the the file system.</p><h3>12.11.10 Reading, Writing, and Creating Files</h3><p>This page discusses the details of reading, writing, creating, and opening files. There are a wide array of file I/O methods to choose from. To help make sense of the API, the following diagram arranges the file I/O methods by complexity.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8DAwAI3gLvRn7P6gAAAABJRU5ErkJggg==" alt="Line drawing with file I/O methods arranged from least complex (on the left) to most complex (on the right)."/></p><p>File I/O Methods Arranged from Less Complex to More Complex</p><p>On the far left of the diagram are the utility methods readAllBytes, readAllLines, and the write methods, designed for simple, common cases. To the right of those are the methods used to iterate over a stream or lines of text, such as newBufferedReader, newBufferedWriter, then newInputStream and newOutputStream. These methods are interoperable with the java.io package. To the right of those are the methods for dealing with ByteChannels, SeekableByteChannels, and ByteBuffers, such as the newByteChannel method. Finally, on the far right are the methods that use FileChannel for advanced applications needing file locking or memory-mapped I/O.</p><p><strong>Note:</strong> The methods for creating a new file enable you to specify an optional set of initial attributes for the file. For example, on a file system that supports the POSIX set of standards (such as UNIX), you can specify a file owner, group owner, or file permissions at the time the file is created. The <a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html">Managing Metadata</a> page explains file attributes, and how to access and set them.</p><p>This page has the following topics:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#openOptions">The OpenOptions Parameter</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#common">Commonly Used Methods for Small Files</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#streams">Methods for Unbuffered Streams and Interoperable with java.io APIs</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#channels">Methods for Channels and ByteBuffers</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#creating">Methods for Creating Regular and Temporary Files</a></li></ul><h4>12.11.10.1 The OpenOptions Parameter</h4><p>Several of the methods in this section take an optional OpenOptions parameter. This parameter is optional and the API tells you what the default behavior is for the method when none is specified.</p><p>The following StandardOpenOptions enums are supported:</p><ul><li>WRITE -- Opens the file for write access.</li><li>APPEND -- Appends the new data to the end of the file. This option is used with the WRITE or CREATE options.</li><li>TRUNCATE_EXISTING -- Truncates the file to zero bytes. This option is used with the WRITE option.</li><li>CREATE_NEW -- Creates a new file and throws an exception if the file already exists.</li><li>CREATE -- Opens the file if it exists or creates a new file if it does not.</li><li>DELETE_ON_CLOSE -- Deletes the file when the stream is closed. This option is useful for temporary files.</li><li>SPARSE -- Hints that a newly created file will be sparse. This advanced option is honored on some file systems, such as NTFS, where large files with data &quot;gaps&quot; can be stored in a more efficient manner where those empty gaps do not consume disk space.</li><li>SYNC -- Keeps the file (both content and metadata) synchronized with the underlying storage device.</li><li>DSYNC -- Keeps the file content synchronized with the underlying storage device.</li></ul><h4>12.11.10.2 Commonly Used Methods for Small Files</h4><h5>12.11.10.2.1 Reading All Bytes or Lines from a File</h5><p>If you have a small-ish file and you would like to read its entire contents in one pass, you can use the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAllBytes-java.nio.file.Path-">readAllBytes(Path)</a> or <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAllLines-java.nio.file.Path-java.nio.charset.Charset-">readAllLines(Path, Charset)</a> method. These methods take care of most of the work for you, such as opening and closing the stream, but are not intended for handling large files. The following code shows how to use the readAllBytes method:</p><p>Path file = <!-- -->.<!-- -->..;</p><p>byte[] fileArray;</p><p>fileArray = Files.readAllBytes(file);</p><h5>12.11.10.2.2 Writing All Bytes or Lines to a File</h5><p>You can use one of the write methods to write bytes, or lines, to a file.</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#write-java.nio.file.Path-byte:A-java.nio.file.OpenOption...-">write(Path, byte[], OpenOption<!-- -->.<!-- -->..)</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#write-java.nio.file.Path-java.lang.Iterable-java.nio.charset.Charset-java.nio.file.OpenOption...-">write(Path, Iterable&lt; extends CharSequence&gt;, Charset, OpenOption<!-- -->.<!-- -->..)</a></li></ul><p>The following code snippet shows how to use a write method.</p><p>Path file = <!-- -->.<!-- -->..;</p><p>byte[] buf = <!-- -->.<!-- -->..;</p><p>Files.write(file, buf);</p><h4>12.11.10.3 Buffered I/O Methods for Text Files</h4><p>The java.nio.file package supports channel I/O, which moves data in buffers, bypassing some of the layers that can bottleneck stream I/O.</p><h5>12.11.10.3.1 Reading a File by Using Buffered Stream I/O</h5><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newBufferedReader-java.nio.file.Path-java.nio.charset.Charset-">newBufferedReader(Path, Charset)</a> method opens a file for reading, returning a BufferedReader that can be used to read text from a file in an efficient manner.</p><p>The following code snippet shows how to use the newBufferedReader method to read from a file. The file is encoded in &quot;US-ASCII.&quot;</p><p>Charset charset = Charset.forName(&quot;US-ASCII&quot;);</p><p>try (BufferedReader reader = Files.newBufferedReader(file, charset)) {</p><p>String line = null;</p><p>while ((line = reader.readLine()) != null) {</p><p>System.out.println(line);</p><p>}</p><p>} catch (IOException x) {</p><p>System.err.format(&quot;IOException: %s%n&quot;, x);</p><p>}</p><h5>12.11.10.3.2 Writing a File by Using Buffered Stream I/O</h5><p>You can use the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newBufferedWriter-java.nio.file.Path-java.nio.charset.Charset-java.nio.file.OpenOption...-">newBufferedWriter(Path, Charset, OpenOption<!-- -->.<!-- -->..)</a> method to write to a file using a BufferedWriter.</p><p>The following code snippet shows how to create a file encoded in &quot;US-ASCII&quot; using this method:</p><p>Charset charset = Charset.forName(&quot;US-ASCII&quot;);</p><p>String s = <!-- -->.<!-- -->..;</p><p>try (BufferedWriter writer = Files.newBufferedWriter(file, charset)) {</p><p>writer.write(s, 0, s.length());</p><p>} catch (IOException x) {</p><p>System.err.format(&quot;IOException: %s%n&quot;, x);</p><p>}</p><h4>12.11.10.4 Methods for Unbuffered Streams and Interoperable with java.io APIs</h4><h5>12.11.10.4.1 Reading a File by Using Stream I/O</h5><p>To open a file for reading, you can use the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newInputStream-java.nio.file.Path-java.nio.file.OpenOption...-">newInputStream(Path, OpenOption<!-- -->.<!-- -->..)</a> method. This method returns an unbuffered input stream for reading bytes from the file.</p><p>Path file = <!-- -->.<!-- -->..;</p><p>try (InputStream in = Files.newInputStream(file);</p><p>BufferedReader reader =</p><p>new BufferedReader(new InputStreamReader(in))) {</p><p>String line = null;</p><p>while ((line = reader.readLine()) != null) {</p><p>System.out.println(line);</p><p>}</p><p>} catch (IOException x) {</p><p>System.err.println(x);</p><p>}</p><h5>12.11.10.4.2 Creating and Writing a File by Using Stream I/O</h5><p>You can create a file, append to a file, or write to a file by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newOutputStream-java.nio.file.Path-java.nio.file.OpenOption...-">newOutputStream(Path, OpenOption<!-- -->.<!-- -->..)</a> method. This method opens or creates a file for writing bytes and returns an unbuffered output stream.</p><p>The method takes an optional OpenOption parameter. If no open options are specified, and the file does not exist, a new file is created. If the file exists, it is truncated. This option is equivalent to invoking the method with the CREATE and TRUNCATE_EXISTING options.</p><p>The following example opens a log file. If the file does not exist, it is created. If the file exists, it is opened for appending.</p><pre><code class="language-java">import static java.nio.file.StandardOpenOption.*;
import java.nio.file.*;
import java.io.*;
public class LogFileTest {
public static void main(String[] args) {
// Convert the string to a
// byte array.
String s = &quot;Hello World! &quot;;
byte data[] = s.getBytes();
Path p = Paths.get(&quot;./logfile.txt&quot;);
try (OutputStream out = new BufferedOutputStream(
Files.newOutputStream(p, CREATE, APPEND))) {
out.write(data, 0, data.length);
} catch (IOException x) {
System.err.println(x);
}
}
}
</code></pre><h4>12.11.10.5 Methods for Channels and ByteBuffers</h4><h5>12.11.10.5.1 Reading and Writing Files by Using Channel I/O</h5><p>While stream I/O reads a character at a time, channel I/O reads a buffer at a time. The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/ByteChannel.html">ByteChannel</a> interface provides basic read and write functionality. A <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html">SeekableByteChannel</a> is a ByteChannel that has the capability to maintain a position in the channel and to change that position. A SeekableByteChannel also supports truncating the file associated with the channel and querying the file for its size.</p><p>The capability to move to different points in the file and then read from or write to that location makes random access of a file possible. See <a href="https://docs.oracle.com/javase/tutorial/essential/io/rafs.html">Random Access Files</a> for more information.</p><p>There are two methods for reading and writing channel I/O.</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newByteChannel-java.nio.file.Path-java.nio.file.OpenOption...-">newByteChannel(Path, OpenOption<!-- -->.<!-- -->..)</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newByteChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-">newByteChannel(Path, Set&lt;? extends OpenOption&gt;, FileAttribute&lt;?&gt;<!-- -->.<!-- -->..)</a></li></ul><p><strong>Note:</strong> The newByteChannel methods return an instance of a SeekableByteChannel. With a default file system, you can cast this seekable byte channel to a <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/FileChannel.html">FileChannel</a>providing access to more advanced features such mapping a region of the file directly into memory for faster access, locking a region of the file so other processes cannot access it, or reading and writing bytes from an absolute position without affecting the channel&#x27;s current position.</p><p>Both newByteChannel methods enable you to specify a list of OpenOption options. The same <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#openOptions">open options</a> used by the newOutputStream methods are supported, in addition to one more option: READ is required because the SeekableByteChannel supports both reading and writing.</p><p>Specifying READ opens the channel for reading. Specifying WRITE or APPEND opens the channel for writing. If none of these options is specified, the channel is opened for reading.</p><p>The following code snippet reads a file and prints it to standard output:</p><p>// Defaults to READ</p><p>try (SeekableByteChannel sbc = Files.newByteChannel(file)) {</p><p>ByteBuffer buf = ByteBuffer.allocate(10);</p><p>// Read the bytes with the proper encoding for this platform. If</p><p>// you skip this step, you might see something that looks like</p><p>// Chinese characters when you expect Latin-style characters.</p><p>String encoding = System.getProperty(&quot;file.encoding&quot;);</p><p>while (sbc.read(buf) &gt; 0) {</p><p>buf.rewind();</p><p>System.out.print(Charset.forName(encoding).decode(buf));</p><p>buf.flip();</p><p>}</p><p>} catch (IOException x) {</p><p>System.out.println(&quot;caught exception: &quot; + x);</p><p>The following example, written for UNIX and other POSIX file systems, creates a log file with a specific set of file permissions. This code creates a log file or appends to the log file if it already exists. The log file is created with read/write permissions for owner and read only permissions for group.</p><pre><code class="language-java">import static java.nio.file.StandardOpenOption.*;

import java.nio.*;

import java.nio.channels.*;

import java.nio.file.*;

import java.nio.file.attribute.*;

import java.io.*;

import java.util.*;

public class LogFilePermissionsTest {

public static void main(String[] args) {

// Create the set of options for appending to the file.

Set&lt;OpenOption&gt; options = new HashSet&lt;OpenOption&gt;();

options.add(APPEND);

options.add(CREATE);

// Create the custom permissions attribute.

Set&lt;PosixFilePermission&gt; perms =

PosixFilePermissions.fromString(&quot;rw-r-----&quot;);

FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; attr =

PosixFilePermissions.asFileAttribute(perms);

// Convert the string to a ByteBuffer.

String s = &quot;Hello World! &quot;;

byte data[] = s.getBytes();

ByteBuffer bb = ByteBuffer.wrap(data);

Path file = Paths.get(&quot;./permissions.log&quot;);

try (SeekableByteChannel sbc =

Files.newByteChannel(file, options, attr)) {

sbc.write(bb);

} catch (IOException x) {

System.out.println(&quot;Exception thrown: &quot; + x);

}

}

}
</code></pre><h4>12.11.10.6 Methods for Creating Regular and Temporary Files</h4><h5>12.11.10.6.1 Creating Files</h5><p>You can create an empty file with an initial set of attributes by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-">createFile(Path, FileAttribute&lt;?&gt;)</a> method. For example, if, at the time of creation, you want a file to have a particular set of file permissions, use the createFile method to do so. If you do not specify any attributes, the file is created with default attributes. If the file already exists, createFile throws an exception.</p><p>In a single atomic operation, the createFile method checks for the existence of the file and creates that file with the specified attributes, which makes the process more secure against malicious code.</p><p>The following code snippet creates a file with default attributes:</p><p>Path file = <!-- -->.<!-- -->..;</p><p>try {</p><p>// Create the empty file with default permissions, etc.</p><p>Files.createFile(file);</p><p>} catch (FileAlreadyExistsException x) {</p><p>System.err.format(&quot;file named %s&quot; +</p><p>&quot; already exists%n&quot;, file);</p><p>} catch (IOException x) {</p><p>// Some other sort of failure, such as permissions.</p><p>System.err.format(&quot;createFile error: %s%n&quot;, x);</p><p>}</p><p><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#posix">POSIX File Permissions</a> has an example that uses createFile(Path, FileAttribute&lt;?&gt;) to create a file with pre-set permissions.</p><p>You can also create a new file by using the newOutputStream methods, as described in <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#createStream">Creating and Writing a File using Stream I/O</a>. If you open a new output stream and close it immediately, an empty file is created.</p><h5>12.11.10.6.2 Creating Temporary Files</h5><p>You can create a temporary file using one of the following createTempFile methods:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempFile-java.nio.file.Path-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-">createTempFile(Path, String, String, FileAttribute&lt;?&gt;)</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempFile-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-">createTempFile(String, String, FileAttribute&lt;?&gt;)</a></li></ul><p>The first method allows the code to specify a directory for the temporary file and the second method creates a new file in the default temporary-file directory. Both methods allow you to specify a suffix for the filename and the first method allows you to also specify a prefix. The following code snippet gives an example of the second method:</p><p>try {</p><p>Path tempFile = Files.createTempFile(null, &quot;.myapp&quot;);</p><p>System.out.format(&quot;The temporary file&quot; +</p><p>&quot; has been created: %s%n&quot;, tempFile)</p><p>;</p><p>} catch (IOException x) {</p><p>System.err.format(&quot;IOException: %s%n&quot;, x);</p><p>}</p><p>The result of running this file would be something like the following:</p><p>The temporary file has been created: /tmp/509668702974537184.myapp</p><p>The specific format of the temporary file name is platform specific.</p><h3>12.11.11 Random Access Files</h3><p><em>Random access files</em> permit nonsequential, or random, access to a file&#x27;s contents. To access a file randomly, you open the file, seek a particular location, and read from or write to that file.</p><p>This functionality is possible with the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html">SeekableByteChannel</a> interface. The SeekableByteChannel interface extends channel I/O with the notion of a current position. Methods enable you to set or query the position, and you can then read the data from, or write the data to, that location. The API consists of a few, easy to use, methods:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#position--">position</a> -- Returns the channel&#x27;s current position</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#position-long-">position(long)</a> -- Sets the channel&#x27;s position</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#read-java.nio.ByteBuffer-">read(ByteBuffer)</a> -- Reads bytes into the buffer from the channel</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#write-java.nio.ByteBuffer-">write(ByteBuffer)</a> -- Writes bytes from the buffer to the channel</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#truncate-long-">truncate(long)</a> -- Truncates the file (or other entity) connected to the channel</li></ul><p><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#channelio">Reading and Writing Files With Channel I/O</a> shows that the Path.newByteChannel methods return an instance of a SeekableByteChannel. On the default file system, you can use that channel as is, or you can cast it to a <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/FileChannel.html">FileChannel</a> giving you access to more advanced features, such as mapping a region of the file directly into memory for faster access, locking a region of the file, or reading and writing bytes from an absolute location without affecting the channel&#x27;s current position.</p><p>The following code snippet opens a file for both reading and writing by using one of the newByteChannel methods. The SeekableByteChannel that is returned is cast to a FileChannel. Then, 12 bytes are read from the beginning of the file, and the string &quot;I was here!&quot; is written at that location. The current position in the file is moved to the end, and the 12 bytes from the beginning are appended. Finally, the string, &quot;I was here!&quot; is appended, and the channel on the file is closed.</p><p>String s = &quot;I was here!<!-- -->\<!-- -->n&quot;;</p><p>byte data[] = s.getBytes();</p><p>ByteBuffer out = ByteBuffer.wrap(data);</p><p>ByteBuffer copy = ByteBuffer.allocate(12);</p><p>try (FileChannel fc = (FileChannel.open(file, READ, WRITE))) {</p><p>// Read the first 12</p><p>// bytes of the file.</p><p>int nread;</p><p>do {</p><p>nread = fc.read(copy);</p><p>} while (nread != -1 &amp;&amp; copy.hasRemaining());</p><p>// Write &quot;I was here!&quot; at the beginning of the file.</p><p>fc.position(0);</p><p>while (out.hasRemaining())</p><p>fc.write(out);</p><p>out.rewind();</p><p>// Move to the end of the file. Copy the first 12 bytes to</p><p>// the end of the file. Then write &quot;I was here!&quot; again.</p><p>long length = fc.size();</p><p>fc.position(length-1);</p><p>copy.flip();</p><p>while (copy.hasRemaining())</p><p>fc.write(copy);</p><p>while (out.hasRemaining())</p><p>fc.write(out);</p><p>} catch (IOException x) {</p><p>System.out.println(&quot;I/O Exception: &quot; + x);</p><p>}</p><h3>12.11.12 Creating and Reading Directories</h3><p>Some of the methods previously discussed, such as delete, work on files, links <em>and</em> directories. But how do you list all the directories at the top of a file system? How do you list the contents of a directory or create a directory?</p><p>This section covers the following functionality specific to directories:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#listall">Listing a File System&#x27;s Root Directories</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#create">Creating a Directory</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#createTemp">Creating a Temporary Directory</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#listdir">Listing a Directory&#x27;s Contents</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#glob">Filtering a Directory Listing By Using Globbing</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#filter">Writing Your Own Directory Filter</a></li></ul><h4>12.11.12.1 Listing a File System&#x27;s Root Directories</h4><p>You can list all the root directories for a file system by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getRootDirectories--">FileSystem.getRootDirectories</a> method. This method returns an Iterable, which enables you to use the <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html">enhanced for</a>statement to iterate over all the root directories.</p><p>The following code snippet prints the root directories for the default file system:</p><pre><code class="language-java">Iterable&lt;Path&gt; dirs = FileSystems.getDefault().getRootDirectories();

for (Path name: dirs) {

System.err.println(name);

}
</code></pre><h4>12.11.12.2 Creating a Directory</h4><p>You can create a new directory by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-">createDirectory(Path, FileAttribute&lt;?&gt;)</a> method. If you don&#x27;t specify any FileAttributes, the new directory will have default attributes. For example:</p><pre><code class="language-java">Path dir = \...;

Files.createDirectory(path);

The following code snippet creates a new directory on a POSIX file system that has specific permissions:

Set&lt;PosixFilePermission&gt; perms =

PosixFilePermissions.fromString(&quot;rwxr-x---&quot;);

FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; attr =

PosixFilePermissions.asFileAttribute(perms);

Files.createDirectory(file, attr);
</code></pre><p>To create a directory several levels deep when one or more of the parent directories might not yet exist, you can use the convenience method, <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectories-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-">createDirectories(Path, FileAttribute&lt;?&gt;)</a>. As with the createDirectory(Path, FileAttribute&lt;?&gt;) method, you can specify an optional set of initial file attributes. The following code snippet uses default attributes:</p><pre><code class="language-java">Files.createDirectories(Paths.get(&quot;foo/bar/test&quot;));
</code></pre><p>The directories are created, as needed, from the top down. In the foo/bar/test example, if the foo directory does not exist, it is created. Next, the bar directory is created, if needed, and, finally, the test directory is created.</p><p>It is possible for this method to fail after creating some, but not all, of the parent directories.</p><h4>12.11.12.3 Creating a Temporary Directory</h4><p>You can create a temporary directory using one of createTempDirectory methods:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempDirectory-java.nio.file.Path-java.lang.String-java.nio.file.attribute.FileAttribute...-">createTempDirectory(Path, String, FileAttribute&lt;?&gt;<!-- -->.<!-- -->..)</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempDirectory-java.lang.String-java.nio.file.attribute.FileAttribute...-">createTempDirectory(String, FileAttribute&lt;?&gt;<!-- -->.<!-- -->..)</a></li></ul><p>The first method allows the code to specify a location for the temporary directory and the second method creates a new directory in the default temporary-fle directory.</p><h4>12.11.12.4 Listing a Directory&#x27;s Contents</h4><p>You can list all the contents of a directory by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newDirectoryStream-java.nio.file.Path-">newDirectoryStream(Path)</a> method. This method returns an object that implements the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/DirectoryStream.html">DirectoryStream</a> interface. The class that implements the DirectoryStream interface also implements Iterable, so you can iterate through the directory stream, reading all of the objects. This approach scales well to very large directories.</p><p><strong>Remember:</strong> The returned DirectoryStream is a <em>stream</em>. If you are not using a try-with-resources statement, don&#x27;t forget to close the stream in the finally block. The try-with-resources statement takes care of this for you.</p><p>The following code snippet shows how to print the contents of a directory:</p><pre><code class="language-java">Path dir = \...;

try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir)) {

for (Path file: stream) {

System.out.println(file.getFileName());

}

} catch (IOException \| DirectoryIteratorException x) {

// IOException can never be thrown by the iteration.

// In this snippet, it can only be thrown by newDirectoryStream.

System.err.println(x);

}
</code></pre><p>The Path objects returned by the iterator are the names of the entries resolved against the directory. So, if you are listing the contents of the /tmp directory, the entries are returned with the form /tmp/a, /tmp/b, and so on.</p><p>This method returns the entire contents of a directory: files, links, subdirectories, and hidden files. If you want to be more selective about the contents that are retrieved, you can use one of the other newDirectoryStream methods, as described later in this page.</p><p>Note that if there is an exception during directory iteration then DirectoryIteratorException is thrown with the IOException as the cause. Iterator methods cannot throw exception exceptions.</p><h4>12.11.12.5 Filtering a Directory Listing By Using Globbing</h4><p>If you want to fetch only files and subdirectories where each name matches a particular pattern, you can do so by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newDirectoryStream-java.nio.file.Path-java.lang.String-">newDirectoryStream(Path, String)</a> method, which provides a built-in glob filter. If you are not familiar with glob syntax, see <a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob">What Is a Glob?</a></p><p>For example, the following code snippet lists files relating to Java: <em>.class</em>, <em>.java</em>, and <em>.jar</em> files.:</p><pre><code class="language-java">Path dir = \...;

try (DirectoryStream&lt;Path&gt; stream =

Files.newDirectoryStream(dir, &quot;\*.{java,class,jar}&quot;)) {

for (Path entry: stream) {

System.out.println(entry.getFileName());

}

} catch (IOException x) {

// IOException can never be thrown by the iteration.

// In this snippet, it can // only be thrown by newDirectoryStream.

System.err.println(x);

}
</code></pre><h4>12.11.12.6 Writing Your Own Directory Filter</h4><p>Perhaps you want to filter the contents of a directory based on some condition other than pattern matching. You can create your own filter by implementing the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/DirectoryStream.Filter.html"><code>DirectoryStream.Filter&lt;T&gt;</code></a>interface. This interface consists of one method, accept, which determines whether a file fulfills the search requirement.</p><p>For example, the following code snippet implements a filter that retrieves only directories:</p><pre><code class="language-java">DirectoryStream.Filter&lt;Path&gt; filter =

newDirectoryStream.Filter&lt;Path&gt;() {

public boolean accept(Path file) throws IOException {

try {

return (Files.isDirectory(path));

} catch (IOException x) {

// Failed to determine if it&#x27;s a directory.

System.err.println(x);

return false;

}

}

};
</code></pre><p>Once the filter has been created, it can be invoked by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newDirectoryStream-java.nio.file.Path-java.nio.file.DirectoryStream.Filter-">newDirectoryStream(Path, DirectoryStream.Filter&lt;? super Path&gt;)</a> method. The following code snippet uses the isDirectory filter to print only the directory&#x27;s subdirectories to standard output:</p><pre><code class="language-java">Path dir = \...;

try (DirectoryStream&lt;Path&gt;

stream = Files.newDirectoryStream(dir, filter)) {

for (Path entry: stream) {

System.out.println(entry.getFileName());

}

} catch (IOException x) {

System.err.println(x);

}
</code></pre><p>This method is used to filter a single directory only. However, if you want to find all the subdirectories in a file tree, you would use the mechanism for <a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html">Walking the File Tree</a>.</p><h3>12.11.13 Links, Symbolic or Otherwise</h3><p>As mentioned previously, the java.nio.file package, and the Path class in particular, is &quot;link aware.&quot; Every Path method either detects what to do when a symbolic link is encountered, or it provides an option enabling you to configure the behavior when a symbolic link is encountered.</p><p>The discussion so far has been about <a href="https://docs.oracle.com/javase/tutorial/essential/io/path.html#symlink">symbolic or <em>soft</em> links</a>, but some file systems also support hard links. <em>Hard links</em> are more restrictive than symbolic links, as follows:</p><ul><li>The target of the link must exist.</li><li>Hard links are generally not allowed on directories.</li><li>Hard links are not allowed to cross partitions or volumes. Therefore, they cannot exist across file systems.</li><li>A hard link looks, and behaves, like a regular file, so they can be hard to find.</li><li>A hard link is, for all intents and purposes, the same entity as the original file. They have the same file permissions, time stamps, and so on. All attributes are identical.</li></ul><p>Because of these restrictions, hard links are not used as often as symbolic links, but the Path methods work seamlessly with hard links.</p><p>Several methods deal specifically with links and are covered in the following sections:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/links.html#symLink">Creating a Symbolic Link</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/links.html#hardLink">Creating a Hard Link</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/links.html#detect">Detecting a Symbolic Link</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/links.html#read">Finding the Target of a Link</a></li></ul><h4>12.11.13.1 Creating a Symbolic Link</h4><p>If your file system supports it, you can create a symbolic link by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createSymbolicLink-java.nio.file.Path-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-">createSymbolicLink(Path, Path, FileAttribute&lt;?&gt;)</a> method. The second Path argument represents the target file or directory and might or might not exist. The following code snippet creates a symbolic link with default permissions:</p><pre><code class="language-java">Path newLink = \...;

Path target = \...;

try {

Files.createSymbolicLink(newLink, target);

} catch (IOException x) {

System.err.println(x);

} catch (UnsupportedOperationException x) {

// Some file systems do not support symbolic links.

System.err.println(x);

}
</code></pre><p>The FileAttributes vararg enables you to specify initial file attributes that are set atomically when the link is created. However, this argument is intended for future use and is not currently implemented.</p><h4>12.11.13.2 Creating a Hard Link</h4><p>You can create a hard (or <em>regular</em>) link to an existing file by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createLink-java.nio.file.Path-java.nio.file.Path-">createLink(Path, Path)</a> method. The second Path argument locates the existing file, and it must exist or a NoSuchFileException is thrown. The following code snippet shows how to create a link:</p><pre><code class="language-java">Path newLink = \...;

Path existingFile = \...;

try {

Files.createLink(newLink, existingFile);

} catch (IOException x) {

System.err.println(x);

} catch (UnsupportedOperationException x) {

// Some file systems do not

// support adding an existing

// file to a directory.

System.err.println(x);

}
</code></pre><h4>12.11.13.3 Detecting a Symbolic Link</h4><p>To determine whether a Path instance is a symbolic link, you can use the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isSymbolicLink-java.nio.file.Path-">isSymbolicLink(Path)</a> method. The following code snippet shows how:</p><pre><code class="language-java">Path file = \...;

boolean isSymbolicLink =

Files.isSymbolicLink(file);
</code></pre><p>For more information, see <a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html">Managing Metadata</a>.</p><h4>12.11.13.4 Finding the Target of a Link</h4><p>You can obtain the target of a symbolic link by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readSymbolicLink-java.nio.file.Path-">readSymbolicLink(Path)</a> method, as follows:</p><pre><code class="language-java">Path link = \...;

try {

System.out.format(&quot;Target of link&quot; +

&quot; &#x27;%s&#x27; is &#x27;%s&#x27;%n&quot;, link,

Files.readSymbolicLink(link));

} catch (IOException x) {

System.err.println(x);

}
</code></pre><p>If the Path is not a symbolic link, this method throws a NotLinkException.</p><h3>12.11.14 Walking the File Tree</h3><p>Do you need to create an application that will recursively visit all the files in a file tree? Perhaps you need to delete every .class file in a tree, or find every file that hasn&#x27;t been accessed in the last year. You can do so with the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html">FileVisitor</a> interface.</p><p>This section covers the following:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html#filevisitor">The FileVisitor Interface</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html#invoke">Kickstarting the Process</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html#order">Considerations When Creating a FileVisitor</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html#return">Controlling the Flow</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html#ex">Examples</a></li></ul><h4>12.11.14.1 The FileVisitor Interface</h4><p>To walk a file tree, you first need to implement a FileVisitor. A FileVisitor specifies the required behavior at key points in the traversal process: when a file is visited, before a directory is accessed, after a directory is accessed, or when a failure occurs. The interface has four methods that correspond to these situations:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html#preVisitDirectory-T-java.nio.file.attribute.BasicFileAttributes-">preVisitDirectory</a> -- Invoked before a directory&#x27;s entries are visited.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html#postVisitDirectory-T-java.io.IOException-">postVisitDirectory</a> -- Invoked after all the entries in a directory are visited. If any errors are encountered, the specific exception is passed to the method.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html#visitFile-T-java.nio.file.attribute.BasicFileAttributes-">visitFile</a> -- Invoked on the file being visited. The file&#x27;s BasicFileAttributes is passed to the method, or you can use the <a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html">file attributes</a> package to read a specific set of attributes. For example, you can choose to read the file&#x27;s DosFileAttributeView to determine if the file has the &quot;hidden&quot; bit set.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html#visitFileFailedy-T-java.io.IOException-">visitFileFailed</a> -- Invoked when the file cannot be accessed. The specific exception is passed to the method. You can choose whether to throw the exception, print it to the console or a log file, and so on.</li></ul><p>If you don&#x27;t need to implement all four of the FileVisitor methods, instead of implementing the FileVisitor interface, you can extend the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/SimpleFileVisitor.html">SimpleFileVisitor</a> class. This class, which implements the FileVisitor interface, visits all files in a tree and throws an IOError when an error is encountered. You can extend this class and override only the methods that you require.</p><p>Here is an example that extends SimpleFileVisitor to print all entries in a file tree. It prints the entry whether the entry is a regular file, a symbolic link, a directory, or some other &quot;unspecified&quot; type of file. It also prints the size, in bytes, of each file. Any exception that is encountered is printed to the console.</p><p>The FileVisitor methods are shown in bold:</p><pre><code class="language-java">import static java.nio.file.FileVisitResult.*;

public static class PrintFiles

extends SimpleFileVisitor&lt;Path&gt; {

// Print information about

// each type of file.

\@Override

**public FileVisitResult visitFile(Path file,**

**BasicFileAttributes attr)** {

if (attr.isSymbolicLink()) {

System.out.format(&quot;Symbolic link: %s &quot;, file);

} else if (attr.isRegularFile()) {

System.out.format(&quot;Regular file: %s &quot;, file);

} else {

System.out.format(&quot;Other: %s &quot;, file);

}

System.out.println(&quot;(&quot; + attr.size() + &quot;bytes)&quot;);

return CONTINUE;

}

// Print each directory visited.

\@Override

**public FileVisitResult postVisitDirectory(Path dir,**

**IOException exc)** {

System.out.format(&quot;Directory: %s%n&quot;, dir);

return CONTINUE;

}

// If there is some error accessing

// the file, let the user know.

// If you don&#x27;t override this method

// and an error occurs, an IOException

// is thrown.

\@Override

**public FileVisitResult visitFileFailed(Path file,**

**IOException exc)** {

System.err.println(exc);

return CONTINUE;

}

}
</code></pre><h4>12.11.14.2 Kickstarting the Process</h4><p>Once you have implemented your FileVisitor, how do you initiate the file walk? There are two walkFileTree methods in the Files class.</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#walkFileTree-java.nio.file.Path-java.nio.file.FileVisitor-"><code>walkFileTree(Path, FileVisitor)</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-"><code>walkFileTree(Path, Set&lt;FileVisitOption&gt;, int, FileVisitor)</code></a></li></ul><p>The first method requires only a starting point and an instance of your FileVisitor. You can invoke the PrintFiles file visitor as follows:</p><pre><code class="language-java">Path startingDir = \...;

PrintFiles pf = new PrintFiles();

Files.walkFileTree(startingDir, pf);
</code></pre><p>The second walkFileTree method enables you to additionally specify a limit on the number of levels visited and a set of <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitOption.html">FileVisitOption</a> enums. If you want to ensure that this method walks the entire file tree, you can specify Integer.MAX_VALUE for the maximum depth argument.</p><p>You can specify the FileVisitOption enum, FOLLOW_LINKS, which indicates that symbolic links should be followed.</p><p>This code snippet shows how the four-argument method can be invoked:</p><pre><code class="language-java">import static java.nio.file.FileVisitResult.*;
Path startingDir = \...;
EnumSet&lt;FileVisitOption&gt; opts = EnumSet.of(FOLLOW_LINKS);
Finder finder = new Finder(pattern);
Files.walkFileTree(startingDir, opts, Integer.MAX_VALUE, finder);
</code></pre><h4>12.11.14.3 Considerations When Creating a FileVisitor</h4><p>A file tree is walked depth first, but you cannot make any assumptions about the iteration order that subdirectories are visited.</p><p>If your program will be changing the file system, you need to carefully consider how you implement your FileVisitor.</p><p>For example, if you are writing a recursive delete, you first delete the files in a directory before deleting the directory itself. In this case, you delete the directory in postVisitDirectory.</p><p>If you are writing a recursive copy, you create the new directory in preVisitDirectory before attempting to copy the files to it (in visitFiles). If you want to preserve the attributes of the source directory (similar to the UNIX cp -p command), you need to do that <em>after</em> the files have been copied, in postVisitDirectory. The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Copy.java">Copy</a> example shows how to do this.</p><p>If you are writing a file search, you perform the comparison in the visitFile method. This method finds all the files that match your criteria, but it does not find the directories. If you want to find both files and directories, you must also perform the comparison in either the preVisitDirectory or postVisitDirectory method. The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Find.java">Find</a> example shows how to do this.</p><p>You need to decide whether you want symbolic links to be followed. If you are deleting files, for example, following symbolic links might not be advisable. If you are copying a file tree, you might want to allow it. By default, walkFileTree does not follow symbolic links.</p><p>The visitFile method is invoked for files. If you have specified the FOLLOW_LINKS option and your file tree has a circular link to a parent directory, the looping directory is reported in the visitFileFailed method with the FileSystemLoopException. The following code snippet shows how to catch a circular link and is from the <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Copy.java">Copy</a> example:</p><p>\@Override</p><p>public FileVisitResult</p><p>visitFileFailed(Path file,</p><p>IOException exc) {</p><p>if (exc instanceof FileSystemLoopException) {</p><p>System.err.println(&quot;cycle detected: &quot; + file);</p><p>} else {</p><p>System.err.format(&quot;Unable to copy:&quot; + &quot; %s: %s%n&quot;, file, exc);</p><p>}</p><p>return CONTINUE;</p><p>}</p><p>This case can occur only when the program is following symbolic links.</p><h4>12.11.14.4 Controlling the Flow</h4><p>Perhaps you want to walk the file tree looking for a particular directory and, when found, you want the process to terminate. Perhaps you want to skip specific directories.</p><p>The FileVisitor methods return a <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitResult.html">FileVisitResult</a> value. You can abort the file walking process or control whether a directory is visited by the values you return in the FileVisitormethods:</p><ul><li>CONTINUE -- Indicates that the file walking should continue. If the preVisitDirectory method returns CONTINUE, the directory is visited.</li><li>TERMINATE -- Immediately aborts the file walking. No further file walking methods are invoked after this value is returned.</li><li>SKIP_SUBTREE -- When preVisitDirectory returns this value, the specified directory and its subdirectories are skipped. This branch is &quot;pruned out&quot; of the tree.</li><li>SKIP_SIBLINGS -- When preVisitDirectory returns this value, the specified directory is not visited, postVisitDirectory is not invoked, and no further unvisited siblings are visited. If returned from the postVisitDirectory method, no further siblings are visited. Essentially, nothing further happens in the specified directory.</li></ul><p>In this code snippet, any directory named SCCS is skipped:</p><pre><code class="language-java">import static java.nio.file.FileVisitResult.*;

public FileVisitResult

preVisitDirectory(Path dir,

BasicFileAttributes attrs) {

(if (dir.getFileName().toString().equals(&quot;SCCS&quot;)) {

return SKIP_SUBTREE;

}

return CONTINUE;

}

In this code snippet, as soon as a particular file is located, the file name is printed to standard output, and the file walking terminates:

import static java.nio.file.FileVisitResult.*;

// The file we are looking for.

Path lookingFor = \...;

public FileVisitResult

visitFile(Path file,

BasicFileAttributes attr) {

if (file.getFileName().equals(lookingFor)) {

System.out.println(&quot;Located file: &quot; + file);

return TERMINATE;

}

return CONTINUE;

}
</code></pre><h4>12.11.14.5 Examples</h4><p>The following examples demonstrate the file walking mechanism:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Find.java">Find</a> -- Recurses a file tree looking for files and directories that match a particular glob pattern. This example is discussed in <a href="https://docs.oracle.com/javase/tutorial/essential/io/find.html">Finding Files</a>.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Chmod.java">Chmod</a> -- Recursively changes permissions on a file tree (for POSIX systems only).</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Copy.java">Copy</a> -- Recursively copies a file tree.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/WatchDir.java">WatchDir</a> -- Demonstrates the mechanism that watches a directory for files that have been created, deleted or modified. Calling this program with the -r option watches an entire tree for changes. For more information about the file notification service, see <a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html">Watching a Directory for Changes</a>.</li></ul><h3>12.11.15 Finding Files</h3><p>If you have ever used a shell script, you have most likely used pattern matching to locate files. In fact, you have probably used it extensively. If you haven&#x27;t used it, pattern matching uses special characters to create a pattern and then file names can be compared against that pattern. For example, in most shell scripts, the asterisk, <!-- -->*<!-- -->, matches any number of characters. For example, the following command lists all the files in the current directory that end in .html:</p><p>\% ls <!-- -->*<!-- -->.html</p><p>The java.nio.file package provides programmatic support for this useful feature. Each file system implementation provides a <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/PathMatcher.html">PathMatcher</a>. You can retrieve a file system&#x27;s PathMatcherby using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-">getPathMatcher(String)</a> method in the FileSystem class. The following code snippet fetches the path matcher for the default file system:</p><p>String pattern = <!-- -->.<!-- -->..;</p><p>PathMatcher matcher =</p><p>FileSystems.getDefault().getPathMatcher(&quot;glob:&quot; + pattern);</p><p>The string argument passed to getPathMatcher specifies the syntax flavor and the pattern to be matched. This example specifies <em>glob</em> syntax. If you are unfamiliar with glob syntax, see <a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob">What is a Glob</a>.</p><p>Glob syntax is easy to use and flexible but, if you prefer, you can also use regular expressions, or <em>regex</em>, syntax. For further information about regex, see the <a href="https://docs.oracle.com/javase/tutorial/essential/regex/index.html">Regular Expressions</a> lesson. Some file system implementations might support other syntaxes.</p><p>If you want to use some other form of string-based pattern matching, you can create your own PathMatcher class. The examples in this page use glob syntax.</p><p>Once you have created your PathMatcher instance, you are ready to match files against it. The PathMatcher interface has a single method, <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/PathMatcher.html#matches-java.nio.file.Path-">matches</a>, that takes a Path argument and returns a boolean: It either matches the pattern, or it does not. The following code snippet looks for files that end in .java or .class and prints those files to standard output:</p><p>PathMatcher matcher =</p><p>FileSystems.getDefault().getPathMatcher(&quot;glob:<!-- -->*<!-- -->.{java,class}&quot;);</p><p>Path filename = <!-- -->.<!-- -->..;</p><p>if (matcher.matches(filename)) {</p><p>System.out.println(filename);</p><p>}</p><h4>12.11.15.1 Recursive Pattern Matching</h4><p>Searching for files that match a particular pattern goes hand-in-hand with walking a file tree. How many times do you know a file is <em>somewhere</em> on the file system, but where? Or perhaps you need to find all files in a file tree that have a particular file extension.</p><p>The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Find.java">Find</a> example does precisely that. Find is similar to the UNIX find utility, but has pared down functionally. You can extend this example to include other functionality. For example, the findutility supports the -prune flag to exclude an entire subtree from the search. You could implement that functionality by returning SKIP_SUBTREE in the preVisitDirectory method. To implement the -L option, which follows symbolic links, you could use the four-argument walkFileTree method and pass in the FOLLOW_LINKS enum (but make sure that you test for circular links in the visitFile method).</p><p>To run the Find application, use the following format:</p><pre><code class="language-bash">\% java Find &lt;path&gt; -name &quot;&lt;glob_pattern&gt;&quot;
</code></pre><p>The pattern is placed inside quotation marks so any wildcards are not interpreted by the shell. For example:</p><pre><code class="language-bash">\% java Find . -name &quot;\*.html&quot;
</code></pre><p>Here is the source code for the Find example:</p><pre><code class="language-java">/\*\*

\* Sample code that finds files that match the specified glob pattern.

\* For more information on what constitutes a glob pattern, see

\* https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html\#glob

\*

\* The file or directories that match the pattern are printed to

\* standard out. The number of matches is also printed.

\*

\* When executing this application, you must put the glob pattern

\* in quotes, so the shell will not expand any wild cards:

\* java Find . -name &quot;\*.java&quot;

\*/

import java.io.*;

import java.nio.file.*;

import java.nio.file.attribute.*;

import static java.nio.file.FileVisitResult.*;

import static java.nio.file.FileVisitOption.*;

import java.util.*;

public class Find {

public static class Finder

extends SimpleFileVisitor&lt;Path&gt; {

private final PathMatcher matcher;

private int numMatches = 0;

Finder(String pattern) {

matcher = FileSystems.getDefault()

.getPathMatcher(&quot;glob:&quot; + pattern);

}

// Compares the glob pattern against

// the file or directory name.

void find(Path file) {

Path name = file.getFileName();

if (name != null &amp;&amp; matcher.matches(name)) {

numMatches++;

System.out.println(file);

}

}

// Prints the total number of

// matches to standard out.

void done() {

System.out.println(&quot;Matched: &quot;

+ numMatches);

}

// Invoke the pattern matching

// method on each file.

\@Override

public FileVisitResult visitFile(Path file,

BasicFileAttributes attrs) {

find(file);

return CONTINUE;

}

// Invoke the pattern matching

// method on each directory.

\@Override

public FileVisitResult preVisitDirectory(Path dir,

BasicFileAttributes attrs) {

find(dir);

return CONTINUE;

}

\@Override

public FileVisitResult visitFileFailed(Path file,

IOException exc) {

System.err.println(exc);

return CONTINUE;

}

}

static void usage() {

System.err.println(&quot;java Find &lt;path&gt;&quot; +

&quot; -name \\&quot;&lt;glob_pattern&gt;\\&quot;&quot;);

System.exit(-1);

}

public static void main(String[] args)

throws IOException {

if (args.length &lt; 3 \|\| !args[1].equals(&quot;-name&quot;))

usage();

Path startingDir = Paths.get(args[0]);

String pattern = args[2];

Finder finder = new Finder(pattern);

Files.walkFileTree(startingDir, finder);

finder.done();

}

}
</code></pre><p>Recursively walking a file tree is covered in <a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html">Walking the File Tree</a>.</p><h3>12.11.16 Watching a Directory for Changes</h3><p>Have you ever found yourself editing a file, using an IDE or another editor, and a dialog box appears to inform you that one of the open files has changed on the file system and needs to be reloaded? Or perhaps, like the NetBeans IDE, the application just quietly updates the file without notifying you. The following sample dialog box shows how this notification looks with the free editor, <a href="http://sourceforge.net/projects/jedit/">jEdit</a>:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8nAwAI8AL4zIw8SAAAAABJRU5ErkJggg==" alt="Sample jEdit Dialog stating: The following files were changed on disk by another program."/></p><p>jEdit Dialog Box Showing That a Modified File Is Detected</p><p>To implement this functionality, called <em>file change notification</em>, a program must be able to detect what is happening to the relevant directory on the file system. One way to do so is to poll the file system looking for changes, but this approach is inefficient. It does not scale to applications that have hundreds of open files or directories to monitor.</p><p>The java.nio.file package provides a file change notification API, called the Watch Service API. This API enables you to register a directory (or directories) with the watch service. When registering, you tell the service which types of events you are interested in: file creation, file deletion, or file modification. When the service detects an event of interest, it is forwarded to the registered process. The registered process has a thread (or a pool of threads) dedicated to watching for any events it has registered for. When an event comes in, it is handled as needed.</p><p>This section covers the following:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html#overview">Watch Service Overview</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html#try">Try It Out</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html#register">Creating a Watch Service and Registering for Events</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html#process">Processing Events</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html#name">Retrieving the File Name</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html#concerns">When to Use and Not Use This API</a></li></ul><h4>12.11.16.1 Watch Service Overview</h4><p>The WatchService API is fairly low level, allowing you to customize it. You can use it as is, or you can choose to create a high-level API on top of this mechanism so that it is suited to your particular needs.</p><p>Here are the basic steps required to implement a watch service:</p><ul><li>Create a WatchService &quot;watcher&quot; for the file system.</li><li>For each directory that you want monitored, register it with the watcher. When registering a directory, you specify the type of events for which you want notification. You receive a WatchKey instance for each directory that you register.</li><li>Implement an infinite loop to wait for incoming events. When an event occurs, the key is signaled and placed into the watcher&#x27;s queue.</li><li>Retrieve the key from the watcher&#x27;s queue. You can obtain the file name from the key.</li><li>Retrieve each pending event for the key (there might be multiple events) and process as needed.</li><li>Reset the key, and resume waiting for events.</li><li>Close the service: The watch service exits when either the thread exits or when it is closed (by invoking its closed method).</li></ul><p>WatchKeys are thread-safe and can be used with the java.nio.concurrent package. You can dedicate a <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html">thread pool</a> to this effort.</p><h4>12.11.16.2 Try It Out</h4><p>Because this API is more advanced, try it out before proceeding. Save the <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/WatchDir.java">WatchDir</a> example to your computer, and compile it. Create a test directory that will be passed to the example. WatchDir uses a single thread to process all events, so it blocks keyboard input while waiting for events. Either run the program in a separate window, or in the background, as follows:</p><p>java WatchDir test &amp;</p><p>Play with creating, deleting, and editing files in the test directory. When any of these events occurs, a message is printed to the console. When you have finished, delete the test directory and WatchDir exits. Or, if you prefer, you can manually kill the process.</p><p>You can also watch an entire file tree by specifying the -r option. When you specify -r, WatchDir <a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html">walks the file tree</a>, registering each directory with the watch service.</p><h4>12.11.16.3 Creating a Watch Service and Registering for Events</h4><p>The first step is to create a new <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html">WatchService</a> by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#newWatchService--">newWatchService</a> method in the FileSystem class, as follows:</p><p>WatchService watcher = FileSystems.getDefault().newWatchService();</p><p>Next, register one or more objects with the watch service. Any object that implements the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Watchable.html">Watchable</a> interface can be registered. The Path class implements the Watchable interface, so each directory to be monitored is registered as a Path object.</p><p>As with any Watchable, the Path class implements two register methods. This page uses the two-argument version, <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#register-java.nio.file.WatchService-java.nio.file.WatchEvent.Kind...-">register(WatchService, WatchEvent.Kind&lt;?&gt;<!-- -->.<!-- -->..)</a>. (The three-argument version takes a WatchEvent.Modifier, which is not currently implemented.)</p><p>When registering an object with the watch service, you specify the types of events that you want to monitor. The supported <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/StandardWatchEventKinds.html">StandardWatchEventKinds</a> event types follow:</p><ul><li>ENTRY_CREATE -- A directory entry is created.</li><li>ENTRY_DELETE -- A directory entry is deleted.</li><li>ENTRY_MODIFY -- A directory entry is modified.</li><li>OVERFLOW -- Indicates that events might have been lost or discarded. You do not have to register for the OVERFLOW event to receive it.</li></ul><p>The following code snippet shows how to register a Path instance for all three event types:</p><pre><code class="language-java">import static java.nio.file.StandardWatchEventKinds.*;

Path dir = \...;

try {

WatchKey key = dir.register(watcher,

ENTRY_CREATE,

ENTRY_DELETE,

ENTRY_MODIFY);

} catch (IOException x) {

System.err.println(x);

}
</code></pre><h4>12.11.16.4 Processing Events</h4><p>The order of events in an event processing loop follow:</p><ol><li>Get a watch key. Three methods are provided:<ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html#poll--">poll</a> -- Returns a queued key, if available. Returns immediately with a null value, if unavailable.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html#poll-long-java.util.concurrent.TimeUnit-">poll(long, TimeUnit)</a> -- Returns a queued key, if one is available. If a queued key is not immediately available, the program waits until the specified time. The TimeUnitargument determines whether the specified time is nanoseconds, milliseconds, or some other unit of time.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html#take--">take</a> -- Returns a queued key. If no queued key is available, this method waits.</li></ul></li><li>Process the pending events for the key. You fetch the List of <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchEvent.html">WatchEvents</a>from the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchKey.html#pollEvents--">pollEvents</a> method.</li><li>Retrieve the type of event by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchEvent.html#kind--">kind</a> method. No matter what events the key has registered for, it is possible to receive an OVERFLOW event. You can choose to handle the overflow or ignore it, but you should test for it.</li><li>Retrieve the file name associated with the event. The file name is stored as the context of the event, so the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchEvent.html#context--">context</a> method is used to retrieve it.</li><li>After the events for the key have been processed, you need to put the key back into a ready state by invoking <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchEvent.html#reset--">reset</a>. If this method returns false, the key is no longer valid and the loop can exit. This step is very <strong>important</strong>. If you fail to invoke reset, this key will not receive any further events.</li></ol><p>A watch key has a state. At any given time, its state might be one of the following:</p><ul><li>Ready indicates that the key is ready to accept events. When first created, a key is in the ready state.</li><li>Signaled indicates that one or more events are queued. Once the key has been signaled, it is no longer in the ready state until the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchKey.html#reset--">reset</a> method is invoked.</li><li>Invalid indicates that the key is no longer active. This state happens when one of the following events occurs:<ul><li>The process explicitly cancels the key by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchKey.html#cancel--">cancel</a> method.</li><li>The directory becomes inaccessible.</li><li>The watch service is <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html#close--">closed</a>.</li></ul></li></ul><p>Here is an example of an event processing loop. It is taken from the <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Email.java">Email</a> example, which watches a directory, waiting for new files to appear. When a new file becomes available, it is examined to determine if it is a text/plain file by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#probeContentType-java.nio.file.Path-">probeContentType(Path)</a> method. The intention is that text/plain files will be emailed to an alias, but that implementation detail is left to the reader.</p><p>The methods specific to the watch service API are shown in bold:</p><pre><code class="language-java">for (;;) {
// wait for key to be signaled
WatchKey key;
try {

**key = watcher.take()**;

} catch (InterruptedException x) {

return;

}

for (WatchEvent&lt;?&gt; event: **key.pollEvents()**) {

WatchEvent.Kind&lt;?&gt; **kind = event.kind()**;

// This key is registered only

// for ENTRY_CREATE events,

// but an OVERFLOW event can

// occur regardless if events

// are lost or discarded.

**if (kind == OVERFLOW)** {

continue;

}

// The filename is the

// context of the event.

**WatchEvent&lt;Path&gt; ev = (WatchEvent&lt;Path&gt;)event;**

**Path filename = ev.context();**

// Verify that the new

// file is a text file.

try {

// Resolve the filename against the directory.

// If the filename is &quot;test&quot; and the directory is &quot;foo&quot;,

// the resolved name is &quot;test/foo&quot;.

Path child = dir.resolve(filename);

if (!Files.probeContentType(child).equals(&quot;text/plain&quot;)) {

System.err.format(&quot;New file &#x27;%s&#x27;&quot; +

&quot; is not a plain text file.%n&quot;, filename);

continue;

}

} catch (IOException x) {

System.err.println(x);

continue;

}

// Email the file to the

// specified email alias.

System.out.format(&quot;Emailing file %s%n&quot;, filename);

//Details left to reader\....

}

// Reset the key -- this step is critical if you want to

// receive further watch events. If the key is no longer valid,

// the directory is inaccessible so exit the loop.

boolean **valid = key.reset()**;

if (!valid) {

break;

}

}
</code></pre><h4>12.11.16.5 Retrieving the File Name</h4><p>The file name is retrieved from the event context. The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Email.java">Email</a> example retrieves the file name with this code:</p><pre><code class="language-java">WatchEvent&lt;Path&gt; ev = (WatchEvent&lt;Path&gt;)event;

Path filename = ev.context();
</code></pre><p>When you compile the Email example, it generates the following error:</p><p>Note: Email.java uses unchecked or unsafe operations.</p><p>Note: Recompile with -Xlint:unchecked for details.</p><p>This error is a result of the line of code that casts the <code>WatchEvent&lt;T&gt;</code> to a <code>WatchEvent&lt;Path&gt;</code>. The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/WatchDir.java">WatchDir</a> example avoids this error by creating a utility cast method that suppresses the unchecked warning, as follows:</p><pre><code class="language-java">@SuppressWarnings(&quot;unchecked&quot;)

static &lt;T&gt; WatchEvent&lt;T&gt; cast(WatchEvent&lt;?&gt; event) {

return (WatchEvent&lt;Path&gt;)event;

}
</code></pre><p>If you are unfamiliar with the \@SuppressWarnings syntax, see <a href="https://docs.oracle.com/javase/tutorial/java/annotations/index.html">Annotations</a>.</p><h4>12.11.16.6 When to Use and Not Use This API</h4><p>The Watch Service API is designed for applications that need to be notified about file change events. It is well suited for any application, like an editor or IDE, that potentially has many open files and needs to ensure that the files are synchronized with the file system. It is also well suited for an application server that watches a directory, perhaps waiting for .jsp or .jar files to drop, in order to deploy them.</p><p>This API is <em>not</em> designed for indexing a hard drive. Most file system implementations have native support for file change notification. The Watch Service API takes advantage of this support where available. However, when a file system does not support this mechanism, the Watch Service will poll the file system, waiting for events.</p><h3>12.11.17 Other Useful Methods</h3><p>A few useful methods did not fit elsewhere in this lesson and are covered here. This section covers the following:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/misc.html#mime">Determining MIME Type</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/misc.html#default">Default File System</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/misc.html#separator">Path String Separator</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/io/misc.html#stores">File System&#x27;s File Stores</a></li></ul><h4>12.11.17.1 Determining MIME Type</h4><p>To determine the MIME type of a file, you might find the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#probeContentType-java.nio.file.Path-">probeContentType(Path)</a> method useful. For example:</p><pre><code class="language-java">try {

String type = Files.probeContentType(filename);

if (type == null) {

System.err.format(&quot;&#x27;%s&#x27; has an&quot; + &quot; unknown filetype.%n&quot;, filename);

} else if (!type.equals(&quot;text/plain&quot;) {

System.err.format(&quot;&#x27;%s&#x27; is not&quot; + &quot; a plain text file.%n&quot;, filename);

continue;

}

} catch (IOException x) {

System.err.println(x);

}
</code></pre><p>Note that probeContentType returns null if the content type cannot be determined.</p><p>The implementation of this method is highly platform specific and is not infallible. The content type is determind by the platform&#x27;s default file type detector. For example, if the detector determines a file&#x27;s content type to be application/x-java based on the .class extension, it might be fooled.</p><p>You can provide a custom <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/spi/FileTypeDetector.html">FileTypeDetector</a> if the default is not sufficient for your needs.</p><p>The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Email.java">Email</a> example uses the probeContentType method.</p><h4>12.11.17.2 Default File System</h4><p>To retrieve the default file system, use the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystems.html#getDefault--">getDefault</a> method. Typically, this FileSystems method (note the plural) is chained to one of the FileSystem methods (note the singular), as follows:</p><p>PathMatcher matcher =</p><p>FileSystems.getDefault().getPathMatcher(&quot;glob:<!-- -->*<!-- -->.*&quot;);</p><h4>12.11.17.3 Path String Separator</h4><p>The path separator for POSIX file systems is the forward slash, /, and for Microsoft Windows is the backslash, <!-- -->\<!-- -->. Other file systems might use other delimiters. To retrieve the Path separator for the default file system, you can use one of the following approaches:</p><p>String separator = File.separator;</p><p>String separator = FileSystems.getDefault().getSeparator();</p><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getSeparator--">getSeparator</a> method is also used to retrieve the path separator for any available file system.</p><h4>12.11.17.4 File System&#x27;s File Stores</h4><p>A file system has one or more file stores to hold its files and directories. The <em>file store</em> represents the underlying storage device. In UNIX operating systems, each mounted file system is represented by a file store. In Microsoft Windows, each volume is represented by a file store: C:, D:, and so on.</p><p>To retrieve a list of all the file stores for the file system, you can use the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getFileStores--">getFileStores</a> method. This method returns an Iterable, which allows you to use the <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html">enhanced for</a> statement to iterate over all the root directories.</p><p>for (FileStore store: FileSystems.getDefault().getFileStores()) {</p><p>.<!-- -->..</p><p>}</p><p>If you want to retrive the file store where a particular file is located, use the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getFileStore-java.nio.file.Path-">getFileStore</a> method in the Files class, as follows:</p><p>Path file = <!-- -->.<!-- -->..;</p><p>FileStore store= Files.getFileStore(file);</p><p>The <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/DiskUsage.java">DiskUsage</a> example uses the getFileStores method.</p><h2>12.12 Legacy File I/O Code</h2><h3>12.12.1 Interoperability With Legacy Code</h3><p>Prior to the Java SE 7 release, the java.io.File class was the mechanism used for file I/O, but it had several drawbacks.</p><ul><li>Many methods didn&#x27;t throw exceptions when they failed, so it was impossible to obtain a useful error message. For example, if a file deletion failed, the program would receive a &quot;delete fail&quot; but wouldn&#x27;t know if it was because the file didn&#x27;t exist, the user didn&#x27;t have permissions, or there was some other problem.</li><li>The rename method didn&#x27;t work consistently across platforms.</li><li>There was no real support for symbolic links.</li><li>More support for metadata was desired, such as file permissions, file owner, and other security attributes.</li><li>Accessing file metadata was inefficient.</li><li>Many of the File methods didn&#x27;t scale. Requesting a large directory listing over a server could result in a hang. Large directories could also cause memory resource problems, resulting in a denial of service.</li><li>It was not possible to write reliable code that could recursively walk a file tree and respond appropriately if there were circular symbolic links.</li></ul><p>Perhaps you have legacy code that uses java.io.File and would like to take advantage of the java.nio.file.Path functionality with minimal impact to your code.</p><p>The java.io.File class provides the <a href="https://docs.oracle.com/javase/8/docs/api/java/io/File.html#toPath--">toPath</a> method, which converts an old style File instance to a java.nio.file.Path instance, as follows:</p><p>Path input = file.toPath();</p><p>You can then take advantage of the rich feature set available to the Path class.</p><p>For example, assume you had some code that deleted a file:</p><p>file.delete();</p><p>You could modify this code to use the Files.delete method, as follows:</p><p>Path fp = file.toPath();</p><p>Files.delete(fp);</p><p>Conversely, the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#toFile--">Path.toFile</a> method constructs a java.io.File object for a Path object.</p><h3>12.12.2 Mapping java.io.File Functionality to java.nio.file</h3><p>Because the Java implementation of file I/O has been completely re-architected in the Java SE 7 release, you cannot swap one method for another method. If you want to use the rich functionality offered by the java.nio.file package, your easiest solution is to use the <a href="https://docs.oracle.com/javase/8/docs/api/java/io/File.html#toPath--">File.toPath</a> method as suggested in the previous section. However, if you do not want to use that approach or it is not sufficient for your needs, you must rewrite your file I/O code.</p><p>There is no one-to-one correspondence between the two APIs, but the following table gives you a general idea of what functionality in the java.io.File API maps to in the java.nio.fileAPI and tells you where you can obtain more information.</p><p>+-----------------------+-----------------------+-----------------------+
| <strong>java.io.File        | </strong>java.nio.file       | <strong>Tutorial Coverage</strong> |
| Functionality<strong>       | Functionality</strong>       |                       |
+-----------------------+-----------------------+-----------------------+
| java.io.File          | java.nio.file.Path    | <!-- -->[The Path             |
|                       |                       | Class]<!-- -->(https          |
|                       |                       | ://docs.oracle.com/ja |
|                       |                       | vase/tutorial/essenti |
|                       |                       | al/io/pathClass.html) |
+-----------------------+-----------------------+-----------------------+
| jav                   | The SeekableByteC     | <!-- -->[Random Access        |
| a.io.RandomAccessFile | hannel functionality. | Files]<!-- -->(               |
|                       |                       | <a href="https://docs.oracle.c">https://docs.oracle.c</a> |
|                       |                       | om/javase/tutorial/es |
|                       |                       | sential/io/rafs.html) |
+-----------------------+-----------------------+-----------------------+
| File.canRead,         | Files.isReadab        | <!-- -->[Checking a File or   |
|  canWrite, canExecute | le, Files.isWritable, | Directory]<!-- -->(ht         |
|                       | and                   | tps://docs.oracle.com |
|                       |  Files.isExecutable.\ | /javase/tutorial/esse |
|                       | On UNIX file systems, | ntial/io/check.html)\ |
|                       | the [Managing         | <!-- -->[Managing             |
|                       | Metadata (File and    | Metadata]<!-- -->(http        |
|                       | File Store            | s://docs.oracle.com/j |
|                       | Attr                  | avase/tutorial/essent |
|                       | ibutes)](https://docs | ial/io/fileAttr.html) |
|                       | .oracle.com/javase/tu |                       |
|                       | torial/essential/io/f |                       |
|                       | ileAttr.html) package |                       |
|                       | is used to check the  |                       |
|                       | nine file             |                       |
|                       | permissions.          |                       |
+-----------------------+-----------------------+-----------------------+
| File.isDirect         | Fi                    | <!-- -->[Managing             |
| ory(), File.isFile(), | les.isDirectory(Path, | Metadata]<!-- -->(http        |
| and File.length()     | LinkOption<!-- -->.<!-- -->..), File | s://docs.oracle.com/j |
|                       | s.isRegularFile(Path, | avase/tutorial/essent |
|                       | LinkOption<!-- -->.<!-- -->..),      | ial/io/fileAttr.html) |
|                       | and Files.size(Path)  |                       |
+-----------------------+-----------------------+-----------------------+
| File.las              | Files.getL            | <!-- -->[Managing             |
| tModified() and File. | astModifiedTime(Path, | Metadata]<!-- -->(http        |
| setLastModified(long) | LinkOptio             | s://docs.oracle.com/j |
|                       | n<!-- -->.<!-- -->..) and Files.setL | avase/tutorial/essent |
|                       | astMOdifiedTime(Path, | ial/io/fileAttr.html) |
|                       | FileTime)             |                       |
+-----------------------+-----------------------+-----------------------+
| The File methods that | These methods are     | <!-- -->[Managing             |
| set various           | replaced by           | Metadata]<!-- -->(http        |
| a                     | the Files meth        | s://docs.oracle.com/j |
| ttributes: setExecuta | od setAttribute(Path, | avase/tutorial/essent |
| ble, setReadable, set | String, Object,       | ial/io/fileAttr.html) |
| ReadOnly, setWritable | LinkOption<!-- -->.<!-- -->..).      |                       |
+-----------------------+-----------------------+-----------------------+
| new File(parent,      | parent                | <!-- -->[Path                 |
| &quot;newfile&quot;)          | .resolve(&quot;newfile&quot;) | Operations]<!-- -->(htt       |
|                       |                       | ps://docs.oracle.com/ |
|                       |                       | javase/tutorial/essen |
|                       |                       | tial/io/pathOps.html) |
+-----------------------+-----------------------+-----------------------+
| File.renameTo         | Files.move            | <!-- -->[Moving a File or     |
|                       |                       | Directory]<!-- -->(           |
|                       |                       | <a href="https://docs.oracle.c">https://docs.oracle.c</a> |
|                       |                       | om/javase/tutorial/es |
|                       |                       | sential/io/move.html) |
+-----------------------+-----------------------+-----------------------+
| File.delete           | Files.delete          | <!-- -->[Deleting a File or   |
|                       |                       | Directory]<!-- -->(ht         |
|                       |                       | tps://docs.oracle.com |
|                       |                       | /javase/tutorial/esse |
|                       |                       | ntial/io/delete.html) |
+-----------------------+-----------------------+-----------------------+
| File.createNewFile    | Files.createFile      | <!-- -->[Creating             |
|                       |                       | Files]<!-- -->(https://doc    |
|                       |                       | s.oracle.com/javase/t |
|                       |                       | utorial/essential/io/ |
|                       |                       | file.html#createFile) |
+-----------------------+-----------------------+-----------------------+
| File.deleteOnExit     | Replaced by           | <!-- -->[Creating             |
|                       | the D                 | Files]<!-- -->(https://doc    |
|                       | ELETE_ON_CLOSE option | s.oracle.com/javase/t |
|                       | specified in          | utorial/essential/io/ |
|                       | t                     | file.html#createFile) |
|                       | he createFile method. |                       |
+-----------------------+-----------------------+-----------------------+
| File.createTempFile   | Files                 | <!-- -->[Creating             |
|                       | .createTempFile(Path, | Files]<!-- -->(https://docs   |
|                       | String,               | .oracle.com/javase/tu |
|                       | FileAt                | torial/essential/io/f |
|                       | tributes&lt;?&gt;), Files | ile.html#createFile)\ |
|                       | .createTempFile(Path, | <!-- -->[Creating and Writing |
|                       | String, String,       | a File by Using       |
|                       | FileAttributes&lt;?&gt;)  | Stream                |
|                       |                       | I/O]<!-- -->(<a href="https://docs.o">https://docs.o</a>   |
|                       |                       | racle.com/javase/tuto |
|                       |                       | rial/essential/io/fil |
|                       |                       | e.html#createStream)\ |
|                       |                       | <!-- -->[Reading and Writing  |
|                       |                       | Files by Using        |
|                       |                       | Channel               |
|                       |                       | I/O]<!-- -->(https://do       |
|                       |                       | cs.oracle.com/javase/ |
|                       |                       | tutorial/essential/io |
|                       |                       | /file.html#channelio) |
+-----------------------+-----------------------+-----------------------+
| File.exists           | Files.exist           | <!-- -->[Verifying the        |
|                       | s and Files.notExists | Existence of a File   |
|                       |                       | or                    |
|                       |                       | Directory]<!-- -->(h          |
|                       |                       | ttps://docs.oracle.co |
|                       |                       | m/javase/tutorial/ess |
|                       |                       | ential/io/check.html) |
+-----------------------+-----------------------+-----------------------+
| File                  | Path                  | <!-- -->[Comparing Two        |
| .compareTo and equals | .compareTo and equals | Paths]<!-- -->(https://doc    |
|                       |                       | s.oracle.com/javase/t |
|                       |                       | utorial/essential/io/ |
|                       |                       | pathOps.html#compare) |
+-----------------------+-----------------------+-----------------------+
| File.getAbsolutePat   | Path.toAbsolutePath   | <!-- -->[Converting a         |
| h and getAbsoluteFile |                       | Path]<!-- -->(https://doc     |
|                       |                       | s.oracle.com/javase/t |
|                       |                       | utorial/essential/io/ |
|                       |                       | pathOps.html#convert) |
+-----------------------+-----------------------+-----------------------+
| File.getCanonicalPath | Path.to               | <!-- -->[Converting a Path    |
|  and getCanonicalFile | RealPath or normalize | (toRe                 |
|                       |                       | alPath)]<!-- -->(https://docs |
|                       |                       | .oracle.com/javase/tu |
|                       |                       | torial/essential/io/p |
|                       |                       | athOps.html#convert)\ |
|                       |                       | <!-- -->[Removing             |
|                       |                       | Redundancies From a   |
|                       |                       | Path                  |
|                       |                       | (n                    |
|                       |                       | ormalize)]<!-- -->(https://do |
|                       |                       | cs.oracle.com/javase/ |
|                       |                       | tutorial/essential/io |
|                       |                       | /pathOps.html#normal) |
+-----------------------+-----------------------+-----------------------+
| File.toURI            | Path.toURI            | <!-- -->[Converting a         |
|                       |                       | Path]<!-- -->(https://doc     |
|                       |                       | s.oracle.com/javase/t |
|                       |                       | utorial/essential/io/ |
|                       |                       | pathOps.html#convert) |
+-----------------------+-----------------------+-----------------------+
| File.isHidden         | Files.isHidden        | <!-- -->[Retrieving           |
|                       |                       | Information About the |
|                       |                       | Path]<!-- -->(https://        |
|                       |                       | docs.oracle.com/javas |
|                       |                       | e/tutorial/essential/ |
|                       |                       | io/pathOps.html#info) |
+-----------------------+-----------------------+-----------------------+
| Fi                    | Pa                    | <!-- -->[Listing a            |
| le.list and listFiles | th.newDirectoryStream | Directory&#x27;s          |
|                       |                       | Contents]<!-- -->(https://    |
|                       |                       | docs.oracle.com/javas |
|                       |                       | e/tutorial/essential/ |
|                       |                       | io/dirs.html#listdir) |
+-----------------------+-----------------------+-----------------------+
| File.mkdir and mkdirs | Path.createDirectory  | <!-- -->[Creating a           |
|                       |                       | Directory]<!-- -->(https:/    |
|                       |                       | /docs.oracle.com/java |
|                       |                       | se/tutorial/essential |
|                       |                       | /io/dirs.html#create) |
+-----------------------+-----------------------+-----------------------+
| File.listRoots        | FileSyst              | <!-- -->[Listing a File       |
|                       | em.getRootDirectories | System&#x27;s Root        |
|                       |                       | Directories]<!-- -->(https:// |
|                       |                       | docs.oracle.com/javas |
|                       |                       | e/tutorial/essential/ |
|                       |                       | io/dirs.html#listall) |
+-----------------------+-----------------------+-----------------------+
| File.getTotalSpa      | FileStore.getTotalSpa | <!-- -->[File Store           |
| ce, File.getFreeSpace | ce, FileStore.getUnal | A                     |
| , File.getUsableSpace | locatedSpace, FileSto | ttributes]<!-- -->(https://do |
|                       | re.getUsableSpace, Fi | cs.oracle.com/javase/ |
|                       | leStore.getTotalSpace | tutorial/essential/io |
|                       |                       | /fileAttr.html#store) |
+-----------------------+-----------------------+-----------------------+</p><h2>12.13 Summary</h2><p>The java.io package contains many classes that your programs can use to read and write data. Most of the classes implement sequential access streams. The sequential access streams can be divided into two groups: those that read and write bytes and those that read and write Unicode characters. Each sequential access stream has a speciality, such as reading from or writing to a file, filtering data as its read or written, or serializing an object.</p><p>The java.nio.file package provides extensive support for file and file system I/O. This is a very comprehensive API, but the key entry points are as follows:</p><ul><li>The Path class has methods for manipulating a path.</li><li>The Files class has methods for file operations, such as moving, copy, deleting, and also methods for retrieving and setting file attributes.</li><li>The FileSystem class has a variety of methods for obtaining information about the file system.</li></ul><p>More information on NIO.2 can be found on the <a href="http://openjdk.java.net/projects/nio/">OpenJDK: NIO</a> project website. This site includes resources for features provided by NIO.2 that are beyond the scope of this tutorial, such as multicasting, asynchronous I/O, and creating your own file system implementation.</p><h1>13 Collections</h1><p>A <em>collection</em> --- sometimes called a container --- is simply an object that groups multiple elements into a single unit. Collections are used to store, retrieve, manipulate, and communicate aggregate data. Typically, they represent data items that form a natural group, such as a poker hand (a collection of cards), a mail folder (a collection of letters), or a telephone directory (a mapping of names to phone numbers). If you have used the Java programming language --- or just about any other programming language --- you are already familiar with collections.</p><h2>13.1 What Is a Collections Framework?</h2><p>A <em>collections framework</em> is a unified architecture for representing and manipulating collections. All collections frameworks contain the following:</p><ul><li><strong>Interfaces:</strong> These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details of their representation. In object-oriented languages, interfaces generally form a hierarchy.</li><li><strong>Implementations:</strong> These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures.</li><li><strong>Algorithms:</strong> These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. The algorithms are said to be <em>polymorphic</em>: that is, the same method can be used on many different implementations of the appropriate collection interface. In essence, algorithms are reusable functionality.</li></ul><p>Apart from the Java Collections Framework, the best-known examples of collections frameworks are the C++ Standard Template Library (STL) and Smalltalk&#x27;s collection hierarchy. Historically, collections frameworks have been quite complex, which gave them a reputation for having a steep learning curve. We believe that the Java Collections Framework breaks with this tradition, as you will learn for yourself in this chapter.</p><h2>13.2 Benefits of the Java Collections Framework</h2><p>The Java Collections Framework provides the following benefits:</p><ul><li><strong>Reduces programming effort:</strong> By providing useful data structures and algorithms, the Collections Framework frees you to concentrate on the important parts of your program rather than on the low-level &quot;plumbing&quot; required to make it work. By facilitating interoperability among unrelated APIs, the Java Collections Framework frees you from writing adapter objects or conversion code to connect APIs.</li><li><strong>Increases program speed and quality:</strong> This Collections Framework provides high-performance, high-quality implementations of useful data structures and algorithms. The various implementations of each interface are interchangeable, so programs can be easily tuned by switching collection implementations. Because you&#x27;re freed from the drudgery of writing your own data structures, you&#x27;ll have more time to devote to improving programs&#x27; quality and performance.</li><li><strong>Allows interoperability among unrelated APIs:</strong> The collection interfaces are the vernacular by which APIs pass collections back and forth. If my network administration API furnishes a collection of node names and if your GUI toolkit expects a collection of column headings, our APIs will interoperate seamlessly, even though they were written independently.</li><li><strong>Reduces effort to learn and to use new APIs:</strong> Many APIs naturally take collections on input and furnish them as output. In the past, each such API had a small sub-API devoted to manipulating its collections. There was little consistency among these ad hoc collections sub-APIs, so you had to learn each one from scratch, and it was easy to make mistakes when using them. With the advent of standard collection interfaces, the problem went away.</li><li><strong>Reduces effort to design new APIs:</strong> This is the flip side of the previous advantage. Designers and implementers don&#x27;t have to reinvent the wheel each time they create an API that relies on collections; instead, they can use standard collection interfaces.</li><li><strong>Fosters software reuse:</strong> New data structures that conform to the standard collection interfaces are by nature reusable. The same goes for new algorithms that operate on objects that implement these interfaces.</li></ul><h2>13.3 Interfaces</h2><p>The <em>core collection interfaces</em> encapsulate different types of collections, which are shown in the figure below. These interfaces allow collections to be manipulated independently of the details of their representation. Core collection interfaces are the foundation of the Java Collections Framework. As you can see in the following figure, the core collection interfaces form a hierarchy.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8BAwAIvgLfv+8lTwAAAABJRU5ErkJggg==" alt="Two interface trees, one starting with Collection and including Set, SortedSet, List, and Queue, and the other starting with Map and including SortedMap."/></p><p>A Set is a special kind of Collection, a SortedSet is a special kind of Set, and so forth. Note also that the hierarchy consists of two distinct trees --- a Map is not a true Collection.</p><p>Note that all the core collection interfaces are generic. For example, this is the declaration of the Collection interface.</p><ol><li><strong>public</strong> <strong>interface</strong> Collection &lt; E &gt; <!-- -->.<!-- -->..  </li></ol><p>The <code>&lt;E&gt;</code> syntax tells you that the interface is generic. When you declare a Collection instance you can <em>and should</em> specify the type of object contained in the collection. Specifying the type allows the compiler to verify (at compile-time) that the type of object you put into the collection is correct, thus reducing errors at runtime.</p><p>To keep the number of core collection interfaces manageable, the Java platform doesn&#x27;t provide separate interfaces for each variant of each collection type. (Such variants might include <strong>immutable, fixed-size, and append-only</strong>.) Instead, the <strong>modification operations in each interface are designated <em>optional</em></strong> --- a given implementation may elect not to support all operations. If an unsupported operation is invoked, a <strong>collection throws an </strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html"><strong>UnsupportedOperationException</strong></a><strong>.</strong> Implementations are responsible for documenting which of the optional operations they support.</p><p>The following list describes the core collection interfaces:</p><ul><li><strong>Collection</strong> --- the root of the collection hierarchy. A collection represents a group of objects known as its <em>elements</em>. The Collection interface is the least common denominator that all collections implement and is used to pass collections around and to manipulate them when maximum generality is desired. Some types of <strong>collections allow duplicate elements, and others do not. Some are ordered and others are unordered.</strong> The Java platform doesn&#x27;t provide any direct implementations of this interface but provides implementations of more specific sub interfaces, such as Set and List.</li><li><strong>Set</strong> --- a <strong>collection that cannot contain duplicate elements</strong>. This interface models the mathematical set abstraction and is used to represent sets, such as the cards comprising a poker hand, the courses making up a student&#x27;s schedule, or the processes running on a machine.</li><li><strong>List</strong> --- <strong>an ordered collection</strong> (sometimes called a <em>sequence</em>). <strong>Lists can contain duplicate elements</strong>. The user of a List generally has precise control over where in the list each element is inserted and can <strong>access elements by their integer index (position)</strong>. If you&#x27;ve used Vector, you&#x27;re familiar with the general flavor of List.</li><li><strong>Queue</strong> --- a collection used to <strong>hold multiple elements prior to processing</strong>. Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations.</li><li>Queues typically, but do not necessarily, order elements in a FIFO (first-in, first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator or the elements&#x27; natural ordering. Whatever the ordering used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. Also see<a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html">The Queue Interface</a> </li><li>Deque --- a collection used to hold multiple elements prior to processing. Besides basic Collection operations, a Deque provides additional insertion, extraction, and inspection operations.</li><li>Deques can be used both as FIFO (first-in, first-out) and LIFO (last-in, first-out). In a deque all new elements can be inserted, retrieved and removed at both ends. Also see <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html">The Deque Interface</a> section.</li><li>Map --- an object that maps keys to values. A Map cannot contain duplicate keys; each key can map to at most one value. Also see <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html">The Map Interface</a> section.</li></ul><p>The last two core collection interfaces are merely sorted versions of Set and Map:</p><ul><li>SortedSet --- a Set that maintains its elements in ascending order. Several additional operations are provided to take advantage of the ordering. Sorted sets are used for naturally ordered sets, such as word lists and membership rolls. Also see <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/sorted-set.html">The SortedSet Interface</a> section.</li><li>SortedMap --- a Map that maintains its mappings in ascending key order. This is the Map analog of SortedSet. Sorted maps are used for naturally ordered collections of key/value pairs, such as dictionaries and telephone directories. Also see <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/sorted-map.html">The SortedMap Interface</a> section.</li></ul><p>To understand how the sorted interfaces maintain the order of their elements, see the <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/order.html">Object Ordering</a> section.</p><h3>13.3.1 The Collection Interface</h3><p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection</a> represents a group of objects known as its elements. The Collection interface is used to pass around collections of objects where maximum generality is desired. For example, by convention all general-purpose collection implementations have a constructor that takes a Collection argument. This constructor, known as a <em>conversion constructor</em>, initializes the new collection to contain all of the elements in the specified collection, whatever the given collection&#x27;s subinterface or implementation type. In other words, it allows you to <em>convert</em> the collection&#x27;s type.</p><p>Suppose, for example, that you have a <code>Collection&lt;String&gt;</code> c, which may be a List, a Set, or another kind of Collection. This idiom creates a new ArrayList (an implementation of the List interface), initially containing all the elements in c.</p><ol><li>List &lt; String &gt; list = <strong>new</strong> ArrayList &lt; String &gt; (c);  </li></ol><p>Or --- if you are using JDK 7 or later --- you can use the diamond operator:</p><ol><li>List &lt; String &gt; list = <strong>new</strong> ArrayList &lt; &gt; (c);  </li></ol><p><strong>The Collection interface contains methods that perform basic operations, such as int size(), boolean isEmpty(), boolean contains(Object element), boolean add(E element), boolean remove(Object element), and <code>Iterator&lt;E&gt;</code> iterator().</strong></p><p><strong>It also contains methods that operate on entire collections, such as boolean containsAll(Collection&lt;?&gt; c), boolean addAll(Collection&lt;? extends E&gt; c), boolean removeAll(Collection&lt;?&gt; c), boolean retainAll(Collection&lt;?&gt; c), and void clear().</strong></p><p><strong>Additional methods for array operations (such as Object[] toArray() and <code>&lt;T&gt;</code> T[] toArray(T[] a) exist as well.</strong></p><p>In JDK 8 and later, the Collection interface also exposes methods <strong><code>Stream&lt;E&gt;</code> stream()</strong> and <strong><code>Stream&lt;E&gt;</code> parallelStream()</strong>, for obtaining sequential or parallel streams from the underlying collection.</p><p>The Collection interface does about what you&#x27;d expect given that a Collection represents a group of objects. It has methods that tell you how many elements are in the collection (size, isEmpty), methods that check whether a given object is in the collection (contains), methods that add and remove an element from the collection (add, remove), and methods that provide an iterator over the collection (iterator).</p><p>The add method is defined generally enough so that it makes sense for collections that allow duplicates as well as those that don&#x27;t. It guarantees that the Collection will contain the specified element after the call completes and returns true if the Collection changes as a result of the call. Similarly, the remove method is designed to remove a single instance of the specified element from the Collection, assuming that it contains the element to start with, and to return true if the Collection was modified as a result.[]{#bookmark=id.2bgtojm}</p><h4>13.3.1.1 Traversing Collections</h4><p>There are three ways to traverse collections: (1) using aggregate operations (2) with the for-each construct and (3) by using Iterators.[]{#bookmark=id.qm3yrf}</p><h5>13.3.1.1.1 Aggregate Operations</h5><p>In JDK 8 and later, the preferred method of iterating over a collection is to obtain a stream and perform aggregate operations on it. Aggregate operations are often used in conjunction with lambda expressions to make programming more expressive, using less lines of code. The following code sequentially iterates through a collection of shapes and prints out the red objects:</p><ol><li>myShapesCollection.stream().filter(e - &gt; e.getColor() == Color.RED).forEach(e - &gt; System.out.println(e.getName()));  </li></ol><p>Likewise, you could easily request a parallel stream, which might make sense if the collection is large enough and your computer has enough cores:</p><ol><li>myShapesCollection.parallelStream().filter(e - &gt; e.getColor() == Color.RED).forEach(e - &gt; System.out.println(e.getName()));  </li></ol><p>There are many different ways to collect data with this API. For example, you might want to convert the elements of a Collection to String objects, then join them, separated by commas:</p><ol><li>String joined = elements.stream().map(Object::toString).collect(Collectors.joining(&quot;, &quot;));  </li></ol><p>Or perhaps sum the salaries of all employees:</p><ol><li><strong>int</strong> total = employees.stream().collect(Collectors.summingInt(Employee::getSalary)));  </li></ol><p>These are but a few examples of what you can do with streams and aggregate operations. For more information and examples, see the lesson entitled <a href="https://docs.oracle.com/javase/tutorial/collections/streams/index.html">Aggregate Operations</a>.</p><p>The Collections framework has always provided a number of so-called &quot;bulk operations&quot; as part of its API. These include methods that operate on entire collections, such as containsAll, addAll, removeAll, etc. Do not confuse those methods with the aggregate operations that were introduced in JDK 8. The key difference between the new aggregate operations and the existing bulk operations (containsAll, addAll, etc.) is that the old versions are all <em>mutative</em>, meaning that they all modify the underlying collection. In contrast, the new aggregate operations <em>do not</em> modify the underlying collection. When using the new aggregate operations and lambda expressions, you must take care to avoid mutation so as not to introduce problems in the future, should your code be run later from a parallel stream.</p><h5>13.3.1.1.2 for-each Construct</h5><p>The for-each construct allows you to concisely traverse a collection or array using a for loop --- see <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html">The for Statement</a>. The following code uses the for-each construct to print out each element of a collection on a separate line.</p><p>[]{#bookmark=id.3alrhf8}</p><ol><li><strong>for</strong> (Object o: collection) System.out.println(o);  </li></ol><h5>13.3.1.1.3 Iterators</h5><p>An <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">Iterator</a> is an object that enables you to traverse through a collection and to remove elements from the collection selectively, if desired. You get an Iterator for a collection by calling its iterator method. The following is the Iterator interface.</p><ol><li><strong>public</strong> <strong>interface</strong> Iterator &lt; E &gt; {  </li><li>    <strong>boolean</strong> hasNext();  </li><li>    E next();  </li><li>    <strong>void</strong> remove(); //optional  </li><li>}  </li></ol><p>The hasNext method returns true if the iteration has more elements, and the next method returns the next element in the iteration. The remove method removes the last element that was returned by next from the underlying Collection. <strong>The remove method may be called only once per call to next and throws an exception if this rule is violated</strong>.</p><p>Note that <strong>Iterator.remove is the <em>only</em> safe way to modify a collection during iteration</strong>; the behavior is unspecified if the underlying collection is modified in any other way while the iteration is in progress.</p><p>Use Iterator instead of the for-each construct when you need to:</p><ul><li>Remove the current element. The for-each construct hides the iterator, so you cannot call remove. Therefore, the for-each construct is not usable for filtering.</li><li>Iterate over multiple collections in parallel.</li></ul><p>The following method shows you how to use an Iterator to filter an arbitrary Collection --- that is, traverse the collection removing specific elements.</p><ol><li><strong>static</strong> <strong>void</strong> filter(Collection &lt;? &gt; c) {  </li><li>    <strong>for</strong> (Iterator &lt;? &gt; it = c.iterator(); it.hasNext();)  </li><li>        <strong>if</strong> (!cond(it.next())) it.remove();  </li><li>}  </li></ol><p>This simple piece of code is polymorphic, which means that it works for <em>any</em> Collection regardless of implementation. This example demonstrates how easy it is to write a polymorphic algorithm using the Java Collections Framework.</p><h4>13.3.1.2 Collection Interface Bulk Operations</h4><p><em>Bulk operations</em> perform an operation on an entire Collection. You could implement these shorthand operations using the basic operations, though in most cases such implementations would be less efficient. The following are the bulk operations:</p><ul><li>containsAll --- returns true if the target Collection contains all of the elements in the specified Collection.</li><li>addAll --- adds all of the elements in the specified Collection to the target Collection.</li><li>removeAll --- removes from the target Collection all of its elements that are also contained in the specified Collection.</li><li>retainAll --- removes from the target Collection all its elements that are not also contained in the specified Collection. That is, it retains only those elements in the target Collection that are also contained in the specified Collection.</li><li>clear --- removes all elements from the Collection.</li></ul><p>The addAll, removeAll, and retainAll methods all return true if the target Collection was modified in the process of executing the operation. As a simple example of the power of bulk operations, consider the following idiom to remove <em>all</em> instances of a specified element, e, from a Collection, c.</p><ol><li>c.removeAll(Collections.singleton(e));  </li></ol><p>More specifically, suppose you want to remove all of the null elements from a Collection.</p><ol><li>c.removeAll(Collections.singleton(<strong>null</strong>));  </li></ol><p>This idiom uses Collections.singleton, which is a static factory method that returns an immutable Set containing only the specified element.[]{#bookmark=id.1pr1rn1}</p><h4>13.3.1.3 Collection Interface Array Operations</h4><p>The toArray methods are provided as a bridge between collections and older APIs that expect arrays on input. The array operations allow the contents of a Collection to be translated into an array. The simple form with no arguments creates a new array of Object. The more complex form allows the caller to provide an array or to choose the runtime type of the output array.</p><p>For example, suppose that c is a Collection. The following snippet <strong>dumps the contents of c into a newly allocated array of Object whose length is identical to the number of elements in c</strong>.</p><ol><li>Object[] a = c.toArray();  </li></ol><p>Suppose that c is known to contain only strings (perhaps because c is of type <code>Collection&lt;String&gt;</code>). The following snippet <strong>dumps the contents of c into a newly allocated array of String whose length is identical to the number of elements in c</strong>.</p><ol><li>String[] a = c.toArray(<strong>new</strong> String<!-- -->[0]<!-- -->);  </li></ol><p><a href="https://stackoverflow.com/questions/3293946/the-easiest-way-to-transform-collection-to-array">https://stackoverflow.com/questions/3293946/the-easiest-way-to-transform-collection-to-array</a></p><h3>13.3.2 The Set Interface</h3><p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html">Set</a> is a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection</a> that cannot contain duplicate elements. It models the mathematical set abstraction. The Set interface contains <em>only</em> methods inherited from Collection and adds the restriction that duplicate elements are prohibited. Set also adds a stronger contract on the behavior of the equals and hashCode operations, allowing Set instances to be compared meaningfully even if their implementation types differ. Two Set instances are equal if they contain the same elements.</p><p>The Java platform contains three general-purpose Set implementations: <strong>HashSet, TreeSet, and LinkedHashSet.</strong> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html"><strong>HashSet</strong></a><strong>, which stores its elements in a hash table</strong>, is the best-performing implementation; however it makes no guarantees concerning the order of iteration. <a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html"><strong>TreeSet</strong></a><strong>, which stores its elements in a red-black tree</strong>, orders its elements based on their values; it is <strong>substantially slower than HashSet</strong>. <a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashSet.html"><strong>LinkedHashSet</strong></a><strong>, which is implemented as a hash table with a linked list running through it, orders its elements based on the order in which they were inserted into the set (insertion-order)</strong>. LinkedHashSet spares its clients from the unspecified, generally chaotic ordering provided by HashSet at a cost that is only slightly higher.</p><p>Here&#x27;s a simple but useful Set idiom. Suppose you have a Collection, c, and you want to create another <strong>Collection containing the same elements but with all duplicates eliminated</strong>. The following one-liner does the trick.</p><ol><li>Collection &lt; Type &gt; noDups = <strong>new</strong> HashSet &lt; Type &gt; (c);  </li></ol><p>It works by creating a Set (which, by definition, cannot contain duplicates), initially containing all the elements in c. It uses the standard conversion constructor described in the <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html">The Collection Interface</a> section.</p><p>Or, if using JDK 8 or later, you could easily collect into a Set using aggregate operations:</p><ol><li>c.stream().collect(Collectors.toSet()); // no duplicates  </li></ol><p>Here&#x27;s a slightly longer example that accumulates a Collection of names into a TreeSet:</p><ol><li>Set &lt; String &gt; set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::<strong>new</strong>));  </li></ol><p>And the following is a minor variant of the first idiom that preserves the order of the original collection while removing duplicate elements:</p><ol><li>Collection &lt; Type &gt; noDups = <strong>new</strong> LinkedHashSet &lt; Type &gt; (c);  </li></ol><p>The following is a generic method that encapsulates the preceding idiom, returning a Set of the same generic type as the one passed.</p><ol><li><strong>public</strong> <strong>static</strong> &lt; E &gt; Set &lt; E &gt; removeDups(Collection &lt; E &gt; c) {  </li><li>    <strong>return</strong> <strong>new</strong> LinkedHashSet &lt; E &gt; (c);  </li><li>}  </li></ol><h4>13.3.2.1 Set Interface Basic Operations</h4><p>The size operation returns the number of elements in the Set (its <em>cardinality</em>). The isEmpty method does exactly what you think it would. The add method adds the specified element to the Set if it is not already present and returns a boolean indicating whether the element was added. Similarly, the remove method removes the specified element from the Set if it is present and returns a boolean indicating whether the element was present. The iterator method returns an Iterator over the Set.</p><p>The following <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/FindDups.java">program</a> prints out all distinct words in its argument list. Two versions of this program are provided. The first uses JDK 8 aggregate operations. The second uses the for-each construct.</p><p>Using JDK 8 Aggregate Operations:</p><pre><code class="language-java">  import java.util.*;  
  import java.util.stream.*;  
  public class FindDups {  
      **public** **static** **void** main(String[] args) {  
          Set &lt; String &gt; distinctWords = Arrays.asList(args).stream().collect(Collectors.toSet());  
          System.out.println(distinctWords.size(+ &quot; distinct words: &quot; + distinctWords);  
     }  
 }  
 Using the   
 **for**-each Construct: 
 **import** java.util.*;  
 **public** **class** FindDups {  
     **public** **static** **void** main(String[] args) {  
         Set &lt; String &gt; s = **new** HashSet &lt; String &gt; ();  
         **for** (String a: args) s.add(a);  
         System.out.println(s.size() + &quot; distinct words: &quot; + s);  
   }  
}  
</code></pre><p>Now run either version of the program.
java FindDups i came i saw i left 
The following output is produced: 
4 distinct words: <!-- -->[left, came, saw, i]<!-- -->  </p><p>Note that <strong>the code always refers to the Collection by its interface type (Set) rather than by its implementation type. This is a <em>strongly</em> recommended programming practice because it gives you the flexibility to change implementations merely by changing the constructor.</strong> If either of the variables used to store a collection or the parameters used to pass it around are declared to be of the Collection&#x27;s implementation type rather than its interface type, <em>all</em> such variables and parameters must be changed in order to change its implementation type.</p><p>Furthermore, there&#x27;s no guarantee that the resulting program will work. If the program uses any nonstandard operations present in the original implementation type but not in the new one, the program will fail. Referring to collections only by their interface prevents you from using any nonstandard operations.</p><p>The implementation type of the Set in the preceding example is HashSet, which makes no guarantees as to the order of the elements in the Set. <strong>If you want the program to print the word list in alphabetical order, merely change the Set&#x27;s implementation type from HashSet to TreeSet</strong>. Making this trivial one-line change causes the command line in the previous example to generate the following output.</p><ol><li>java FindDups i came i saw i left </li><li>4 distinct words: <!-- -->[came, i, left, saw]<!-- -->  </li></ol><h4>13.3.2.2 Set Interface Bulk Operations</h4><p>Bulk operations are particularly well suited to Sets; when applied, they perform standard set-algebraic operations. Suppose s1 and s2 are sets. Here&#x27;s what bulk operations do:</p><ul><li>s1.containsAll(s2) --- returns true if s2 is a <strong>subset</strong> of s1. (s2 is a subset of s1 if set s1 contains all of the elements in s2.)</li><li>s1.addAll(s2) --- transforms s1 into the <strong>union</strong> of s1 and s2. (The union of two sets is the set containing all of the elements contained in either set.)</li><li>s1.retainAll(s2) --- transforms s1 into the intersection of s1 and s2. (The intersection of two sets is the set containing only the elements common to both sets.)</li><li>s1.removeAll(s2) --- transforms s1 into the (asymmetric) set difference of s1 and s2. (For example, the set difference of s1 minus s2 is the set containing all of the elements found in s1 but not in s2.)</li></ul><p><strong>To calculate the union, intersection, or set difference of two sets <em>nondestructively</em> (without modifying either set), the caller must copy one set before calling the appropriate bulk operation</strong>. The following are the resulting idioms.</p><ol><li>Set &lt; Type &gt; union = <strong>new</strong> HashSet &lt; Type &gt; (s1);  </li><li>union.addAll(s2);  </li><li>Set &lt; Type &gt; intersection = <strong>new</strong> HashSet &lt; Type &gt; (s1);  </li><li>intersection.retainAll(s2);  </li><li>Set &lt; Type &gt; difference = <strong>new</strong> HashSet &lt; Type &gt; (s1);  </li><li>difference.removeAll(s2);  </li></ol><p>The implementation type of the result Set in the preceding idioms is HashSet, which is, as already mentioned, the best all-around Set implementation in the Java platform. However, any general-purpose Set implementation could be substituted.</p><p>Let&#x27;s revisit the FindDups program. Suppose you want to know which words in the argument list occur only once and which occur more than once, but you do not want any duplicates printed out repeatedly. This effect can be achieved by generating two sets --- one containing every word in the argument list and the other containing only the duplicates. The words that occur only once are the set difference of these two sets, which we know how to compute. Here&#x27;s how <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/FindDups2.java">the resulting program</a> looks.</p><pre><code class="language-java">1.  **import** java.util.*;  
2.  **public** **class** FindDups2 {  
3.      **public** **static** **void** main(String[] args) {  
4.          Set &lt; String &gt; uniques = **new** HashSet &lt; String &gt; ();  
5.          Set &lt; String &gt; dups = **new** HashSet &lt; String &gt; ();  
6.          **for** (String a: args)  
7.              **if** (!uniques.add(a)) dups.add(a); // Destructive set-difference  
8.          uniques.removeAll(dups);  
9.          System.out.println(&quot;Unique words:    &quot; + uniques);  
10.         System.out.println(&quot;Duplicate words: &quot; + dups);  
11.     }  
12. }  
</code></pre><p>When run with the same argument list used earlier (i came i saw i left), the program yields the following output.</p><ol><li>Unique words: <!-- -->[left, saw, came]<!-- --> </li><li>Duplicate words: <!-- -->[i]<!-- -->  </li></ol><p>A less common set-algebraic operation is the <em>symmetric set difference</em> --- the set of elements contained in either of two specified sets but not in both. The following code calculates the symmetric set difference of two sets nondestructively.</p><ol><li>Set &lt; Type &gt; symmetricDiff = <strong>new</strong> HashSet &lt; Type &gt; (s1);  </li><li>symmetricDiff.addAll(s2);  </li><li>Set &lt; Type &gt; tmp = <strong>new</strong> HashSet &lt; Type &gt; (s1);  </li><li>tmp.retainAll(s2);  </li><li>symmetricDiff.removeAll(tmp);  </li></ol><h4>13.3.2.3 Set Interface Array Operations</h4><p>The array operations don&#x27;t do anything special for Sets beyond what they do for any other Collection. These operations are described in <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html">The Collection Interface</a> section.</p><h3>13.3.3 The List Interface</h3><p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">List</a> is an ordered <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection</a> (sometimes called a <em>sequence</em>). Lists may contain duplicate elements. In addition to the operations inherited from Collection, the List interface includes operations for the following:</p><ul><li>Positional access --- manipulates elements based on their numerical position in the list. This includes methods such as get, set, add, addAll, and remove.</li><li>Search --- searches for a specified object in the list and returns its numerical position. Search methods include indexOf and lastIndexOf.</li><li>Iteration --- extends Iterator semantics to take advantage of the list&#x27;s sequential nature. The listIterator methods provide this behavior.</li><li>Range-view --- The sublist method performs arbitrary <em>range operations</em> on the list.</li></ul><p>The Java platform contains two general-purpose List implementations. <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList</a>, which is usually the better-performing implementation, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html">LinkedList</a> which offers better performance under certain circumstances.</p><h4>13.3.3.1 Collection Operations</h4><p>The operations inherited from Collection all do about what you&#x27;d expect them to do, assuming you&#x27;re already familiar with them. If you&#x27;re not familiar with them from Collection, now would be a good time to read <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html">The Collection Interface</a> section. The remove operation always removes <em>the first</em> occurrence of the specified element from the list. The add and addAll operations always append the new element(s) to the <em>end</em> of the list. Thus, the following idiom concatenates one list to another.</p><ol><li>list1.addAll(list2);  </li></ol><p>Here&#x27;s a nondestructive form of this idiom, which produces a third List consisting of the second list appended to the first.</p><ol><li>List &lt; Type &gt; list3 = <strong>new</strong> ArrayList &lt; Type &gt; (list1);  </li><li>list3.addAll(list2);  </li></ol><p>Note that the idiom, in its nondestructive form, takes advantage of ArrayList&#x27;s standard conversion constructor.</p><p>And here&#x27;s an example (JDK 8 and later) that aggregates some names into a List:</p><ol><li>List &lt; String &gt; list = people.stream().map(Person::getName).collect(Collectors.toList());  </li></ol><p>Like the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html">Set</a> interface, List strengthens the requirements on the equals and hashCode methods so that two List objects can be compared for logical equality without regard to their implementation classes. <strong>Two List objects are equal if they contain the same elements in the same order.</strong></p><h4>13.3.3.2 Positional Access and Search Operations</h4><p>The basic positional access operations are get, set, add and remove. (The set and remove operations return the old value that is being overwritten or removed.) Other operations (indexOf and lastIndexOf) return the first or last index of the specified element in the list.</p><p>The addAll operation inserts all the elements of the specified Collection starting at the specified position. The elements are inserted in the order they are returned by the specified Collection&#x27;s iterator. This call is the positional access analog of Collection&#x27;s addAll operation.</p><p>Here&#x27;s a little method to swap two indexed values in a List.</p><p>[]{#bookmark=id.1419uqg}</p><ol><li><strong>public</strong> <strong>static</strong> &lt; E &gt; <strong>void</strong> swap(List &lt; E &gt; a, <strong>int</strong> i, <strong>int</strong> j) {  </li><li>    E tmp = a.get(i);  </li><li>    a.set(i, a.get(j));  </li><li>    a.set(j, tmp);  </li><li>}  </li></ol><p>Of course, there&#x27;s one big difference. This is a polymorphic algorithm: It swaps two elements in any List, regardless of its implementation type. Here&#x27;s another polymorphic algorithm that uses the preceding swap method.</p><ol><li><strong>public</strong> <strong>static</strong> <strong>void</strong> shuffle(List &lt;? &gt; list, Random rnd) {  </li><li>    <strong>for</strong> (<strong>int</strong> i = list.size(); i &gt; 1; i--) swap(list, i - 1, rnd.nextInt(i));  </li><li>}  </li></ol><p>This algorithm, which is included in the Java platform&#x27;s <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html">Collections</a> class, randomly permutes the specified list using the specified source of randomness. It&#x27;s a bit subtle: It runs up the list from the bottom, repeatedly swapping a randomly selected element into the current position. Unlike most naive attempts at shuffling, it&#x27;s <em>fair</em> (all permutations occur with equal likelihood, assuming an unbiased source of randomness) and <em>fast</em> (requiring exactly list.size()-1 swaps). The following program uses this algorithm to print the words in its argument list in random order.</p><pre><code class="language-java">1.  **import** java.util.*;  
2.  **public** **class** Shuffle {  
3.      **public** **static** **void** main(String[] args) {  
4.          List &lt; String &gt; list = **new** ArrayList &lt; String &gt; ();  
5.          **for** (String a: args) list.add(a);  
6.          Collections.shuffle(list, **new** Random());  
7.          System.out.println(list);  
8.      }  
9.  }  
</code></pre><p>In fact, this program can be made even shorter and faster. The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html">Arrays</a> class has a static factory method called asList, which allows an array to be viewed as a List. This method does not copy the array. Changes in the List write through to the array and vice versa. The resulting List is not a general-purpose List implementation, because it doesn&#x27;t implement the (optional) addand remove operations: Arrays are not resizable. Taking advantage of Arrays.asList and calling the library version of shuffle, which uses a default source of randomness, you get the following <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/Shuffle.java">tiny program</a> whose behavior is identical to the previous program.</p><pre><code class="language-java">1.  **import** java.util.*;  
2.  **public** **class** Shuffle {  
3.      **public** **static** **void** main(String[] args) {  
4.          List &lt; String &gt; list = Arrays.asList(args);  
5.          Collections.shuffle(list);  
6.          System.out.println(list);  
7.      }  
8.  }  
</code></pre><h4>13.3.3.3 Iterators</h4><p>As you&#x27;d expect, the Iterator returned by List&#x27;s iterator operation returns the elements of the list in proper sequence. List also provides a richer iterator, called a ListIterator, which allows you to traverse the list in either direction, modify the list during iteration, and obtain the current position of the iterator.</p><p>The three methods that ListIterator inherits from Iterator (hasNext, next, and remove) do exactly the same thing in both interfaces. The hasPrevious and the previous operations are exact analogues of hasNext and next. The former operations refer to the element before the (implicit) cursor, whereas the latter refer to the element after the cursor. The previousoperation moves the cursor backward, whereas next moves it forward.</p><p>Here&#x27;s the standard idiom for iterating backward through a list.</p><ol><li><strong>for</strong> (ListIterator &lt; Type &gt; it = list.listIterator(list.size()); it.hasPrevious();) {  </li><li>    Type t = it.previous();<!-- -->.<!-- -->..  </li><li>}  </li></ol><p>Note the argument to listIterator in the preceding idiom. The List interface has two forms of the listIterator method. The form with no arguments returns a ListIterator positioned at the beginning of the list; the form with an int argument returns a ListIterator positioned at the specified index. The index refers to the element that would be returned by an initial call to next. An initial call to previous would return the element whose index was index-1. In a list of length n, there are n+1 valid values for index, from 0 to n, inclusive.</p><p>Intuitively speaking, the cursor is always between two elements --- the one that would be returned by a call to previous and the one that would be returned by a call to next. The n+1 valid index values correspond to the n+1 gaps between elements, from the gap before the first element to the gap after the last one. The following figure shows the five possible cursor positions in a list containing four elements.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8jAwAI4ALwKj4zGQAAAABJRU5ErkJggg==" alt="Five arrows representing five cursor positions, from 0 to 4, with four elements, one between each arrow."/></p><p>The five possible cursor positions.</p><p>Calls to next and previous can be intermixed, but you have to be a bit careful. The first call to previous returns the same element as the last call to next. Similarly, the first call to next after a sequence of calls to previous returns the same element as the last call to previous.</p><p>It should come as no surprise <strong>that the nextIndex method returns the index of the element</strong> that would be returned by a subsequent call to next, and previous Index returns the index of the element that would be returned by a subsequent call to previous. These calls are typically used either to report the position where something was found or to record the position of the ListIterator so that another ListIterator with identical position can be created.</p><p>It should also come as no surprise that the number returned by nextIndex is always one greater than the number returned by previousIndex. This implies the behavior of the two boundary cases: (1) a call to previousIndex when the cursor is before the initial element returns -1 and (2) a call to nextIndex when the cursor is after the final element returns list.size(). To make all this concrete, the following is a possible implementation of List.indexOf.</p><ol><li><strong>public</strong> <strong>int</strong> indexOf(E e) {  </li><li>    <strong>for</strong> (ListIterator &lt; E &gt; it = listIterator(); it.hasNext();)  </li><li>        <strong>if</strong> (e == <strong>null</strong> ? it.next() == <strong>null</strong> : e.equals(it.next())) <strong>return</strong> it.previousIndex(); // Element not found  </li><li>    <strong>return</strong> -1;  </li><li>}  </li></ol><p>Note that the indexOf method returns it.previousIndex() even though it is traversing the list in the forward direction. The reason is that it.nextIndex() would return the index of the element we are about to examine, and we want to return the index of the element we just examined.</p><p>The Iterator interface provides the remove operation to remove the last element returned by next from the Collection. For ListIterator, this operation removes the last element returned by next or previous. The ListIterator interface provides two additional operations to modify the list --- set and add. The set method overwrites the last element returned by next or previous with the specified element. The following polymorphic algorithm uses set to replace all occurrences of one specified value with another.</p><ol><li><strong>public</strong> <strong>static</strong> &lt; E &gt; <strong>void</strong> replace(List &lt; E &gt; list, E val, E newVal) {  </li><li>    <strong>for</strong> (ListIterator &lt; E &gt; it = list.listIterator(); it.hasNext();)  </li><li>        <strong>if</strong> (val == <strong>null</strong> ? it.next() == <strong>null</strong> : val.equals(it.next())) it.set(newVal);  </li><li>}  </li></ol><p>The only bit of trickiness in this example is the equality test between val and it.next. You need to special-case a val value of null to prevent a NullPointerException.</p><p>The add method inserts a new element into the list immediately before the current cursor position. This method is illustrated in the following <strong>polymorphic algorithm to replace all occurrences of a specified value with the sequence of values contained in the specified list</strong>.</p><ol><li><strong>public</strong> <strong>static</strong> &lt; E &gt; <strong>void</strong> replace(List &lt; E &gt; list, E val, List &lt;? <strong>extends</strong> E &gt; newVals) {  </li><li>    <strong>for</strong> (ListIterator &lt; E &gt; it = list.listIterator(); it.hasNext();) {  </li><li>        <strong>if</strong> (val == <strong>null</strong> ? it.next() == <strong>null</strong> : val.equals(it.next())) {  </li><li>            it.remove();  </li><li>            <strong>for</strong> (E e: newVals) it.add(e);  </li><li>        }  </li><li>    }  </li><li>}  </li></ol><h4>13.3.3.4 Range-View Operation</h4><p>The range-view operation, subList(int fromIndex, int toIndex), returns a List view of the portion of this list whose indices range from fromIndex, inclusive, to toIndex, exclusive. This <em>half-open range</em> mirrors the typical for loop.</p><ol><li><strong>for</strong> (<strong>int</strong> i = fromIndex; i &lt; toIndex; i++) {<!-- -->.<!-- -->..  </li><li>}  </li></ol><p>As the term <em>view</em> implies, the returned List is backed up by the List on which subList was called, so changes in the former are reflected in the latter.</p><p>This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a List can be used as a range operation by passing a subList view instead of a whole List. For example, the following idiom removes a range of elements from a List.</p><ol><li>list.subList(fromIndex, toIndex).clear();  </li></ol><p>Similar idioms can be constructed to search for an element in a range.</p><ol><li><strong>int</strong> i = list.subList(fromIndex, toIndex).indexOf(o);  </li><li><strong>int</strong> j = list.subList(fromIndex, toIndex).lastIndexOf(o);  </li></ol><p>Note that the preceding idioms return the index of the found element in the subList, not the index in the backing List.</p><p>Any polymorphic algorithm that operates on a List, such as the replace and shuffle examples, works with the List returned by subList.</p><p>Here&#x27;s a polymorphic algorithm whose implementation uses subList to deal a hand from a deck. That is, it returns a new List (the &quot;hand&quot;) containing the specified number of elements taken from the end of the specified List (the &quot;deck&quot;). The elements returned in the hand are removed from the deck.</p><pre><code class="language-java">1.  **public** **static** &lt; E &gt; List &lt; E &gt; dealHand(List &lt; E &gt; deck, **int** n) {  
2.      **int** deckSize = deck.size();  
3.      List &lt; E &gt; handView = deck.subList(deckSize - n, deckSize);  
4.      List &lt; E &gt; hand = **new** ArrayList &lt; E &gt; (handView);  
5.      handView.clear();  
6.      **return** hand;  
7.  }  
</code></pre><p>Note that this algorithm removes the hand from the <em>end</em> of the deck. For many common List implementations, such as ArrayList, the performance of removing elements from the end of the list is substantially better than that of removing elements from the beginning.</p><p>The following is <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/Deal.java">a program</a> that uses the dealHand method in combination with Collections.shuffle to generate hands from a normal 52-card deck. The program takes two command-line arguments: (1) the number of hands to deal and (2) the number of cards in each hand.</p><pre><code class="language-java">1.  **import** java.util.*;  
2.  **public** **class** Deal {  
3.      **public** **static** **void** main(String[] args) {  
4.          **if** (args.length &lt; 2) {  
5.              System.out.println(&quot;Usage: Deal hands cards&quot;);  
6.              **return**;  
7.          }  
8.          **int** numHands = Integer.parseInt(args[0]);  
9.          **int** cardsPerHand = Integer.parseInt(args[1]); // Make a normal 52-card deck.  
10.         String[] suit = **new** String[] {  
11.             &quot;spades&quot;, &quot;hearts&quot;, &quot;diamonds&quot;, &quot;clubs&quot;  
12.         };  
13.         String[] rank = **new** String[] {  
14.             &quot;ace&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;jack&quot;, &quot;queen&quot;, &quot;king&quot;  
15.         };  
16.         List &lt; String &gt; deck = **new** ArrayList &lt; String &gt; ();  
17.         **for** (**int** i = 0; i &lt; suit.length; i++)  
18.             **for** (**int** j = 0; j &lt; rank.length; j++) deck.add(rank[j] + &quot; of &quot; + suit[i]); // Shuffle the deck.  
19.         Collections.shuffle(deck);  
20.         **if** (numHands \* cardsPerHand &gt; deck.size()) {  
21.             System.out.println(&quot;Not enough cards.&quot;);  
22.             **return**;  
23.         }  
24.         **for** (**int** i = 0; i &lt; numHands; i++) System.out.println(dealHand(deck, cardsPerHand));  
25.     }  
26.     **public** **static** &lt; E &gt; List &lt; E &gt; dealHand(List &lt; E &gt; deck, **int** n) {  
27.         **int** deckSize = deck.size();  
28.         List &lt; E &gt; handView = deck.subList(deckSize - n, deckSize);  
29.         List &lt; E &gt; hand = **new** ArrayList &lt; E &gt; (handView);  
30.         handView.clear();  
31.         **return** hand;  
32.     }  
33. }  
</code></pre><ol start="34"><li>Running the program produces output like the following. </li><li>% java Deal 4 5</li><li>[8 of hearts, jack of spades, 3 of spades, 4 of spades, king of diamonds]</li><li>[4 of diamonds, ace of clubs, 6 of clubs, jack of hearts, queen of hearts]</li><li>[7 of spades, 5 of spades, 2 of diamonds, queen of diamonds, 9 of clubs]</li><li>[8 of spades, 6 of diamonds, ace of spades, 3 of hearts, ace of hearts]<!-- -->  </li></ol><p><strong>Although the subList operation is extremely powerful, some care must be exercised when using it. The semantics of the List returned by subList become undefined if elements are added to or removed from the backing List in any way other than via the returned List. Thus, it&#x27;s highly recommended that you use the List returned by subList only as a transient object --- to perform one or a sequence of range operations on the backing List. The longer you use the subList instance, the greater the probability that you&#x27;ll compromise it by modifying the backing List directly or through another subList object. Note that it is legal to modify a sublist of a sublist and to continue using the original sublist (though not concurrently).</strong></p><h4>13.3.3.5 List Algorithms</h4><p>Most polymorphic algorithms in the Collections class apply specifically to List. Having all these algorithms at your disposal makes it very easy to manipulate lists. Here&#x27;s a summary of these algorithms, which are described in more detail in the <a href="https://docs.oracle.com/javase/tutorial/collections/algorithms/index.html">Algorithms</a> section.</p><ul><li>sort --- sorts a List using a merge sort algorithm, which provides a fast, stable sort. (A <em>stable sort</em> is one that does not reorder equal elements.)</li><li>shuffle --- randomly permutes the elements in a List.</li><li>reverse --- reverses the order of the elements in a List.</li><li>rotate --- rotates all the elements in a List by a specified distance.</li><li>swap --- swaps the elements at specified positions in a List.</li><li>replaceAll --- replaces all occurrences of one specified value with another.</li><li>fill --- overwrites every element in a List with the specified value.</li><li>copy --- copies the source List into the destination List.</li><li>binarySearch --- searches for an element in an ordered List using the binary search algorithm.</li><li>indexOfSubList --- returns the index of the first sublist of one List that is equal to another.</li><li>lastIndexOfSubList --- returns the index of the last sublist of one List that is equal to another.</li></ul><h3>13.3.4 The Queue Interface</h3><p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html">Queue</a> is a collection for holding elements prior to processing. Besides basic Collection operations, queues provide additional insertion, removal, and inspection operations. The Queueinterface follows.</p><pre><code class="language-java">1.  **public** **interface** Queue &lt; E &gt; **extends** Collection &lt; E &gt; {  
2.      E element();  
3.      **boolean** offer(E e);  
4.      E peek();  
5.      E poll();  
6.      E remove();  
7.  }  
</code></pre><p>Each Queue method exists in two forms: (1) one throws an exception if the operation fails, and (2) the other returns a special value if the operation fails (either null or false, depending on the operation). The regular structure of the interface is illustrated in the following table.</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Queue Interface Structure</td><td></td><td></td></tr><tr><td>Type of Operation</td><td><strong>Throws exception</strong></td><td><strong>Returns special value</strong></td></tr><tr><td>Insert</td><td>add(e)</td><td>offer(e)</td></tr><tr><td>Remove</td><td>remove()</td><td>poll()</td></tr><tr><td>Examine</td><td>element()</td><td>peek()</td></tr></tbody></table><p>Queues typically, but not necessarily, order elements in a FIFO (first-in-first-out) manner. Among the exceptions are priority queues, which order elements according to their values --- see the <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/order.html">Object Ordering</a> section for details). Whatever ordering is used, the head of the queue is the element that would be removed by a call to remove or poll. In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties.</p><p>It is possible for a Queue implementation to restrict the number of elements that it holds; such queues are known as <em>bounded</em>. Some Queue implementations in java.util.concurrent are bounded, but the implementations in java.util are not.</p><p>The <strong>add</strong> method, which Queue inherits from Collection, inserts an element unless it would violate the queue&#x27;s capacity restrictions, in which case it throws IllegalStateException. The <strong>offer</strong> method, which is intended solely for use on <strong>bounded queues, differs from add only in that it indicates failure to insert an element by returning false</strong>.</p><p>The <strong>remove and poll</strong> methods both remove and return the head of the queue. Exactly which element gets removed is a function of the queue&#x27;s ordering policy. <strong>The remove and poll methods differ in their behavior only when the queue is empty. Under these circumstances, remove throws NoSuchElementException, while poll returns null.</strong></p><p>The <strong>element and peek methods return, but do not remove, the head of the queue</strong>. They differ from one another in precisely the same fashion as remove and poll: <strong>If the queue is empty, element throws NoSuchElementException, while peek returns null.</strong></p><p><strong>Queue implementations generally do not allow insertion of null elements</strong>. <strong>The LinkedList implementation, which was retrofitted to implement Queue, is an exception.</strong> For historical reasons, it permits null elements, but you should refrain from taking advantage of this, because null is used as a special return value by the poll and peek methods.</p><p>Queue implementations generally do not define element-based versions of the equals and hashCode methods but instead inherit the identity-based versions from Object.</p><p>The Queue interface does not define the blocking queue methods, which are common in concurrent programming. These methods, which wait for elements to appear or for space to become available, are defined in the interface <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html">java.util.concurrent.BlockingQueue</a>, which extends Queue.</p><p>In the following example program, a queue is used to implement a countdown timer. The queue is preloaded with all the integer values from a number specified on the command line to zero, in descending order. Then, the values are removed from the queue and printed at one-second intervals. The program is artificial in that it would be more natural to do the same thing without using a queue, but it illustrates the use of a queue to store elements prior to subsequent processing.</p><pre><code class="language-java">1.  **import** java.util.*;  
2.  **public** **class** Countdown {  
3.      **public** **static** **void** main(String[] args) **throws** InterruptedException {  
4.          **int** time = Integer.parseInt(args[0]);  
5.          Queue &lt; Integer &gt; queue = **new** LinkedList &lt; Integer &gt; ();  
6.          **for** (**int** i = time; i &gt;= 0; i--) queue.add(i);  
7.          **while** (!queue.isEmpty()) {  
8.              System.out.println(queue.remove());  
9.              Thread.sleep(1000);  
10.         }  
11.     }  
12. }  
</code></pre><p>In the following example, a priority queue is used to sort a collection of elements. Again this program is artificial in that there is no reason to use it in favor of the sort method provided in Collections, but it illustrates the behavior of priority queues.</p><pre><code class="language-java">1.  **static** &lt; E &gt; List &lt; E &gt; heapSort(Collection &lt; E &gt; c) {  
2.      Queue &lt; E &gt; queue = **new** PriorityQueue &lt; E &gt; (c);  
3.      List &lt; E &gt; result = **new** ArrayList &lt; E &gt; ();  
4.      **while** (!queue.isEmpty()) result.add(queue.remove());  
5.      **return** result;  
6.  }  
</code></pre><h3>13.3.5 The Deque Interface</h3><p>Usually pronounced as deck, a deque is a double-ended-queue. A double-ended-queue is a linear collection of elements that supports the insertion and removal of elements at both end points. The Deque interface is a richer abstract data type than both Stack and Queue because it implements both stacks and queues at the same time. The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html">Deque</a> interface, defines methods to access the elements at both ends of the Deque instance. Methods are provided to insert, remove, and examine the elements. Predefined classes like <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html">ArrayDeque</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html">LinkedList</a> implement the Deque interface.</p><p>Note that the Deque interface can be used <strong>both as last-in-first-out stacks and first-in-first-out queues</strong>. The methods given in the Deque interface are divided into three parts:</p><h4>13.3.5.1 Insert</h4><p>The addfirst and offerFirst methods insert elements at the beginning of the Deque instance. The methods addLast and offerLast insert elements at the end of the Deque instance. When the capacity of the Deque instance is restricted, the preferred methods are offerFirst and offerLast because addFirst might fail to throw an exception if it is full.</p><h4>13.3.5.2 Remove</h4><p>The removeFirst and pollFirst methods remove elements from the beginning of the Deque instance. The removeLast and pollLast methods remove elements from the end. The methods pollFirst and pollLast return null if the Deque is empty whereas the methods removeFirst and removeLast throw an exception if the Deque instance is empty.</p><h4>13.3.5.3 Retrieve</h4><p>The methods getFirst and peekFirst retrieve the first element of the Deque instance. These methods dont remove the value from the Deque instance. Similarly, the methods getLast and peekLast retrieve the last element. The methods getFirst and getLast throw an exception if the deque instance is empty whereas the methods peekFirst and peekLast return NULL.</p><p>The 12 methods for insertion, removal and retieval of Deque elements are summarized in the following table:</p><p>+-----------------------+-----------------------+-----------------------+
| Deque Methods         |                       |                       |
+-----------------------+-----------------------+-----------------------+
| Type of Operation     | <strong>First Element       | </strong>Last Element (End   |
|                       | (Beginning of         | of                    |
|                       | the Deque instance)<strong> | the Deque instance)</strong> |
+-----------------------+-----------------------+-----------------------+
| Insert                | addFirst(e)\          | addLast(e)\           |
|                       | offerFirst(e)         | offerLast(e)          |
+-----------------------+-----------------------+-----------------------+
| Remove                | removeFirst()\        | removeLast()\         |
|                       | pollFirst()           | pollLast()            |
+-----------------------+-----------------------+-----------------------+
| Examine               | getFirst()\           | getLast()\            |
|                       | peekFirst()           | peekLast()            |
+-----------------------+-----------------------+-----------------------+</p><p>In addition to these basic methods to insert,remove and examine a Deque instance, the Deque interface also has some more predefined methods. One of these is removeFirstOccurence, this method removes the first occurence of the specified element if it exists in the Deque instance. If the element does not exist then the Deque instance remains unchanged. Another similar method is removeLastOccurence; this method removes the last occurence of the specified element in the Deque instance. The return type of these methods is boolean, and they return trueif the element exists in the Deque instance.</p><h3>13.3.6 The Map Interface</h3><p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">Map</a> is an object that maps keys to values. A map cannot contain duplicate keys: Each key can map to at most one value. It models the mathematical <em>function</em> abstraction. The Map interface includes methods for basic operations (such as put, get, remove, containsKey, containsValue, size, and empty), bulk operations (such as putAll and clear), and collection views (such as keySet, entrySet, and values).</p><p>The Java platform contains three general-purpose Map implementations: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html">TreeMap</a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html">LinkedHashMap</a>. Their behavior and performance are precisely analogous to HashSet, TreeSet, and LinkedHashSet, as described in <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html">The Set Interface</a> section.</p><p>The remainder of this page discusses the Map interface in detail. But first, here are some more examples of collecting to Maps using JDK 8 aggregate operations. Modeling real-world objects is a common task in object-oriented programming, so it is reasonable to think that some programs might, for example, group employees by department:</p><ol><li>// Group employees by department  </li><li>Map &lt; Department, List &lt; Employee &gt;&gt; byDept = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment));  </li><li>// Compute sum of salaries by department  </li><li>    Map &lt; Department, Integer &gt; totalByDept = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary)));  </li><li>// Partition students into passing and failing  </li><li>    Map &lt; Boolean, List &lt; Student &gt;&gt; passingFailing = students.stream().collect(Collectors.partitioningBy(s - &gt; s.getGrade() &gt;= PASS_THRESHOLD));  </li><li>// Classify Person objects by city  </li><li>    Map &lt; String, List &lt; Person &gt;&gt; peopleByCity = personStream.collect(Collectors.groupingBy(Person::getCity));  </li><li>// Cascade Collectors   </li><li>    Map &lt; String, Map &lt; String, List &lt; Person &gt;&gt;&gt; peopleByStateAndCity = personStream.collect(Collectors.groupingBy(Person::getState, Collectors.groupingBy(Person::getCity)))  </li></ol><p>Again, these are but a few examples of how to use the new JDK 8 APIs. For in-depth coverage of lambda expressions and aggregate operations see the lesson entitled <a href="https://docs.oracle.com/javase/tutorial/collections/streams/index.html">Aggregate Operations</a>.</p><h4>13.3.6.1 Map Interface Basic Operations</h4><p>The basic operations of Map (put, get, containsKey, containsValue, size, and isEmpty) behave exactly like their counterparts in Hashtable. The <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/Freq.java">following program</a> generates a frequency table of the words found in its argument list. The frequency table maps each word to the number of times it occurs in the argument list.</p><pre><code class="language-java">1.  **import** java.util.*;  
2.  **public** **class** Freq {  
3.      **public** **static** **void** main(String[] args) {  
4.          Map &lt; String, Integer &gt; m = **new** HashMap &lt; String, Integer &gt; (); // Initialize frequency table from command line  
5.          **for** (String a: args) {  
6.              Integer freq = m.get(a);  
7.              m.put(a, (freq == **null**) ? 1 : freq + 1);  
8.          }  
9.          System.out.println(m.size() + &quot; distinct words:&quot;);  
10.         System.out.println(m);  
11.     }  
12. }  
</code></pre><p>The only tricky thing about this program is the second argument of the put statement. That argument is a conditional expression that has the effect of setting the frequency to one if the word has never been seen before or one more than its current value if the word has already been seen. Try running this program with the command:</p><p>java Freq if it is to be it is up to me to delegate</p><p>The program yields the following output.</p><ol><li>8 distinct words: {  </li><li>    to = 3, delegate = 1, be = 1, it = 2, up = 1,  </li><li>        <strong>if</strong> = 1, me = 1, is = 2  </li><li>}  </li></ol><p>Suppose you&#x27;d prefer to see the frequency table in alphabetical order. All you have to do is change the implementation type of the Map from HashMap to TreeMap. Making this four-character change causes the program to generate the following output from the same command line.</p><ol><li>8 distinct words: {  </li><li>    be = 1, delegate = 1,  </li><li>        <strong>if</strong> = 1, is = 2, it = 2, me = 1, to = 3, up = 1  </li><li>}  </li></ol><p>Similarly, you could make the program print the frequency table in the order the words first appear on the command line simply by changing the implementation type of the map to LinkedHashMap. Doing so results in the following output.</p><ol><li>8 distinct words: {  </li><li>    <strong>if</strong> = 1, it = 2, is = 2, to = 3, be = 1, up = 1, me = 1, delegate = 1  </li><li>}  </li></ol><p>This flexibility provides a potent illustration of the power of an interface-based framework.</p><p>Like the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html">Set</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">List</a> interfaces, <strong>Map strengthens the requirements on the equals and hashCode methods</strong> so that two Map objects can be compared for logical equality without regard to their implementation types. Two Map instances are equal if they represent the same key-value mappings.</p><p>By convention, all general-purpose Map implementations provide constructors that take a Map object and initialize the new Map to contain all the key-value mappings in the specified Map. This standard Map conversion constructor is entirely analogous to the standard Collection constructor: It allows the caller to create a Map of a desired implementation type that initially contains all of the mappings in another Map, regardless of the other Map&#x27;s implementation type. For example, suppose you have a Map, named m. The following one-liner creates a new HashMap initially containing all of the same key-value mappings as m.</p><ol><li>Map &lt; K, V &gt; copy = <strong>new</strong> HashMap &lt; K, V &gt; (m);  </li></ol><h4>13.3.6.2 Map Interface Bulk Operations</h4><p>The clear operation does exactly what you would think it could do: It removes all the mappings from the Map. The putAll operation is the Map analogue of the Collection interface&#x27;s addAll operation. In addition to its obvious use of dumping one Map into another, it has a second, more subtle use. Suppose a Map is used to represent a collection of attribute-value pairs; the putAll operation, in combination with the Map conversion constructor, provides a neat way to implement attribute map creation with default values. The following is a static factory method that demonstrates this technique.</p><ol><li><strong>static</strong> &lt; K, V &gt; Map &lt; K, V &gt; newAttributeMap(Map &lt; K, V &gt; defaults, Map &lt; K, V &gt; overrides) {  </li><li>    Map &lt; K, V &gt; result = <strong>new</strong> HashMap &lt; K, V &gt; (defaults);  </li><li>    result.putAll(overrides);  </li><li>    <strong>return</strong> result;  </li><li>}  </li></ol><h4>13.3.6.3 Collection Views</h4><p>The Collection view methods allow a Map to be viewed as a Collection in these three ways:</p><p>keySet --- the Set of keys contained in the Map.</p><p>values --- The Collection of values contained in the Map. This Collection is not a Set, because multiple keys can map to the same value.</p><p>entrySet --- the Set of key-value pairs contained in the Map. <strong>The Map interface provides a small nested interface called Map.Entry, the type of the elements in this Set</strong>.</p><p><strong>The Collection views provide the <em>only</em> means to iterate over a Map</strong>. This example illustrates the standard idiom for iterating over the keys in a Map with a for-each construct:</p><ol><li><strong>for</strong> (KeyType key: m.keySet()) System.out.println(key);  </li><li>and <strong>with</strong> an  iterator: // Filter a map based on some  // property of its keys.  </li><li>    <strong>for</strong> (Iterator &lt; Type &gt; it = m.keySet().iterator(); it.hasNext();)  </li><li>        <strong>if</strong> (it.next().isBogus()) it.remove();  </li></ol><p>The idiom for iterating over values is analogous. Following is the idiom for iterating over key-value pairs.</p><ol><li><strong>for</strong> (Map.Entry &lt; KeyType, ValType &gt; e: m.entrySet()) System.out.println(e.getKey() + &quot;: &quot; + e.getValue());  </li></ol><p>At first, many people worry that these idioms may be slow because the Map has to create a new Collection instance each time a Collection view operation is called. Rest easy: There&#x27;s no reason that a Map cannot always return the same object each time it is asked for a given Collection view. This is precisely what all the Map implementations in java.util do.</p><p>With all three Collection views, <strong>calling an Iterator&#x27;s remove operation removes the associated entry from the backing Map</strong>, assuming that the backing Map supports element removal to begin with. This is illustrated by the preceding filtering idiom.</p><p><strong>With the entrySet view, it is also possible to change the value associated with a key by calling a Map.Entry&#x27;s setValue method during iteration</strong> (again, assuming the Map supports value modification to begin with). <strong>Note that these are the <em>only</em> safe ways to modify a Map during iteration; the behavior is unspecified if the underlying Map is modified in any other way while the iteration is in progress.</strong></p><p>The Collection views support element removal in all its many forms --- remove, removeAll, retainAll, and clear operations, as well as the Iterator.remove operation. (Yet again, this assumes that the backing Map supports element removal.)</p><p><strong>The Collection views <em>do not</em> support element addition under any circumstances</strong>. It would make no sense for the keySet and values views, and it&#x27;s unnecessary for the entrySet view, because the backing Map&#x27;s put and putAll methods provide the same functionality.</p><h4>13.3.6.4 Fancy Uses of Collection Views: Map Algebra</h4><p>When applied to the Collection views, bulk operations (containsAll, removeAll, and retainAll) are surprisingly potent tools. For starters, suppose you want to know whether one Map is a submap of another --- that is, whether the first Map contains all the key-value mappings in the second. The following idiom does the trick.</p><ol><li><strong>if</strong> (m1.entrySet().containsAll(m2.entrySet())) {<!-- -->.<!-- -->..  </li><li>}  </li></ol><p>Along similar lines, suppose you want to know whether two Map objects contain mappings for all of the same keys.</p><ol><li><strong>if</strong> (m1.keySet().equals(m2.keySet())) {<!-- -->.<!-- -->..  </li><li>}  </li></ol><p>Suppose you have a Map that represents a collection of attribute-value pairs, and two Sets representing required attributes and permissible attributes. (The permissible attributes include the required attributes.) The following snippet determines whether the attribute map conforms to these constraints and prints a detailed error message if it doesn&#x27;t.</p><ol><li><strong>static</strong> &lt; K, V &gt; <strong>boolean</strong> validate(Map &lt; K, V &gt; attrMap, Set &lt; K &gt; requiredAttrs, Set &lt; K &gt; permittedAttrs) {  </li><li>    <strong>boolean</strong> valid = <strong>true</strong>;  </li><li>    Set &lt; K &gt; attrs = attrMap.keySet();  </li><li>    <strong>if</strong> (!attrs.containsAll(requiredAttrs)) {  </li><li>        Set &lt; K &gt; missing = <strong>new</strong> HashSet &lt; K &gt; (requiredAttrs);  </li><li>        missing.removeAll(attrs);  </li><li>        System.out.println(&quot;Missing attributes: &quot; + missing);  </li><li>        valid = <strong>false</strong>;  </li><li>    }  </li><li>    <strong>if</strong> (!permittedAttrs.containsAll(attrs)) {  </li><li>        Set &lt; K &gt; illegal = <strong>new</strong> HashSet &lt; K &gt; (attrs);  </li><li>        illegal.removeAll(permittedAttrs);  </li><li>        System.out.println(&quot;Illegal attributes: &quot; + illegal);  </li><li>        valid = <strong>false</strong>;  </li><li>    }  </li><li>    <strong>return</strong> valid;  </li><li>}  </li></ol><p>Suppose you want to know all the keys common to two Map objects.</p><ol><li>Set &lt; KeyType &gt; commonKeys = <strong>new</strong> HashSet &lt; KeyType &gt; (m1.keySet());  </li><li>commonKeys.retainAll(m2.keySet());  </li></ol><p>A similar idiom gets you the common values.</p><p>All the idioms presented thus far have been nondestructive; that is, they don&#x27;t modify the backing Map. Here are a few that do. Suppose you want to remove all of the key-value pairs that one Map has in common with another.</p><ol><li>m1.entrySet().removeAll(m2.entrySet());  </li></ol><p>Suppose you want to remove from one Map all of the keys that have mappings in another.</p><ol><li>m1.keySet().removeAll(m2.keySet());  </li></ol><p>What happens when you start mixing keys and values in the same bulk operation? Suppose you have a Map, managers, that maps each employee in a company to the employee&#x27;s manager. We&#x27;ll be deliberately vague about the types of the key and the value objects. It doesn&#x27;t matter, as long as they&#x27;re the same. Now suppose you want to know who all the &quot;individual contributors&quot; (or nonmanagers) are. The following snippet tells you exactly what you want to know.</p><ol><li>Set &lt; Employee &gt; individualContributors = <strong>new</strong> HashSet &lt; Employee &gt; (managers.keySet());  </li><li>individualContributors.removeAll(managers.values());  </li></ol><p>Suppose you want to fire all the employees who report directly to some manager, Simon.</p><ol><li>Employee simon = <!-- -->.<!-- -->..;  </li><li>managers.values().removeAll(Collections.singleton(simon));  </li></ol><p>Note that this idiom makes use of Collections.singleton, a static factory method that returns an immutable Set with the single, specified element.</p><p>Once you&#x27;ve done this, you may have a bunch of employees whose managers no longer work for the company (if any of Simon&#x27;s direct-reports were themselves managers). The following code will tell you which employees managers who have no longer works for the company.</p><ol><li>Map &lt; Employee, Employee &gt; m = <strong>new</strong> HashMap &lt; Employee, Employee &gt; (managers);  </li><li>m.values().removeAll(managers.keySet());  </li><li>Set &lt; Employee &gt; slackers = m.keySet();  </li></ol><p>This example is a bit tricky. First, it makes a temporary copy of the Map, and it removes from the temporary copy all entries whose (manager) value is a key in the original Map. Remember that the original Map has an entry for each employee. Thus, the remaining entries in the temporary Map comprise all the entries from the original Map whose (manager) values are no longer employees. The keys in the temporary copy, then, represent precisely the employees that we&#x27;re looking for.</p><p>There are many more idioms like the ones contained in this section, but it would be impractical and tedious to list them all. Once you get the hang of it, it&#x27;s not that difficult to come up with the right one when you need it.</p><h4>13.3.6.5 Multimaps</h4><p>A <em>multimap</em> is like a Map but it can map each key to multiple values. The Java Collections Framework doesn&#x27;t include an interface for multimaps because they aren&#x27;t used all that commonly. It&#x27;s a fairly simple matter to use a Map whose values are List instances as a multimap. This technique is demonstrated in the next code example, which reads a word list containing one word per line (all lowercase) and prints out all the anagram groups that meet a size criterion. An <em>anagram group</em> is a bunch of words, all of which contain exactly the same letters but in a different order. The program takes two arguments on the command line: (1) the name of the dictionary file and (2) the minimum size of anagram group to print out. Anagram groups containing fewer words than the specified minimum are not printed.</p><p>There is a standard trick for finding anagram groups: For each word in the dictionary, alphabetize the letters in the word (that is, reorder the word&#x27;s letters into alphabetical order) and put an entry into a multimap, mapping the alphabetized word to the original word. For example, the word <em>bad</em> causes an entry mapping <em>abd</em> into <em>bad</em> to be put into the multimap. A moment&#x27;s reflection will show that all the words to which any given key maps form an anagram group. It&#x27;s a simple matter to iterate over the keys in the multimap, printing out each anagram group that meets the size constraint.</p><p><a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/Anagrams.java">The following program</a> is a straightforward implementation of this technique.</p><pre><code class="language-java">1.  **import** java.util.*;  
2.  **import** java.io.*;  
3.  **public** **class** Anagrams {  
4.      **public** **static** **void** main(String[] args) {  
5.          **int** minGroupSize = Integer.parseInt(args[1]); // Read words from file and put into a simulated multimap  
6.          Map &lt; String, List &lt; String &gt;&gt; m = **new** HashMap &lt; String, List &lt; String &gt;&gt; ();  
7.          **try** {  
8.              Scanner s = **new** Scanner(**new** File(args[0]));  
9.              **while** (s.hasNext()) {  
10.                 String word = s.next();  
11.                 String alpha = alphabetize(word);  
12.                 List &lt; String &gt; l = m.get(alpha);  
13.                 **if** (l == **null**) m.put(alpha, l = **new** ArrayList &lt; String &gt; ());  
14.                 l.add(word);  
15.             }  
16.         } **catch** (IOException e) {  
17.             System.err.println(e);  
18.             System.exit(1);  
19.         } // Print all permutation groups above size threshold  
20.         **for** (List &lt; String &gt; l: m.values())  
21.             **if** (l.size() &gt;= minGroupSize) System.out.println(l.size() + &quot;: &quot; + l);  
22.     }  
23.     **private** **static** String alphabetize(String s) {  
24.         **char**[] a = s.toCharArray();  
25.         Arrays.sort(a);  
26.         **return** **new** String(a);  
27.     }  
28. }  
</code></pre><ol start="29"><li>Running <strong>this</strong> program on a 173, 000 - word dictionary file <strong>with</strong> a minimum anagram group size of eight produces the following output.</li><li>9:<!-- -->[estrin, inerts, insert, inters, niters, nitres, sinter, triens, trines]<!-- --> </li><li>8: <!-- -->[lapse, leaps, pales, peals, pleas, salep, sepal, spale]<!-- --> </li><li>8: <!-- -->[aspers, parses, passer, prases, repass, spares, sparse, spears]<!-- --> </li><li>10: <!-- -->[least, setal, slate, stale, steal, stela, taels, tales, teals, tesla]<!-- --> </li><li>8: <!-- -->[enters, nester, renest, rentes, resent, tenser, ternes, treens]<!-- --> </li><li>8: <!-- -->[arles, earls, lares, laser, lears, rales, reals, seral]<!-- --> </li><li>8: <!-- -->[earings, erasing, gainers, reagins, regains, reginas, searing, seringa]<!-- --> </li><li>8: <!-- -->[peris, piers, pries, prise, ripes, speir, spier, spire]<!-- --> </li><li>12: <!-- -->[apers, apres, asper, pares, parse, pears, prase, presa, rapes, reaps, spare, spear]<!-- --> </li><li>11: <!-- -->[alerts, alters, artels, estral, laster, ratels, salter, slater, staler, stelar, talers]<!-- --> </li><li>9: <!-- -->[capers, crapes, escarp, pacers, parsec, recaps, scrape, secpar, spacer]<!-- --> </li><li>9: <!-- -->[palest, palets, pastel, petals, plates, pleats, septal, staple, tepals]<!-- --> </li><li>9: <!-- -->[anestri, antsier, nastier, ratines, retains, retinas, retsina, stainer, stearin]<!-- --> </li><li>8: <!-- -->[ates, east, eats, etas, sate, seat, seta, teas]<!-- --> </li><li>8: <!-- -->[carets, cartes, caster, caters, crates, reacts, recast, traces]<!-- -->  </li></ol><p>Many of these words seem a bit bogus, but that&#x27;s not the program&#x27;s fault; they&#x27;re in the dictionary file. Here&#x27;s the <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/dictionary.txt">dictionary file</a> we used. It was derived from the Public Domain ENABLE benchmark reference word list.</p><h3>13.3.7 Object Ordering</h3><p>A List l may be sorted as follows.</p><ol><li>Collections.sort(l);  </li></ol><p>If the List consists of String elements, it will be sorted into alphabetical order. If it consists of Date elements, it will be sorted into chronological order. How does this happen? String and Date both implement the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">Comparable</a> interface. Comparable implementations provide a <em>natural ordering</em> for a class, which allows objects of that class to be sorted automatically. The following table summarizes some of the more important Java platform classes that implement Comparable.</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Classes Implementing Comparable</td><td></td></tr><tr><td>Class</td><td><strong>Natural Ordering</strong></td></tr><tr><td>Byte</td><td>Signed numerical</td></tr><tr><td>Character</td><td>Unsigned numerical</td></tr><tr><td>Long</td><td>Signed numerical</td></tr><tr><td>Integer</td><td>Signed numerical</td></tr><tr><td>Short</td><td>Signed numerical</td></tr><tr><td>Double</td><td>Signed numerical</td></tr><tr><td>Float</td><td>Signed numerical</td></tr><tr><td>BigInteger</td><td>Signed numerical</td></tr><tr><td>BigDecimal</td><td>Signed numerical</td></tr><tr><td>Boolean</td><td>Boolean.FALSE &lt; Boolean.TRUE</td></tr><tr><td>File</td><td>System-dependent lexicographic on path name</td></tr><tr><td>String</td><td>Lexicographic</td></tr><tr><td>Date</td><td>Chronological</td></tr><tr><td>CollationKey</td><td>Locale-specific lexicographic</td></tr></tbody></table><p><strong>If you try to sort a list, the elements of which do not implement Comparable, Collections.sort(list) will throw a </strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassCastException.html"><strong>ClassCastException</strong></a><strong>.</strong> Similarly, Collections.sort(list, comparator) will throw a ClassCastException if you try to sort a list whose elements cannot be compared to one another using the comparator. Elements that can be compared to one another are called <em>mutually comparable</em>. Although elements of different types may be mutually comparable, none of the classes listed here permit interclass comparison.</p><p>This is all you really need to know about the Comparable interface if you just want to sort lists of comparable elements or to create sorted collections of them. The next section will be of interest to you if you want to implement your own Comparable type.</p><h4>13.3.7.1 Writing Your Own Comparable Types</h4><p>The Comparable interface consists of the following method.</p><pre><code class="language-java">1.  **public** **interface** Comparable &lt; T &gt; {  
2.      **public** **int** compareTo(T o);  
3.  }  
</code></pre><p>The compareTo method compares the receiving object with the specified object and returns a negative integer, 0, or a positive integer depending on whether the receiving object is less than, equal to, or greater than the specified object. If the specified object cannot be compared to the receiving object, the method throws a ClassCastException.</p><p>The <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/Name.java">following class representing a person&#x27;s name</a> implements Comparable.</p><pre><code class="language-java">1.  **import** java.util.*;  
2.  **public** **class** Name **implements** Comparable &lt; Name &gt; {  
3.      **private** **final** String firstName, lastName;  
4.      **public** Name(String firstName, String lastName) {  
5.          **if** (firstName == **null** \|\| lastName == **null**) **throw** **new** NullPointerException();  
6.          **this**.firstName = firstName;  
7.          **this**.lastName = lastName;  
8.      }  
9.      **public** String firstName() {  
10.         **return** firstName;  
11.     }  
12.     **public** String lastName() {  
13.         **return** lastName;  
14.     }  
15.     **public** **boolean** equals(Object o) {  
16.         **if** (!(o **instanceof** Name)) **return** **false**;  
17.         Name n = (Name) o;  
18.         **return** n.firstName.equals(firstName) &amp;&amp; n.lastName.equals(lastName);  
19.     }  
20.     **public** **int** hashCode() {  
21.         **return** 31 \* firstName.hashCode() + lastName.hashCode();  
22.     }  
23.     **public** String toString() {  
24.         **return** firstName + &quot; &quot; + lastName;  
25.     }  
26.     **public** **int** compareTo(Name n) {  
27.         **int** lastCmp = lastName.compareTo(n.lastName);  
28.         **return** (lastCmp != 0 ? lastCmp : firstName.compareTo(n.firstName));  
29.     }  
30. }  
</code></pre><p>To keep the preceding example short, the class is somewhat limited: It doesn&#x27;t support middle names, it demands both a first and a last name, and it is not internationalized in any way. Nonetheless, it illustrates the following important points:</p><ul><li>Name objects are <em>immutable</em>. All other things being equal, immutable types are the way to go, especially for objects that will be used as elements in Sets or as keys in Maps. These collections will break if you modify their elements or keys while they&#x27;re in the collection.</li><li>The constructor checks its arguments for null. This ensures that all Name objects are well formed so that none of the other methods will ever throw a NullPointerException.</li><li>The hashCode method is redefined. This is essential for any class that redefines the equals method. (Equal objects must have equal hash codes.)</li><li>The equals method returns false if the specified object is null or of an inappropriate type. The compareTo method throws a runtime exception under these circumstances. Both of these behaviors are required by the general contracts of the respective methods.</li><li>The toString method has been redefined so it prints the Name in human-readable form. This is always a good idea, especially for objects that are going to get put into collections. The various collection types&#x27; toString methods depend on the toString methods of their elements, keys, and values.</li></ul><p>It implements the <strong>standard name-ordering algorithm</strong>, where last names take precedence over first names. This is exactly what you want in a natural ordering. It would be very confusing indeed if the natural ordering were unnatural!</p><p>Take a look at how compareTo is implemented, because it&#x27;s quite typical. First, <strong>you compare the most significant part of the object (in this case, the last name). Often, you can just use the natural ordering of the part&#x27;s type</strong>. In this case, the part is a String and the natural (lexicographic) ordering is exactly what&#x27;s called for. If the comparison results in anything other than zero, which represents equality, you&#x27;re done: You just return the result. If the most significant parts are equal, you go on to compare the next most-significant parts. In this case, there are only two parts --- first name and last name.</p><p>Just to show that it all works, here&#x27;s <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/NameSort.java">a program that builds a list of names and sorts them</a>.</p><pre><code class="language-java">1.  **import** java.util.*;  
2.  **public** **class** NameSort {  
3.      **public** **static** **void** main(String[] args) {  
4.          Name nameArray[] = {  
5.              **new** Name(&quot;John&quot;, &quot;Smith&quot;), **new** Name(&quot;Karl&quot;, &quot;Ng&quot;), **new** Name(&quot;Jeff&quot;, &quot;Smith&quot;), **new** Name(&quot;Tom&quot;, &quot;Rich&quot;)  
6.          };  
7.          List &lt; Name &gt; names = Arrays.asList(nameArray);  
8.          Collections.sort(names);  
9.          System.out.println(names);  
10.     }  
11. }  
</code></pre><p>If you run this program, here&#x27;s what it prints.</p><ol><li>[Karl Ng, Tom Rich, Jeff Smith, John Smith]<!-- -->  </li></ol><p>There are four restrictions on the behavior of the compareTo method, which we won&#x27;t go into now because they&#x27;re fairly technical and boring and are better left in the API documentation. It&#x27;s really important that all classes that implement Comparable obey these restrictions, so read the documentation for Comparable if you&#x27;re writing a class that implements it. Attempting to sort a list of objects that violate the restrictions has undefined behavior. Technically speaking, these restrictions ensure that the natural ordering is a <em>total order</em> on the objects of a class that implements it; this is necessary to ensure that sorting is well defined.</p><h4>13.3.7.2 Comparators</h4><p>What if you want to sort some objects in an order other than their natural ordering? Or what if you want to sort some objects that don&#x27;t implement Comparable? To do either of these things, you&#x27;ll need to provide a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html">Comparator</a> --- an object that encapsulates an ordering. Like the Comparable interface, the Comparator interface consists of a single method.</p><pre><code class="language-java">1.  **public** **interface** Comparator &lt; T &gt; {  
2.      **int** compare(T o1, T o2);  
3.  }  
</code></pre><p>The compare method compares its two arguments, returning a negative integer, 0, or a positive integer depending on whether the first argument is less than, equal to, or greater than the second. If either of the arguments has an inappropriate type for the Comparator, the compare method throws a ClassCastException.</p><p>Much of what was said about Comparable applies to Comparator as well. Writing a compare method is nearly identical to writing a compareTo method, except that the former gets both objects passed in as arguments. The compare method has to obey the same four technical restrictions as Comparable&#x27;s compareTo method for the same reason --- a Comparator must induce a total order on the objects it compares.</p><p>Suppose you have a class called Employee, as follows.</p><pre><code class="language-java">1.  **public** **class** Employee **implements** Comparable &lt; Employee &gt; {  
2.      **public** Name name() {\...  
3.      }  
4.      **public** **int** number() {\...  
5.      }  
6.      **public** Date hireDate() {\...  
7.      }\...  
8.  }  
</code></pre><p>Let&#x27;s assume that the natural ordering of Employee instances is Name ordering (as defined in the previous example) on employee name. Unfortunately, the boss has asked for a list of employees in order of seniority. This means we have to do some work, but not much. The following program will produce the required list.</p><pre><code class="language-java">1.  **import** java.util.*;  
2.  **public** **class** EmpSort {  
3.      **static** **final** Comparator &lt; Employee &gt; SENIORITY_ORDER = **new** Comparator &lt; Employee &gt; () {  
4.          **public** **int** compare(Employee e1, Employee e2) {  
5.              **return** e2.hireDate().compareTo(e1.hireDate());  
6.          }  
7.      };  
8.  // Employee database  
9.  **static** **final** Collection &lt; Employee &gt; employees = \...;  
10. **public** **static** **void** main(String[] args) {  
11.     List &lt; Employee &gt; e = **new** ArrayList &lt; Employee &gt; (employees);  
12.     Collections.sort(e, SENIORITY_ORDER);  
13.     System.out.println(e);  
14. }  
15. }  
</code></pre><p>The Comparator in the program is reasonably straightforward. It relies on the natural ordering of Date applied to the values returned by the hireDate accessor method. Note that the Comparator passes the hire date of its second argument to its first rather than vice versa. The reason is that the employee who was hired most recently is the least senior; sorting in the order of hire date would put the list in reverse seniority order. Another technique people sometimes use to achieve this effect is to maintain the argument order but to negate the result of the comparison.</p><pre><code class="language-java">// Don&#x27;t do this!!
1.  **return** -r1.hireDate().compareTo(r2.hireDate());  
</code></pre><p>You should always use the former technique in favor of the latter because the latter is not guaranteed to work. The reason for this is that the compareTo method can return any negative int if its argument is less than the object on which it is invoked. There is one negative int that remains negative when negated, strange as it may seem.</p><pre><code class="language-java">1.  -Integer.MIN_VALUE == Integer.MIN_VALUE  
</code></pre><p>The Comparator in the preceding program works fine for sorting a List, but it does have one deficiency: It cannot be used to order a sorted collection, such as TreeSet, because it generates an ordering that is <em>not compatible with</em> equals. This means that this Comparator equates objects that the equals method does not. In particular, any two employees who were hired on the same date will compare as equal. When you&#x27;re sorting a List, this doesn&#x27;t matter; but when you&#x27;re using the Comparator to order a sorted collection, it&#x27;s fatal. If you use this Comparator to insert multiple employees hired on the same date into a TreeSet, only the first one will be added to the set; the second will be seen as a duplicate element and will be ignored.</p><p>To fix this problem, simply tweak the Comparator so that it produces an ordering that <em>is compatible with</em> equals. In other words, tweak it so that the only elements seen as equal when using compare are those that are also seen as equal when compared using equals. The way to do this is to perform a two-part comparison (as for Name), where the first part is the one we&#x27;re interested in --- in this case, the hire date --- and the second part is an attribute that uniquely identifies the object. Here the employee number is the obvious attribute. This is the Comparator that results.</p><pre><code class="language-java">1.  **static** **final** Comparator &lt; Employee &gt; SENIORITY_ORDER = **new** Comparator &lt; Employee &gt; () {  
2.      **public** **int** compare(Employee e1, Employee e2) {  
3.          **int** dateCmp = e2.hireDate().compareTo(e1.hireDate());  
4.          **if** (dateCmp != 0) **return** dateCmp;  
5.          **return** (e1.number() &lt; e2.number() ? -1 : (e1.number() == e2.number() ? 0 : 1));  
6.      }  
7.  };  
</code></pre><p>One last note: You might be tempted to replace the final return statement in the Comparator with the simpler:</p><pre><code class="language-java">return e1.number() - e2.number();
</code></pre><p>Don&#x27;t do it unless you&#x27;re <em>absolutely sure</em> no one will ever have a negative employee number! This trick does not work in general because the signed integer type is not big enough to represent the difference of two arbitrary signed integers. If i is a large positive integer and j is a large negative integer, i - j will overflow and will return a negative integer. The resulting comparator violates one of the four technical restrictions we keep talking about (transitivity) and produces horrible, subtle bugs. This is not a purely theoretical concern; people get burned by it.</p><h4>13.3.7.3 Technical restrictions on comparator implementations</h4><ul><li>The implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (This implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.)</li><li>The implementor must also ensure that the <strong>relation is transitive</strong>: ((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0.</li><li>Finally, the implementor must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z.</li><li>It is generally the case, but not strictly required that (compare(x, y)==0) == (x.equals(y)). Generally speaking, any comparator that violates this condition should clearly indicate this fact. The recommended language is &quot;Note: this comparator imposes orderings that are inconsistent with equals.&quot;</li></ul><p><a href="https://stackoverflow.com/questions/14732551/rules-to-implement-compare-method">https://stackoverflow.com/questions/14732551/rules-to-implement-compare-method</a></p><h3>13.3.8 The SortedSet Interface</h3><p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html">SortedSet</a> is a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html">Set</a> that maintains its elements in ascending order, sorted according to the elements&#x27; natural ordering or according to a Comparator provided at SortedSet creation time. In addition to the normal Set operations, the SortedSet interface provides operations for the following:</p><ul><li>Range view --- allows arbitrary range operations on the sorted set</li><li>Endpoints --- returns the first or last element in the sorted set</li><li>Comparator access --- returns the Comparator, if any, used to sort the set</li></ul><p>The code for the SortedSet interface follows.</p><pre><code class="language-java">1.  **public** **interface** SortedSet &lt; E &gt; **extends** Set &lt; E &gt; { // Range-view  
2.      SortedSet &lt; E &gt; subSet(E fromElement, E toElement);  
3.      SortedSet &lt; E &gt; headSet(E toElement);  
4.      SortedSet &lt; E &gt; tailSet(E fromElement); // Endpoints  
5.      E first();  
6.      E last(); // Comparator access  
7.      Comparator &lt;? **super** E &gt; comparator();  
8.  }  
</code></pre><h4>13.3.8.1 Set Operations</h4><p>The operations that SortedSet inherits from Set behave identically on sorted sets and normal sets with two exceptions:</p><ul><li>The Iterator returned by the iterator operation traverses the sorted set in order.</li><li>The array returned by toArray contains the sorted set&#x27;s elements in order.</li></ul><p>Although the interface doesn&#x27;t guarantee it, the toString method of the Java platform&#x27;s SortedSet implementations returns a string containing all the elements of the sorted set, in order.</p><h4>13.3.8.2 Standard Constructors</h4><p>By convention, all general-purpose Collection implementations provide a standard conversion constructor that takes a Collection; SortedSet implementations are no exception. In <strong>TreeSet, this constructor creates an instance that sorts its elements according to their natural ordering</strong>. This was probably a mistake. It would have been better to check dynamically to see whether the specified collection was a SortedSet instance and, <strong>if so, to sort the new TreeSet according to the same criterion (comparator or natural ordering). Because TreeSet took the approach that it did, it also provides a constructor that takes a SortedSet and returns a new TreeSet containing the same elements sorted according to the same criterion.</strong> Note that it is the compile-time type of the argument, not its runtime type, that determines which of these two constructors is invoked (and whether the sorting criterion is preserved).</p><p>SortedSet implementations also provide, by convention, a constructor that takes a Comparator and returns an empty set sorted according to the specified Comparator. If null is passed to this constructor, it returns a set that sorts its elements according to their natural ordering.</p><h4>13.3.8.3 Range-view Operations</h4><p>The range-view operations are somewhat analogous to those provided by the List interface, but there is one big difference. Range views of a sorted set remain valid even if the backing sorted set is modified directly. This is feasible because the endpoints of a range view of a sorted set are absolute points in the element space rather than specific elements in the backing collection, as is the case for lists. A range-view of a sorted set is really just a window onto whatever portion of the set lies in the designated part of the element space. Changes to the range-view write back to the backing sorted set and vice versa. Thus, it&#x27;s okay to use range-views on sorted sets for long periods of time, unlike range-views on lists.</p><p>Sorted sets provide three range-view operations. The first, subSet, takes two endpoints, like subList. Rather than indices, the endpoints are objects and must be comparable to the elements in the sorted set, using the Set&#x27;s Comparator or the natural ordering of its elements, whichever the Set uses to order itself. Like subList, the range is half open, including its low endpoint but excluding the high one.</p><p>Thus, the following line of code tells you how many words between &quot;doorbell&quot; and &quot;pickle&quot;, including &quot;doorbell&quot; but excluding &quot;pickle&quot;, are contained in a SortedSet of strings called dictionary:</p><pre><code class="language-java">1.  **int** count = dictionary.subSet(&quot;doorbell&quot;, &quot;pickle&quot;).size();```

In like manner, the following one-liner removes all the elements beginning with the letter f.
```java
1.  dictionary.subSet(&quot;f&quot;, &quot;g&quot;).clear();  
</code></pre><p>A similar trick can be used to print a table telling you how many words begin with each letter.</p><pre><code class="language-java">1.  **for** (**char** ch = &#x27;a&#x27;; ch &lt;= &#x27;z&#x27;;) {  
2.      String from = String.valueOf(ch++);  
3.      String to = String.valueOf(ch);  
4.      System.out.println(from + &quot;: &quot; + dictionary.subSet(from, to).size());  
5.  }  
</code></pre><p>Suppose you want to view a <em>closed interval</em>, which contains both of its endpoints, instead of an open interval. If the element type allows for the calculation of the successor of a given value in the element space, merely request the subSet from lowEndpoint to successor(highEndpoint). Although it isn&#x27;t entirely obvious, the successor of a string s in String&#x27;s natural ordering is s + &quot;<!-- -->\<!-- -->0&quot; --- that is, s with a null character appended.</p><p>Thus, the following one-liner tells you how many words between &quot;doorbell&quot; and &quot;pickle&quot;, including doorbell <em>and</em> pickle, are contained in the dictionary.</p><pre><code class="language-java">1.  count = dictionary.subSet(&quot;doorbell&quot;, &quot;pickle\\0&quot;).size();  
</code></pre><p>A similar technique can be used to view an <em>open interval</em>, which contains neither endpoint. The open-interval view from lowEndpoint to highEndpoint is the half-open interval from successor(lowEndpoint) to highEndpoint. Use the following to calculate the number of words between &quot;doorbell&quot; and &quot;pickle&quot;, excluding both.</p><pre><code class="language-java">1.  count = dictionary.subSet(&quot;doorbell\\0&quot;, &quot;pickle&quot;).size();  
</code></pre><p>The SortedSet interface contains two more range-view operations --- headSet and tailSet, both of which take a single Object argument. The former returns a view of the initial portion of the backing SortedSet, up to but not including the specified object. The latter returns a view of the final portion of the backing SortedSet, beginning with the specified object and continuing to the end of the backing SortedSet. Thus, the following code allows you to view the dictionary as two disjoint volumes (a-m and n-z).</p><pre><code class="language-java">1.  SortedSet &lt; String &gt; volume1 = dictionary.headSet(&quot;n&quot;);  
2.  SortedSet &lt; String &gt; volume2 = dictionary.tailSet(&quot;n&quot;);  
</code></pre><h4>13.3.8.4 Endpoint Operations</h4><p>The SortedSet interface contains operations to return the first and last elements in the sorted set, not surprisingly called first and last. In addition to their obvious uses, last allows a workaround for a deficiency in the SortedSet interface. One thing you&#x27;d like to do with a SortedSet is to go into the interior of the Set and iterate forward or backward. It&#x27;s easy enough to go forward from the interior: Just get a tailSet and iterate over it. Unfortunately, there&#x27;s no easy way to go backward.</p><p>The following idiom obtains the first element that is less than a specified object o in the element space.</p><pre><code class="language-java">1.  Object predecessor = ss.headSet(o).last();  
</code></pre><p>This is a fine way to go one element backward from a point in the interior of a sorted set. It could be applied repeatedly to iterate backward, but this is very inefficient, requiring a lookup for each element returned.</p><h4>13.3.8.5 Comparator Accessor</h4><p>The SortedSet interface contains an accessor method called comparator that returns the Comparator used to sort the set, or null if the set is sorted according to the <em>natural ordering</em> of its elements. This method is provided so that sorted sets can be copied into new sorted sets with the same ordering. It is used by the SortedSet constructor described <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/sorted-set.html#constructor">previously</a>.</p><h3>13.3.9 The SortedMap Interface</h3><p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html">SortedMap</a> is a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">Map</a> that maintains its entries in ascending order, sorted according to the keys&#x27; natural ordering, or according to a Comparator provided at the time of the SortedMapcreation. Natural ordering and Comparators are discussed in the <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/order.html">Object Ordering</a> section. The SortedMap interface provides operations for normal Map operations and for the following:</p><ul><li>Range view --- performs arbitrary range operations on the sorted map</li><li>Endpoints --- returns the first or the last key in the sorted map</li><li>Comparator access --- returns the Comparator, if any, used to sort the map</li></ul><p>The following interface is the Map analog of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html">SortedSet</a>.</p><pre><code class="language-java">1.  **public** **interface** SortedMap &lt; K, V &gt; **extends** Map &lt; K, V &gt; {  
2.      Comparator &lt;? **super** K &gt; comparator();  
3.      SortedMap &lt; K, V &gt; subMap(K fromKey, K toKey);  
4.      SortedMap &lt; K, V &gt; headMap(K toKey);  
5.      SortedMap &lt; K, V &gt; tailMap(K fromKey);  
6.      K firstKey();  
7.      K lastKey();  
8.  }  
</code></pre><h4>13.3.9.1 Map Operations</h4><p>The operations SortedMap inherits from Map behave identically on sorted maps and normal maps with two exceptions:</p><ul><li>The Iterator returned by the iterator operation on any of the sorted map&#x27;s Collection views traverse the collections in order.</li><li>The arrays returned by the Collection views&#x27; toArray operations contain the keys, values, or entries in order.</li></ul><p>Although it isn&#x27;t guaranteed by the interface, the toString method of the Collection views in all the Java platform&#x27;s SortedMap implementations returns a string containing all the elements of the view, in order.</p><h4>13.3.9.2 Standard Constructors</h4><p>By convention, all general-purpose Map implementations provide a standard conversion constructor that takes a Map; SortedMap implementations are no exception. In TreeMap, this constructor creates an instance that orders its entries according to their keys&#x27; natural ordering. This was probably a mistake. It would have been better to check dynamically to see whether the specified Mapinstance was a SortedMap and, if so, to sort the new map according to the same criterion (comparator or natural ordering). Because TreeMap took the approach it did, it also provides a constructor that takes a SortedMap and returns a new TreeMap containing the same mappings as the given SortedMap, sorted according to the same criterion. Note that it is the compile-time type of the argument, not its runtime type, that determines whether the SortedMap constructor is invoked in preference to the ordinary map constructor.</p><p>SortedMap implementations also provide, by convention, a constructor that takes a Comparator and returns an empty map sorted according to the specified Comparator. If null is passed to this constructor, it returns a Map that sorts its mappings according to their keys&#x27; natural ordering.</p><h4>13.3.9.3 Comparison to SortedSet</h4><p>Because this interface is a precise Map analog of SortedSet, all the idioms and code examples in <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/sorted-set.html">The SortedSet Interface</a> section apply to SortedMap with only trivial modifications.</p><h3>13.3.10 Summary of Interfaces</h3><p>The core collection interfaces are the foundation of the Java Collections Framework.</p><p>The Java Collections Framework hierarchy consists of two distinct interface trees:</p><ul><li>The first tree starts with the Collection interface, which provides for the basic functionality used by all collections, such as add and remove methods. Its subinterfaces --- Set, List, and Queue --- provide for more specialized collections.</li><li>The Set interface does not allow duplicate elements. This can be useful for storing collections such as a deck of cards or student records. The Set interface has a subinterface, SortedSet, that provides for ordering of elements in the set.</li><li>The List interface provides for an ordered collection, for situations in which you need precise control over where each element is inserted. You can retrieve elements from a List by their exact position.</li><li>The Queue interface enables additional insertion, extraction, and inspection operations. Elements in a Queue are typically ordered in on a FIFO basis.</li><li>The Deque interface enables insertion, deletion, and inspection operations at both the ends. Elements in a Deque can be used in both LIFO and FIFO.</li><li>The second tree starts with the Map interface, which maps keys and values similar to a Hashtable.</li><li>Map&#x27;s subinterface, SortedMap, maintains its key-value pairs in ascending order or in an order specified by a Comparator.</li></ul><p>These interfaces allow collections to be manipulated independently of the details of their representation.</p><h2>13.4 Aggregate Operations</h2><p>As before, suppose that members of this social networking application are represented by the following <a href="https://docs.oracle.com/javase/tutorial/collections/streams/examples/Person.java">Person</a> class:</p><pre><code class="language-java">1.  **public** **class** Person {  
2.      **public** **enum** Sex {  
3.          MALE, FEMALE  
4.      }  
5.      String name;  
6.      LocalDate birthday;  
7.      Sex gender;  
8.      String emailAddress; // \...  
9.      **public** **int** getAge() { // \...  
10.     }  
11.     **public** String getName() { // \...  
12.     }  
13. }  
</code></pre><p>The following example prints the name of all members contained in the collection roster with a for-each loop:</p><pre><code class="language-java">1.  **for** (Person p: roster) {  
2.      System.out.println(p.getName());  
3.  }  
</code></pre><p>The following example prints all members contained in the collection roster but with the aggregate operation forEach:</p><pre><code class="language-java">1.  roster.stream().forEach(e - &gt; System.out.println(e.getName());  
</code></pre><p>Although, in this example, the version that uses aggregate operations is longer than the one that uses a for-each loop, you will see that versions that use bulk-data operations will be more concise for more complex tasks.</p><h4>13.4.0.1 Pipelines and Streams</h4><p>A <em>pipeline</em> is a sequence of aggregate operations. The following example prints the male members contained in the collection roster with a pipeline that consists of the aggregate operations filter and forEach:</p><pre><code class="language-java">1.  roster.stream().filter(e - &gt; e.getGender() == Person.Sex.MALE).forEach(e - &gt; System.out.println(e.getName()));  
</code></pre><p>Compare this example to the following that prints the male members contained in the collection roster with a for-each loop:</p><pre><code class="language-java">1.  **for** (Person p: roster) {  
2.      **if** (p.getGender() == Person.Sex.MALE) {  
3.          System.out.println(p.getName());  
4.      }  
5.  }  
</code></pre><p>A pipeline contains the following components:</p><p>A source: This could be a collection, an array, a generator function, or an I/O channel. In this example, the source is the collection roster.</p><p>Zero or more <em>intermediate operations</em>. An intermediate operation, such as filter, produces a new stream.</p><p>A <em>stream</em> is a sequence of elements. Unlike a collection, it is not a data structure that stores elements. Instead, a stream carries values from a source through a pipeline. This example creates a stream from the collection roster by invoking the method stream.</p><p>The filter operation returns a new stream that contains elements that match its predicate (this operation&#x27;s parameter). In this example, the predicate is the lambda expression e -&gt; e.getGender() == Person.Sex.MALE. It returns the boolean value true if the gender field of object e has the value Person.Sex.MALE. Consequently, the filter operation in this example returns a stream that contains all male members in the collection roster.</p><p>A <em>terminal operation</em>. A terminal operation, such as forEach, produces a non-stream result, such as a primitive value (like a double value), a collection, or in the case of forEach, no value at all. In this example, the parameter of the forEach operation is the lambda expression e -&gt; System.out.println(e.getName()), which invokes the method getName on the object e. (The Java runtime and compiler infer that the type of the object e is Person.)</p><p>The following example calculates the average age of all male members contained in the collection roster with a pipeline that consists of the aggregate operations filter, mapToInt, and average:</p><ol><li><strong>double</strong> average = roster.stream().filter(p - &gt; p.getGender() == Person.Sex.MALE).mapToInt(Person::getAge).average().getAsDouble();  </li></ol><p>The <strong>mapToInt operation returns a new stream of type IntStream</strong> (which is a stream that contains only integer values). The operation applies the function specified in its parameter to each element in a particular stream. The average operation calculates the average value of the elements contained in a stream of type IntStream. It returns an object of type OptionalDouble. If the stream contains no elements, then the average operation returns an empty instance of OptionalDouble, and invoking the method getAsDouble throws a NoSuchElementException. <strong>The JDK contains many terminal operations such as average that return one value by combining the contents of a stream. These operations are called <em>reduction operations</em></strong>; see the section <a href="https://docs.oracle.com/javase/tutorial/collections/streams/reduction.html">Reduction</a> for more information.</p><h4>13.4.0.2 Differences Between Aggregate Operations and Iterators</h4><p>Aggregate operations, like forEach, appear to be like iterators. However, they have several fundamental differences:</p><ul><li><strong>They use internal iteration</strong>: Aggregate operations do not contain a method like next to instruct them to process the next element of the collection. With <em>internal delegation</em>, your application determines <em>what</em> collection it iterates, but the JDK determines <em>how</em> to iterate the collection. With <em>external iteration</em>, your application determines both what collection it iterates and how it iterates it. However, external iteration can only iterate over the elements of a collection sequentially. Internal iteration does not have this limitation. It can more easily take advantage of parallel computing, which involves dividing a problem into subproblems, solving those problems simultaneously, and then combining the results of the solutions to the subproblems. See the section <a href="https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html">Parallelism</a> for more information.</li><li><strong>They process elements from a stream: Aggregate operations process elements from a stream, not directly from a collection. Consequently, they are also called <em>stream operations</em></strong>.</li><li><strong>They support behavior as parameters</strong>: You can specify <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">lambda expressions</a> as parameters for most aggregate operations. This enables you to customize the behavior of a particular aggregate operation.</li></ul><h3>13.4.1 Reduction</h3><p>The section <a href="https://docs.oracle.com/javase/tutorial/collections/streams/index.html">Aggregate Operations</a> describes the following pipeline of operations, which calculates the average age of all male members in the collection roster:</p><ol><li><strong>double</strong> average = roster.stream().filter(p - &gt; p.getGender() == Person.Sex.MALE).mapToInt(Person::getAge).average().getAsDouble();  </li></ol><p>The JDK contains many terminal operations (such as <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#average--java/lang/reflect/Executable.html"><strong>average</strong></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#sum--"><strong>sum</strong></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#min-java.util.Comparator-"><strong>min</strong></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#max-java.util.Comparator-"><strong>max</strong></a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#count--"><strong>count</strong></a>) that return one value by combining the contents of a stream. These operations are called <em>reduction operations</em>. The JDK also contains reduction operations that return a collection instead of a single value. Many reduction operations perform a specific task, such as finding the average of values or grouping elements into categories. However, the JDK provides you with the general-purpose reduction operations <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-">reduce</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BiConsumer-">collect</a>, which this section describes in detail.</p><p>You can find the code excerpts described in this section in the example <a href="https://docs.oracle.com/javase/tutorial/collections/streams/examples/ReductionExamples.java">ReductionExamples</a>.</p><h4>13.4.1.1 The Stream.reduce Method</h4><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-">Stream.reduce</a> method is a general-purpose reduction operation. Consider the following pipeline, which calculates the sum of the male members&#x27; ages in the collection roster. It uses the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#sum--">Stream.sum</a> reduction operation:</p><ol><li>Integer totalAge = roster.stream().mapToInt(Person::getAge).sum();  </li></ol><p>Compare this with the following pipeline, which uses the Stream.reduce operation to calculate the same value:</p><ol><li>Integer totalAgeReduce = roster.stream().map(Person::getAge).reduce(0, (a, b) - &gt; a + b);  </li></ol><p>The reduce operation in this example takes two arguments:</p><ul><li>identity: The identity element is both the <strong>initial value of the reduction and the default result</strong> if there are no elements in the stream. In this example, the identity element is 0; this is the initial value of the sum of ages and the default value if no members exist in the collection roster.</li><li>accumulator: The accumulator function takes two parameters: <strong>a partial result of the reduction (in this example, the sum of all processed integers so far) and the next element of the stream (in this example, an integer). It returns a new partial result. In this example, the accumulator function is a lambda expression that adds two Integer values and returns an Integer value:</strong> (a, b) -&gt; a + b</li></ul><p>The <strong>reduce operation always returns a new value</strong>. However, the accumulator function also returns a new value every time it processes an element of a stream. Suppose that <strong>you want to reduce the elements of a stream to a more complex object, such as a collection. This might hinder the performance of your application</strong>. If your reduce operation involves adding elements to a collection, then every time your accumulator function processes an element, it creates a new collection that includes the element, which is inefficient. <strong>It would be more efficient for you to update an existing collection instead. You can do this with the </strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BiConsumer-"><strong>Stream.collect</strong></a><strong> method,</strong> which the next section describes.</p><p><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce">https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce</a></p><h4>13.4.1.2 The Stream.collect Method</h4><p>Unlike the reduce method, which always creates a new value when it processes an element, the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BiConsumer-">collect</a> method modifies, or mutates, an existing value.</p><p>Consider how to find the average of values in a stream. You require two pieces of data: the total number of values and the sum of those values. However, like the reduce method and all other reduction methods, the collect method returns only one value. You can create a new data type that contains member variables that keep track of the total number of values and the sum of those values, such as the following class, <a href="https://docs.oracle.com/javase/tutorial/collections/streams/examples/Averager.java">Averager</a>:</p><ol><li><strong>class</strong> Averager <strong>implements</strong> IntConsumer {  </li><li>    <strong>private</strong> <strong>int</strong> total = 0;  </li><li>    <strong>private</strong> <strong>int</strong> count = 0;  </li><li>    <strong>public</strong> <strong>double</strong> average() {  </li><li>        <strong>return</strong> count &gt; 0 ? ((<strong>double</strong>) total) / count : 0;  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> accept(<strong>int</strong> i) {  </li><li>        total += i;  </li><li>        count++;  </li><li>    }  </li><li>    <strong>public</strong> <strong>void</strong> combine(Averager other) {  </li><li>        total += other.total;  </li><li>        count += other.count;  </li><li>    }  </li><li>}  </li></ol><p>The following pipeline uses the Averager class and the collect method to calculate the average age of all male members:</p><ol><li>Averager averageCollect = roster.stream().filter(p - &gt; p.getGender() == Person.Sex.MALE).map(Person::getAge).collect(Averager::<strong>new</strong>, Averager::accept, Averager::combine);  </li><li>System.out.println(&quot;Average age of male members: &quot; + averageCollect.average());  </li></ol><p>The collect operation in this example takes three arguments:</p><ul><li>supplier: The supplier is a factory function; it constructs new instances. For the collect operation, it creates instances of the result container. In this example, it is a new instance of the Averager class.</li><li>accumulator: The accumulator function incorporates a stream element into a result container. In this example, it modifies the Averager result container by incrementing the countvariable by one and adding to the total member variable the value of the stream element, which is an integer representing the age of a male member.</li><li>combiner: The combiner function takes two result containers and merges their contents. In this example, it modifies an Averager result container by incrementing the count variable by the count member variable of the other Averager instance and adding to the total member variable the value of the other Averager instance&#x27;s total member variable.</li></ul><p>Note the following:</p><ul><li>The supplier is a lambda expression (or a method reference) as opposed to a value like the identity element in the reduce operation.</li><li>The accumulator and combiner functions do not return a value.</li><li>You can use the collect operations with parallel streams; see the section <a href="https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html">Parallelism</a> for more information. (If you run the collect method with a parallel stream, then the JDK creates a new thread whenever the combiner function creates a new object, such as an Averager object in this example. Consequently, you do not have to worry about synchronization.)</li></ul><p>Although the JDK provides you with the average operation to calculate the average value of elements in a stream, you can use the collect operation and a custom class if you need to calculate several values from the elements of a stream.</p><p>The collect operation is best suited for collections. The following example puts the names of the male members in a collection with the collect operation:</p><ol><li>List &lt; String &gt; namesOfMaleMembersCollect = roster.stream().filter(p - &gt; p.getGender() == Person.Sex.MALE).map(p - &gt; p.getName()).collect(Collectors.toList());  </li></ol><p>This version of the collect operation takes one parameter of type <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html">Collector</a>. This class encapsulates the functions used as arguments in the collect operation that requires three arguments (supplier, accumulator, and combiner functions).</p><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html">Collectors</a> class contains many useful reduction operations, such as accumulating elements into collections and summarizing elements according to various criteria. These reduction operations return instances of the class Collector, so you can use them as a parameter for the collect operation.</p><p>This example uses the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toList--">Collectors.toList</a> operation, which accumulates the stream elements into a new instance of List. As with most operations in the Collectors class, the toListoperator returns an instance of Collector, not a collection.</p><p>The following example groups members of the collection roster by gender:</p><ol><li>Map &lt; Person.Sex, List &lt; Person &gt;&gt; byGender = roster.stream().collect(Collectors.groupingBy(Person::getGender));  </li></ol><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-">groupingBy</a> operation returns a map whose keys are the values that result from applying the lambda expression specified as its parameter (which is called a <em>classification function</em>). In this example, the returned map contains two keys, Person.Sex.MALE and Person.Sex.FEMALE. The keys&#x27; corresponding values are instances of List that contain the stream elements that, when processed by the classification function, correspond to the key value. For example, the value that corresponds to key Person.Sex.MALE is an instance of List that contains all male members.</p><p>The following example retrieves the names of each member in the collection roster and groups them by gender:</p><ol><li>Map &lt; Person.Sex, List &lt; String &gt;&gt; namesByGender = roster.stream().collect(Collectors.groupingBy(Person::getGender, Collectors.mapping(Person::getName, Collectors.toList())));  </li></ol><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.stream.Collector-">groupingBy</a> operation in this example takes two parameters, a classification function and an instance of Collector. The Collector parameter is called a <em>downstream collector</em>. This is a collector that the Java runtime applies to the results of another collector. Consequently, this groupingBy operation enables you to apply a collect method to the List values created by the groupingBy operator. This example applies the collector <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#mapping-java.util.function.Function-java.util.stream.Collector-java.util.stream.Collector-">mapping</a>, which applies the mapping function Person::getName to each element of the stream. Consequently, the resulting stream consists of only the names of members. A pipeline that contains one or more downstream collectors, like this example, is called a <em>multilevel reduction</em>.</p><p>The following example retrieves the total age of members of each gender:</p><ol><li>Map &lt; Person.Sex, Integer &gt; totalAgeByGender = roster.stream().collect(Collectors.groupingBy(Person::getGender, Collectors.reducing(0, Person::getAge, Integer::sum)));  </li></ol><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#reducing-U-java.util.function.Function-java.util.function.BinaryOperator-">reducing</a> operation takes three parameters:</p><ul><li>identity: Like the Stream.reduce operation, the identity element is both the initial value of the reduction and the default result if there are no elements in the stream. In this example, the identity element is 0; this is the initial value of the sum of ages and the default value if no members exist.</li><li>mapper: The reducing operation applies this mapper function to all stream elements. In this example, the mapper retrieves the age of each member.</li><li>operation: The operation function is used to reduce the mapped values. In this example, the operation function adds Integer values.</li></ul><p>The following example retrieves the average age of members of each gender:</p><ol><li>Map &lt; Person.Sex, Double &gt; averageAgeByGender = roster.stream().collect(Collectors.groupingBy(Person::getGender, Collectors.averagingInt(Person::getAge)));  </li></ol><h3>13.4.2 Parallelism</h3><p>Parallel computing involves dividing a problem into subproblems, solving those problems simultaneously (in parallel, with each subproblem running in a separate thread), and then combining the results of the solutions to the subproblems. Java SE provides the <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">fork/join framework</a>, which enables you to more easily implement parallel computing in your applications. However, with this framework, you must specify how the problems are subdivided (partitioned). With aggregate operations, the Java runtime performs this partitioning and combining of solutions for you.</p><p>One difficulty in implementing parallelism in applications that use collections is that collections are not thread-safe, which means that multiple threads cannot manipulate a collection without introducing <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/interfere.html">thread interference</a> or <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/memconsist.html">memory consistency errors</a>. The Collections Framework provides <a href="https://docs.oracle.com/javase/tutorial/collections/implementations/wrapper.html">synchronization wrappers</a>, which add automatic synchronization to an arbitrary collection, making it thread-safe. However, synchronization introduces <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html#thread_contention">thread contention</a>. You want to avoid thread contention because it prevents threads from running in parallel. Aggregate operations and parallel streams enable you to implement parallelism with non-thread-safe collections provided that you do not modify the collection while you are operating on it.</p><p>Note that parallelism is not automatically faster than performing operations serially, although it can be if you have enough data and processor cores. While aggregate operations enable you to more easily implement parallelism, it is still your responsibility to determine if your application is suitable for parallelism.</p><p>You can find the code excerpts described in this section in the example <a href="https://docs.oracle.com/javase/tutorial/collections/streams/examples/ParallelismExamples.java">ParallelismExamples</a>.</p><h4>13.4.2.1 Executing Streams in Parallel</h4><p>You can execute streams in serial or in parallel. When a stream executes in parallel, the Java runtime partitions the stream into multiple substreams. Aggregate operations iterate over and process these substreams in parallel and then combine the results.</p><p>When you create a stream, it is always a serial stream unless otherwise specified. To create a parallel stream, invoke the operation <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#parallelStream--">Collection.parallelStream</a>. Alternatively, invoke the operation <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#parallel--">BaseStream.parallel</a>. For example, the following statement calculates the average age of all male members in parallel:</p><p>[]{#bookmark=id.4ev95cb}</p><ol><li><strong>double</strong> average = roster.parallelStream().filter(p - &gt; p.getGender() == Person.Sex.MALE).mapToInt(Person::getAge).average().getAsDouble();  </li></ol><h4>13.4.2.2 Concurrent Reduction</h4><p>Consider again the following example (which is described in the section <a href="https://docs.oracle.com/javase/tutorial/collections/streams/reduction.html">Reduction</a>) that groups members by gender. This example invokes the collect operation, which reduces the collection roster into a Map:</p><ol><li>Map &lt; Person.Sex, List &lt; Person &gt;&gt; byGender = roster.stream().collect(Collectors.groupingBy(Person::getGender));  </li></ol><p>The following is the parallel equivalent:</p><ol><li>ConcurrentMap &lt; Person.Sex, List &lt; Person &gt;&gt; byGender = roster.parallelStream().collect(Collectors.groupingByConcurrent(Person::getGender));  </li></ol><p>This is called a <em>concurrent reduction</em>. The Java runtime performs a concurrent reduction if all of the the following are true for a particular pipeline that contains the collect operation:</p><ul><li>The stream is parallel.</li><li>The parameter of the collect operation, the collector, has the characteristic <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#CONCURRENT">Collector.Characteristics.CONCURRENT</a>. To determine the characteristics of a collector, invoke the<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html">Collector.characteristics</a> method.</li><li>Either the stream is unordered, or the collector has the characteristic <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#UNORDERED">Collector.Characteristics.UNORDERED</a>. To ensure that the stream is unordered, invoke the<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#unordered--">BaseStream.unordered</a> operation.</li></ul><p><strong>Note</strong>: This example returns an instance of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html">ConcurrentMap</a> instead of Map and invokes the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-">groupingByConcurrent</a> operation instead of groupingBy. (See the section <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/collections.html">Concurrent Collections</a> for more information about ConcurrentMap.) Unlike the operation groupingByConcurrent, the operation groupingBy performs poorly with parallel streams. (This is because it operates by merging two maps by key, which is computationally expensive.) Similarly, the operation <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-">Collectors.toConcurrentMap</a> performs better with parallel streams than the operation<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-">Collectors.toMap</a>.</p><h4>13.4.2.3 Ordering</h4><p>The order in which a pipeline processes the elements of a stream depends on whether the stream is executed in serial or in parallel, the source of the stream, and intermediate operations. For example, consider the following example that prints the elements of an instance of ArrayList with the forEach operation several times:</p><ol><li>Integer[] intArray = {  </li><li>    1, 2, 3, 4, 5, 6, 7, 8  </li><li>};  </li><li>List &lt; Integer &gt; listOfIntegers = <strong>new</strong> ArrayList &lt; &gt; (Arrays.asList(intArray));  </li><li>System.out.println(&quot;listOfIntegers:&quot;);  </li><li>listOfIntegers.stream().forEach(e - &gt; System.out.print(e + &quot; &quot;));  </li><li>System.out.println(&quot;&quot;);  </li><li>System.out.println(&quot;listOfIntegers sorted in reverse order:&quot;);  </li><li>Comparator &lt; Integer &gt; normal = Integer::compare;  </li><li>Comparator &lt; Integer &gt; reversed = normal.reversed();  </li><li>Collections.sort(listOfIntegers, reversed);  </li><li>listOfIntegers.stream().forEach(e - &gt; System.out.print(e + &quot; &quot;));  </li><li>System.out.println(&quot;&quot;);  </li><li>System.out.println(&quot;Parallel stream&quot;);  </li><li>listOfIntegers.parallelStream().forEach(e - &gt; System.out.print(e + &quot; &quot;));  </li><li>System.out.println(&quot;&quot;);  </li><li>System.out.println(&quot;Another parallel stream:&quot;);  </li><li>listOfIntegers.parallelStream().forEach(e - &gt; System.out.print(e + &quot; &quot;));  </li><li>System.out.println(&quot;&quot;);  </li><li>System.out.println(&quot;With forEachOrdered:&quot;);  </li><li>listOfIntegers.parallelStream().forEachOrdered(e - &gt; System.out.print(e + &quot; &quot;));  </li><li>System.out.println(&quot;&quot;);  </li></ol><p>This example consists of five pipelines. It prints output similar to the following:</p><ol><li>listOfIntegers: 1 2 3 4 5 6 7 8 listOfIntegers sorted <strong>in</strong> reverse order: 8 7 6 5 4 3 2 1 Parallel stream: 3 4 1 6 2 5 7 8 Another parallel stream: 6 3 1 5 7 8 4 2 With forEachOrdered: 8 7 6 5 4 3 2 1  </li></ol><p>This example does the following:</p><ul><li>The first pipeline prints the elements of the list listOfIntegers in the order that they were added to the list.</li><li>The second pipeline prints the elements of listOfIntegers after it was sorted by the method <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-">Collections.sort</a>.</li><li>The third and fourth pipelines print the elements of the list in an apparently random order. Remember that stream operations use internal iteration when processing elements of a stream. Consequently, when you execute a stream in parallel, the Java compiler and runtime determine the order in which to process the stream&#x27;s elements to maximize the benefits of parallel computing unless otherwise specified by the stream operation.</li><li>The fifth pipeline uses the method <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEachOrdered-java.util.function.Consumer-">forEachOrdered</a>, which processes the elements of the stream in the order specified by its source, regardless of whether you executed the stream in serial or parallel. Note that you may lose the benefits of parallelism if you use operations like forEachOrdered with parallel streams.</li></ul><h4>13.4.2.4 Side Effects</h4><p>A method or an expression has a side effect if, in addition to returning or producing a value, it also modifies the state of the computer. Examples include mutable reductions (operations that use the collect operation; see the section <a href="https://docs.oracle.com/javase/tutorial/collections/streams/reduction.html">Reduction</a> for more information) as well as invoking the System.out.println method for debugging. The JDK handles certain side effects in pipelines well. In particular, the collect method is designed to perform the most common stream operations that have side effects in a parallel-safe manner. Operations like forEach and peek are designed for side effects; a lambda expression that returns void, such as one that invokes System.out.println, can do nothing but have side effects. Even so, you should use the forEachand peek operations with care; if you use one of these operations with a parallel stream, then the Java runtime may invoke the lambda expression that you specified as its parameter concurrently from multiple threads. In addition, never pass as parameters lambda expressions that have side effects in operations such as filter and map. The following sections discuss <a href="https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html#interference">interference</a> and <a href="https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html#stateful_lambda_expressions">stateful lambda expressions</a>, both of which can be sources of side effects and can return inconsistent or unpredictable results, especially in parallel streams. However, the concept of <a href="https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html#laziness">laziness</a> is discussed first, because it has a direct effect on interference.</p><h5>13.4.2.4.1 Laziness</h5><p>All intermediate operations are <em>lazy</em>. An expression, method, or algorithm is lazy if its value is evaluated only when it is required. (An algorithm is <em>eager</em> if it is evaluated or processed immediately.) Intermediate operations are lazy because they do not start processing the contents of the stream until the terminal operation commences. Processing streams lazily enables the Java compiler and runtime to optimize how they process streams. For example, in a pipeline such as the filter-mapToInt-average example described in the section <a href="https://docs.oracle.com/javase/tutorial/collections/streams/index.html">Aggregate Operations</a>, the averageoperation could obtain the first several integers from the stream created by the mapToInt operation, which obtains elements from the filter operation. The average operation would repeat this process until it had obtained all required elements from the stream, and then it would calculate the average.</p><h5>13.4.2.4.2 Interference</h5><p>Lambda expressions in stream operations should not <em>interfere</em>. Interference occurs when the source of a stream is modified while a pipeline processes the stream. For example, the following code attempts to concatenate the strings contained in the List listOfStrings. However, it throws a ConcurrentModificationException:</p><ol><li><strong>try</strong> {  </li><li>    List &lt; String &gt; listOfStrings = <strong>new</strong> ArrayList &lt; &gt; (Arrays.asList(&quot;one&quot;, &quot;two&quot;)); // This will fail as the peek operation will attempt to add the // string &quot;three&quot; to the source after the terminal operation has // commenced.   </li><li>    String concatenatedString = listOfStrings.stream() // Don&#x27;t do this! Interference occurs here.  </li><li>        .peek(s - &gt; listOfStrings.add(&quot;three&quot;)).reduce((a, b) - &gt; a + &quot; &quot; + b).get();  </li><li>    System.out.println(&quot;Concatenated string: &quot; + concatenatedString);  </li><li>} <strong>catch</strong> (Exception e) {  </li><li>    System.out.println(&quot;Exception caught: &quot; + e.toString());  </li><li>}  </li></ol><p>This example concatenates the strings contained in listOfStrings into an <code>Optional&lt;String&gt;</code> value with the reduce operation, which is a terminal operation. However, the pipeline here invokes the intermediate operation peek, which attempts to add a new element to listOfStrings. Remember, all intermediate operations are lazy. This means that the pipeline in this example begins execution when the operation get is invoked, and ends execution when the get operation completes. The argument of the peek operation attempts to modify the stream source during the execution of the pipeline, which causes the Java runtime to throw a ConcurrentModificationException.</p><h5>13.4.2.4.3 Stateful Lambda Expressions</h5><p>Avoid using <em>stateful lambda expressions</em> as parameters in stream operations. A stateful lambda expression is one whose result depends on any state that might change during the execution of a pipeline. The following example adds elements from the List listOfIntegers to a new List instance with the map intermediate operation. It does this twice, first with a serial stream and then with a parallel stream:</p><ol><li>List &lt; Integer &gt; serialStorage = <strong>new</strong> ArrayList &lt; &gt; ();  </li><li>System.out.println(&quot;Serial stream:&quot;);  </li><li>listOfIntegers.stream() // Don&#x27;t do this! It uses a stateful lambda expression.  </li><li>    .map(e - &gt; {  </li><li>        serialStorage.add(e);  </li><li>        <strong>return</strong> e;  </li><li>    }).forEachOrdered(e - &gt; System.out.print(e + &quot; &quot;));  </li><li>System.out.println(&quot;&quot;);  </li><li>serialStorage.stream().forEachOrdered(e - &gt; System.out.print(e + &quot; &quot;));  </li><li>System.out.println(&quot;&quot;);  </li><li>System.out.println(&quot;Parallel stream:&quot;);  </li><li>List &lt; Integer &gt; parallelStorage = Collections.synchronizedList(<strong>new</strong> ArrayList &lt; &gt; ());  </li><li>listOfIntegers.parallelStream() // Don&#x27;t do this! It uses a stateful lambda expression.  </li><li>    .map(e - &gt; {  </li><li>        parallelStorage.add(e);  </li><li>        <strong>return</strong> e;  </li><li>    }).forEachOrdered(e - &gt; System.out.print(e + &quot; &quot;));  </li><li>System.out.println(&quot;&quot;);  </li><li>parallelStorage.stream().forEachOrdered(e - &gt; System.out.print(e + &quot; &quot;));  </li><li>System.out.println(&quot;&quot;);  </li></ol><p>The lambda expression e -&gt; { parallelStorage.add(e); return e; } is a stateful lambda expression. Its result can vary every time the code is run. This example prints the following:</p><ol><li>Serial stream: 8 7 6 5 4 3 2 1 8 7 6 5 4 3 2 1 Parallel stream: 8 7 6 5 4 3 2 1 1 3 6 2 4 5 8 7  </li></ol><p>The operation forEachOrdered processes elements in the order specified by the stream, regardless of whether the stream is executed in serial or parallel. However, when a stream is executed in parallel, the map operation processes elements of the stream specified by the Java runtime and compiler. Consequently, the order in which the lambda expression e -&gt; { parallelStorage.add(e); return e; } adds elements to the List parallelStorage can vary every time the code is run. For deterministic and predictable results, ensure that lambda expression parameters in stream operations are not stateful.</p><p><strong>Note</strong>: This example invokes the method <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedList-java.util.List-">synchronizedList</a> so that the List parallelStorage is thread-safe. Remember that collections are not thread-safe. This means that multiple threads should not access a particular collection at the same time. Suppose that you do not invoke the method synchronizedList when creating parallelStorage:</p><ol><li>List &lt; Integer &gt; parallelStorage = <strong>new</strong> ArrayList &lt; &gt; ();  </li></ol><p>The example behaves erratically because multiple threads access and modify parallelStorage without a mechanism like synchronization to schedule when a particular thread may access the List instance. Consequently, the example could print output similar to the following:</p><ol><li>Parallel stream: 8 7 6 5 4 3 2 1 <strong>null</strong> 3 5 4 7 8 1 2  </li></ol><h2>13.5 Implementations</h2><p>Implementations are the data objects used to store collections, which implement the interfaces described in <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html">the Interfaces section</a>. This lesson describes the following kinds of implementations:</p><ul><li><strong>General-purpose implementations</strong> are the most commonly used implementations, designed for everyday use. They are summarized in the table titled General-purpose-implementations.</li><li><strong>Special-purpose implementations</strong> are designed for use in special situations and display nonstandard performance characteristics, usage restrictions, or behavior.</li><li><strong>Concurrent implementations</strong> are designed to support high concurrency, typically at the expense of single-threaded performance. These implementations are part of the java.util.concurrent package.</li><li><strong>Wrapper implementations</strong> are used in combination with other types of implementations, often the general-purpose ones, to provide added or restricted functionality.</li><li><strong>Convenience implementations</strong> are mini-implementations, typically made available via static factory methods, that provide convenient, efficient alternatives to general-purpose implementations for special collections (for example, singleton sets).</li><li><strong>Abstract implementations</strong> are skeletal implementations that facilitate the construction of custom implementations --- described later in the <a href="https://docs.oracle.com/javase/tutorial/collections/custom-implementations/index.html">Custom Collection Implementations</a> section. An advanced topic, it&#x27;s not particularly difficult, but relatively few people will need to do it.</li></ul><p>The general-purpose implementations are summarized in the following table.</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>General-purpose Implementations</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Interfaces</td><td><strong>Hash table Implementations</strong></td><td><strong>Resizable array Implementations</strong></td><td><strong>Tree Implementations</strong></td><td><strong>Linked list Implementations</strong></td><td><strong>Hash table + Linked list Implementations</strong></td></tr><tr><td>Set</td><td>HashSet</td><td> </td><td>TreeSet</td><td> </td><td>LinkedHashSet</td></tr><tr><td>List</td><td> </td><td>ArrayList</td><td> </td><td>LinkedList</td><td> </td></tr><tr><td>Queue</td><td> </td><td> </td><td> </td><td> </td><td> </td></tr><tr><td>Deque</td><td> </td><td>ArrayDeque</td><td> </td><td>LinkedList</td><td> </td></tr><tr><td>Map</td><td>HashMap</td><td> </td><td>TreeMap</td><td> </td><td>LinkedHashMap</td></tr></tbody></table><p>As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html">Set</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">List</a> , and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">Map</a> interfaces. In each case, one implementation ---<a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html">HashSet</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList</a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a> --- is clearly the one to use for most applications, all other things being equal. Note that the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html">SortedSet</a> and the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html">SortedMap</a> interfaces do not have rows in the table. Each of those interfaces has one implementation <a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html">(TreeSet</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html">TreeMap</a>) and is listed in the Set and the Map rows. There are two general-purpose Queue implementations ---<a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html">LinkedList</a>, which is also a List implementation, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html">PriorityQueue</a>, which is omitted from the table. These two implementations provide very different semantics: LinkedList provides FIFO semantics, while PriorityQueue orders its elements according to their values.</p><p>Each of the general-purpose implementations provides all optional operations contained in its interface. All permit null elements, keys, and values. None are synchronized (thread-safe). All have <em>fail-fast iterators</em>, which detect illegal concurrent modification during iteration and fail quickly and cleanly rather than risking arbitrary, nondeterministic behavior at an undetermined time in the future. All are Serializable and all support a public clone method.</p><p>The fact that these implementations are unsynchronized represents a break with the past: The legacy collections Vector and Hashtable are synchronized. The present approach was taken because collections are frequently used when the synchronization is of no benefit. Such uses include single-threaded use, read-only use, and use as part of a larger data object that does its own synchronization. In general, it is good API design practice not to make users pay for a feature they don&#x27;t use. Furthermore, unnecessary synchronization can result in deadlock under certain circumstances.</p><p>If you need thread-safe collections, the synchronization wrappers, described in the <a href="https://docs.oracle.com/javase/tutorial/collections/implementations/wrapper.html">Wrapper Implementations</a> section, allow <em>any</em> collection to be transformed into a synchronized collection. Thus, synchronization is optional for general-purpose implementations, whereas it is mandatory for legacy implementations. Moreover, the java.util.concurrent package provides concurrent implementations of the BlockingQueue interface, which extends Queue, and of the ConcurrentMap interface, which extends Map. These implementations offer much higher concurrency than mere synchronized implementations.</p><p>As a rule, you should be thinking about the interfaces, <em>not</em> the implementations. That is why there are no programming examples in this section. For the most part, the choice of implementation affects only performance. The preferred style, as mentioned in the <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html">Interfaces</a> section, is to choose an implementation when a Collection is created and to immediately assign the new collection to a variable of the corresponding interface type (or to pass the collection to a method expecting an argument of the interface type). In this way, the program does not become dependent on any added methods in a given implementation, leaving the programmer free to change implementations anytime that it is warranted by performance concerns or behavioral details.</p><p>The sections that follow briefly discuss the implementations. The performance of the implementations is described using words such as <em>constant-time</em>, <em>log</em>, <em>linear</em>, <em>n log(n)</em>, and <em>quadratic</em> to refer to the asymptotic upper-bound on the time complexity of performing the operation. All this is quite a mouthful, and it doesn&#x27;t matter much if you don&#x27;t know what it means. If you&#x27;re interested in knowing more, refer to any good algorithms textbook. One thing to keep in mind is that this sort of performance metric has its limitations. Sometimes, the nominally slower implementation may be faster. When in doubt, measure the performance!</p><h3>13.5.1 Set Implementations</h3><p>The Set implementations are grouped into general-purpose and special-purpose implementations.</p><h3>13.5.2 General-Purpose Set Implementations</h3><p>There are three general-purpose <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html">Set</a> implementations --- <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html">HashSet</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html">TreeSet</a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashSet.html">LinkedHashSet</a>. Which of these three to use is generally straightforward. HashSet is much faster than TreeSet (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the SortedSet interface, or if value-ordered iteration is required, use TreeSet; otherwise, use HashSet. It&#x27;s a fair bet that you&#x27;ll end up using HashSet most of the time.</p><p>LinkedHashSet is in some sense intermediate between HashSet and TreeSet. Implemented as a hash table with a linked list running through it, it provides <em>insertion-ordered</em> iteration (least recently inserted to most recently) and runs nearly as fast as HashSet. The LinkedHashSet implementation spares its clients from the unspecified, generally chaotic ordering provided by HashSet without incurring the increased cost associated with TreeSet.</p><p>One thing worth keeping in mind about HashSet is that iteration is linear in the sum of the number of entries and the number of buckets (the <em>capacity</em>). Thus, choosing an initial capacity that&#x27;s too high can waste both space and time. On the other hand, choosing an initial capacity that&#x27;s too low wastes time by copying the data structure each time it&#x27;s forced to increase its capacity. If you don&#x27;t specify an initial capacity, the default is 16. In the past, there was some advantage to choosing a prime number as the initial capacity. This is no longer true. Internally, the capacity is always rounded up to a power of two. The initial capacity is specified by using the int constructor. The following line of code allocates a HashSet whose initial capacity is 64.</p><ol><li>Set &lt; String &gt; s = <strong>new</strong> HashSet &lt; String &gt; (64);  </li></ol><p>The HashSet class has one other tuning parameter called the <em>load factor</em>. If you care a lot about the space consumption of your HashSet, read the HashSet documentation for more information. Otherwise, just accept the default; it&#x27;s almost always the right thing to do.</p><p>If you accept the default load factor but want to specify an initial capacity, pick a number that&#x27;s about twice the size to which you expect the set to grow. If your guess is way off, you may waste a bit of space, time, or both, but it&#x27;s unlikely to be a big problem.</p><p>LinkedHashSet has the same tuning parameters as HashSet, but iteration time is not affected by capacity. TreeSet has no tuning parameters.</p><h4>13.5.2.1 Special-Purpose Set Implementations</h4><p>There are two special-purpose Set implementations --- <a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html">EnumSet</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CopyOnWriteArraySet.html">CopyOnWriteArraySet</a>.</p><p>EnumSet is a high-performance Set implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single long. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The EnumSet class provides a static factory that makes it easy.</p><ol><li><strong>for</strong> (Day d: EnumSet.range(Day.MONDAY, Day.FRIDAY)) System.out.println(d);  </li></ol><p>Enum sets also provide a rich, typesafe replacement for traditional bit flags.</p><ol><li>EnumSet.of(Style.BOLD, Style.ITALIC)  </li></ol><p>CopyOnWriteArraySet is a Set implementation backed up by a copy-on-write array. All mutative operations, such as add, set, and remove, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most Set implementations, the add, remove, and containsmethods require time proportional to the size of the set. This implementation is <em>only</em> appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.</p><h3>13.5.3 List Implementations</h3><p>List implementations are grouped into general-purpose and special-purpose implementations.</p><h4>13.5.3.1 General-Purpose List Implementations</h4><p>There are two general-purpose <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">List</a> implementations --- <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html">LinkedList</a>. Most of the time, you&#x27;ll probably use ArrayList, which offers constant-time positional access and is just plain fast. It does not have to allocate a node object for each element in the List, and it can take advantage of System.arraycopy when it has to move multiple elements at the same time. Think of ArrayList as Vector without the synchronization overhead.</p><p>If you frequently add elements to the beginning of the List or iterate over the List to delete elements from its interior, you should consider using LinkedList. These operations require constant-time in a LinkedList and linear-time in an ArrayList. But you pay a big price in performance. Positional access requires linear-time in a LinkedList and constant-time in an ArrayList. Furthermore, the constant factor for LinkedList is much worse. If you think you want to use a LinkedList, measure the performance of your application with both LinkedListand ArrayList before making your choice; ArrayList is usually faster.</p><p>ArrayList has one tuning parameter --- the <em>initial capacity</em>, which refers to the number of elements the ArrayList can hold before it has to grow. LinkedList has no tuning parameters and seven optional operations, one of which is clone. The other six are addFirst, getFirst, removeFirst, addLast, getLast, and removeLast. LinkedList also implements the Queueinterface.</p><h4>13.5.3.2 Special-Purpose List Implementations</h4><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CopyOnWriteArrayList.html">CopyOnWriteArrayList</a> is a List implementation backed up by a copy-on-write array. This implementation is similar in nature to CopyOnWriteArraySet. No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw ConcurrentModificationException. This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming.</p><p>If you need synchronization, a Vector will be slightly faster than an ArrayList synchronized with Collections.synchronizedList. But Vector has loads of legacy operations, so be careful to always manipulate the Vector with the List interface or else you won&#x27;t be able to replace the implementation at a later time.</p><p>If your List is fixed in size --- that is, you&#x27;ll never use remove, add, or any of the bulk operations other than containsAll --- you have a third option that&#x27;s definitely worth considering. See Arrays.asList in the <a href="https://docs.oracle.com/javase/tutorial/collections/implementations/convenience.html">Convenience Implementations</a> section for more information.</p><h3>13.5.4 Map Implementations</h3><p>Map implementations are grouped into general-purpose, special-purpose, and concurrent implementations.</p><h4>13.5.4.1 General-Purpose Map Implementations</h4><p>The three general-purpose <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">Map</a> implementations are <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html">TreeMap</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html">LinkedHashMap</a>. If you need SortedMap operations or key-ordered Collection-view iteration, use TreeMap; if you want maximum speed and don&#x27;t care about iteration order, use HashMap; if you want near-HashMap performance and insertion-order iteration, use LinkedHashMap. In this respect, the situation for Map is analogous to Set. Likewise, everything else in the <a href="https://docs.oracle.com/javase/tutorial/collections/implementations/set.html">Set Implementations</a> section also applies to Map implementations.</p><p>LinkedHashMap provides two capabilities that are not available with LinkedHashSet. When you create a LinkedHashMap, you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, LinkedHashMap provides the removeEldestEntry method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.</p><p>For example, this override will allow the map to grow up to as many as 100 entries and then it will delete the eldest entry each time a new entry is added, maintaining a steady state of 100 entries.</p><ol><li><strong>private</strong> <strong>static</strong> <strong>final</strong> <strong>int</strong> MAX_ENTRIES = 100;  </li><li><strong>protected</strong> <strong>boolean</strong> removeEldestEntry(Map.Entry eldest) {  </li><li>    <strong>return</strong> size() &gt; MAX_ENTRIES;  </li><li>}  </li></ol><h4>13.5.4.2 Special-Purpose Map Implementations</h4><p>There are three special-purpose Map implementations --- <a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumMap.html">EnumMap</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/WeakHashMap.html">WeakHashMap</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/IdentityHashMap.html">IdentityHashMap</a>. EnumMap, which is internally implemented as an array, is a high-performance Mapimplementation for use with enum keys. This implementation combines the richness and safety of the Map interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an EnumMap in preference to an array.</p><p>WeakHashMap is an implementation of the Map interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the WeakHashMap. This class provides the easiest way to harness the power of weak references. It is useful for implementing &quot;registry-like&quot; data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.</p><p>IdentityHashMap is an identity-based Map implementation based on a hash table. This class is useful for topology-preserving object graph transformations, such as serialization or deep-copying. To perform such transformations, you need to maintain an identity-based &quot;node table&quot; that keeps track of which objects have already been seen. Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems. Finally, identity-based maps are useful in thwarting &quot;spoof attacks&quot; that are a result of intentionally perverse equals methods because IdentityHashMap never invokes the equals method on its keys. An added benefit of this implementation is that it is fast.</p><h4>13.5.4.3 Concurrent Map Implementations</h4><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html">java.util.concurrent</a> package contains the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html">ConcurrentMap</a> interface, which extends Map with atomic putIfAbsent, remove, and replace methods, and the<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">ConcurrentHashMap</a> implementation of that interface.</p><p>ConcurrentHashMap is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for Hashtable: in addition to implementing ConcurrentMap, it supports all the legacy methods peculiar to Hashtable. Again, if you don&#x27;t need the legacy operations, be careful to manipulate it with the ConcurrentMap interface.</p><h3>13.5.5 Queue Implementations</h3><p>The Queue implementations are grouped into general-purpose and concurrent implementations.</p><h4>13.5.5.1 General-Purpose Queue Implementations</h4><p>As mentioned in the previous section, LinkedList implements the Queue interface, providing first in, first out (FIFO) queue operations for add, poll, and so on.</p><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html">PriorityQueue</a> class is a priority queue based on the <em>heap</em> data structure. This queue orders elements according to the order specified at construction time, which can be the elements&#x27; natural ordering or the ordering imposed by an explicit Comparator.</p><p>The queue retrieval operations --- poll, remove, peek, and element --- access the element at the head of the queue. The <em>head of the queue</em> is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily.</p><p>PriorityQueue and its iterator implement all of the optional methods of the Collection and Iterator interfaces. The iterator provided in method iterator is not guaranteed to traverse the elements of the PriorityQueue in any particular order. For ordered traversal, consider using Arrays.sort(pq.toArray()).</p><h4>13.5.5.2 Concurrent Queue Implementations</h4><p>The java.util.concurrent package contains a set of synchronized Queue interfaces and classes. <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html">BlockingQueue</a> extends Queue with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingQueue.html">LinkedBlockingQueue</a> --- an optionally bounded FIFO blocking queue backed by linked nodes</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ArrayBlockingQueue.html">ArrayBlockingQueue</a> --- a bounded FIFO blocking queue backed by an array</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/PriorityBlockingQueue.html">PriorityBlockingQueue</a> --- an unbounded blocking priority queue backed by a heap</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/DelayQueue.html">DelayQueue</a> --- a time-based scheduling queue backed by a heap</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/SynchronousQueue.html">SynchronousQueue</a> --- a simple rendezvous mechanism that uses the BlockingQueue interface</li></ul><p>In JDK 7, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TransferQueue.html">TransferQueue</a> is a specialized BlockingQueue in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. TransferQueue has a single implementation:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedTransferQueue.html">LinkedTransferQueue</a> --- an unbounded TransferQueue based on linked nodes</li></ul><h3>13.5.6 Deque Implementations</h3><p>The Deque interface, pronounced as <em>&quot;deck&quot;</em>, represents a double-ended queue. The Deque interface can be implemented as various types of Collections. The Deque interface implementations are grouped into general-purpose and concurrent implementations.</p><h4>13.5.6.1 General-Purpose Deque Implementations</h4><p>The general-purpose implementations include LinkedList and ArrayDeque classes. The Deque interface supports insertion, removal and retrieval of elements at both ends. The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html">ArrayDeque</a>class is the resizable array implementation of the Deque interface, whereas the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html">LinkedList</a> class is the list implementation.</p><p>The basic insertion, removal and retieval operations in the Deque interface addFirst, addLast, removeFirst, removeLast, getFirst and getLast. The method addFirst adds an element at the head whereas addLast adds an element at the tail of the Deque instance.</p><p>The LinkedList implementation is more flexible than the ArrayDeque implementation. LinkedList implements all optional list operations. null elements are allowed in the LinkedListimplementation but not in the ArrayDeque implementation.</p><p>In terms of efficiency, ArrayDeque is more efficient than the LinkedList for add and remove operation at both ends. The best operation in a LinkedList implementation is removing the current element during the iteration. LinkedList implementations are not ideal structures to iterate.</p><p>The LinkedList implementation consumes more memory than the ArrayDeque implementation. For the ArrayDeque instance traversal use any of the following:</p><h5>13.5.6.1.1 foreach</h5><p>The foreach is fast and can be used for all kinds of lists.</p><ol><li>ArrayDeque &lt; String &gt; aDeque = <strong>new</strong> ArrayDeque &lt; String &gt; ();<!-- -->.<!-- -->..<strong>for</strong>(String str: aDeque) {  </li><li>    System.out.println(str);  </li><li>}  </li></ol><h5>13.5.6.1.2 Iterator</h5><p>The Iterator can be used for the forward traversal on all kinds of lists for all kinds of data.</p><ol><li>ArrayDeque &lt; String &gt; aDeque = <strong>new</strong> ArrayDeque &lt; String &gt; ();<!-- -->.<!-- -->..<strong>for</strong>(Iterator &lt; String &gt; iter = aDeque.iterator(); iter.hasNext();) {  </li><li>    System.out.println(iter.next());  </li><li>}  </li></ol><p>The ArrayDeque class is used in this tutorial to implement the Deque interface. The complete code of the example used in this tutorial is available in <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/ArrayDequeSample.java">ArrayDequeSample</a>. Both theLinkedList and ArrayDeque classes do not support concurrent access by multiple threads.</p><h4>13.5.6.2 Concurrent Deque Implementations</h4><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingDeque.html">LinkedBlockingDeque</a> class is the concurrent implementation of the Deque interface. If the deque is empty then methods such as takeFirst and takeLast wait until the element becomes available, and then retrieves and removes the same element.</p><h3>13.5.7 Wrapper Implementations</h3><p>Wrapper implementations delegate all their real work to a specified collection but add extra functionality on top of what this collection offers. For design pattern fans, this is an example of the <em>decorator</em> pattern. Although it may seem a bit exotic, it&#x27;s really pretty straightforward.</p><p>These implementations are anonymous; rather than providing a public class, the library provides a static factory method. All these implementations are found in the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html">Collections</a> class, which consists solely of static methods.</p><h4>13.5.7.1 Synchronization Wrappers</h4><p>The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces --- <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html">Set</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">List</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">Map</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html">SortedSet</a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html">SortedMap</a> --- has one static factory method.</p><ol><li><strong>public</strong> <strong>static</strong> &lt; T &gt; Collection &lt; T &gt; synchronizedCollection(Collection &lt; T &gt; c);  </li><li><strong>public</strong> <strong>static</strong> &lt; T &gt; Set &lt; T &gt; synchronizedSet(Set &lt; T &gt; s);  </li><li><strong>public</strong> <strong>static</strong> &lt; T &gt; List &lt; T &gt; synchronizedList(List &lt; T &gt; list);  </li><li><strong>public</strong> <strong>static</strong> &lt; K, V &gt; Map &lt; K, V &gt; synchronizedMap(Map &lt; K, V &gt; m);  </li><li><strong>public</strong> <strong>static</strong> &lt; T &gt; SortedSet &lt; T &gt; synchronizedSortedSet(SortedSet &lt; T &gt; s);  </li><li><strong>public</strong> <strong>static</strong> &lt; K, V &gt; SortedMap &lt; K, V &gt; synchronizedSortedMap(SortedMap &lt; K, V &gt; m);  </li></ol><p>Each of these methods returns a synchronized (thread-safe) Collection backed up by the specified collection. To guarantee serial access, <em>all</em> access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick.</p><ol><li>List &lt; Type &gt; list = Collections.synchronizedList(<strong>new</strong> ArrayList &lt; Type &gt; ());  </li></ol><p>A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html">Vector</a>.</p><p>In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection.</p><ol><li>Collection &lt; Type &gt; c = Collections.synchronizedCollection(myCollection);  </li><li><strong>synchronized</strong>(c) {  </li><li>    <strong>for</strong> (Type e: c) foo(e);  </li><li>}  </li></ol><p>If an explicit iterator is used, the iterator method must be called from within the synchronized block. Failure to follow this advice may result in nondeterministic behavior. The idiom for iterating over a Collection view of a synchronized Map is similar. It is imperative that the user synchronize on the synchronized Map when iterating over any of its Collection views rather than synchronizing on the Collection view itself, as shown in the following example.</p><ol><li>Map &lt; KeyType, ValType &gt; m = Collections.synchronizedMap(<strong>new</strong> HashMap &lt; KeyType, ValType &gt; ());<!-- -->.<!-- -->..Set &lt; KeyType &gt; s = m.keySet();<!-- -->.<!-- -->.. // Synchronizing on m, not s!  </li><li><strong>synchronized</strong>(m) {  </li><li>    <strong>while</strong> (KeyType k: s) foo(k);  </li><li>}  </li></ol><p>One minor downside of using wrapper implementations is that you do not have the ability to execute any <em>noninterface</em> operations of a wrapped implementation. So, for instance, in the preceding List example, you cannot call ArrayList&#x27;s <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ensureCapacity-int-">ensureCapacity</a> operation on the wrapped ArrayList.</p><h4>13.5.7.2 Unmodifiable Wrappers</h4><p>Unlike synchronization wrappers, which add functionality to the wrapped collection, the unmodifiable wrappers take functionality away. In particular, they take away the ability to modify the collection by intercepting all the operations that would modify the collection and throwing an UnsupportedOperationException. Unmodifiable wrappers have two main uses, as follows:</p><ul><li>To make a collection immutable once it has been built. In this case, it&#x27;s good practice not to maintain a reference to the backing collection. This absolutely guarantees immutability.</li><li>To allow certain clients read-only access to your data structures. You keep a reference to the backing collection but hand out a reference to the wrapper. In this way, clients can look but not modify, while you maintain full access.</li></ul><p>Like synchronization wrappers, each of the six core Collection interfaces has one static factory method.</p><ol><li><strong>public</strong> <strong>static</strong> &lt; T &gt; Collection &lt; T &gt; unmodifiableCollection(Collection &lt;? <strong>extends</strong> T &gt; c);  </li><li><strong>public</strong> <strong>static</strong> &lt; T &gt; Set &lt; T &gt; unmodifiableSet(Set &lt;? <strong>extends</strong> T &gt; s);  </li><li><strong>public</strong> <strong>static</strong> &lt; T &gt; List &lt; T &gt; unmodifiableList(List &lt;? <strong>extends</strong> T &gt; list);  </li><li><strong>public</strong> <strong>static</strong> &lt; K, V &gt; Map &lt; K, V &gt; unmodifiableMap(Map &lt;? <strong>extends</strong> K, ? <strong>extends</strong> V &gt; m);  </li><li><strong>public</strong> <strong>static</strong> &lt; T &gt; SortedSet &lt; T &gt; unmodifiableSortedSet(SortedSet &lt;? <strong>extends</strong> T &gt; s);  </li><li><strong>public</strong> <strong>static</strong> &lt; K, V &gt; SortedMap &lt; K, V &gt; unmodifiableSortedMap(SortedMap &lt; K, ? <strong>extends</strong> V &gt; m);  </li></ol><h4>13.5.7.3 Checked Interface Wrappers</h4><p>The Collections.checked <em>interface</em> wrappers are provided for use with generic collections. These implementations return a <em>dynamically</em> type-safe view of the specified collection, which throws a ClassCastException if a client attempts to add an element of the wrong type. The generics mechanism in the language provides compile-time (static) type-checking, but it is possible to defeat this mechanism. Dynamically type-safe views eliminate this possibility entirely.</p><h3>13.5.8 Convenience Implementations</h3><p>This section describes several mini-implementations that can be more convenient and more efficient than general-purpose implementations when you don&#x27;t need their full power. All the implementations in this section are made available via static factory methods rather than public classes.</p><h4>13.5.8.1 List View of an Array</h4><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-">Arrays.asList</a> method returns a List view of its array argument. Changes to the List write through to the array and vice versa. The size of the collection is that of the array and cannot be changed. If the add or the remove method is called on the List, an UnsupportedOperationException will result.</p><p>The normal use of this implementation is as a bridge between array-based and collection-based APIs. It allows you to pass an array to a method expecting a Collection or a List. However, this implementation also has another use. If you need a fixed-size List, it&#x27;s more efficient than any general-purpose List implementation. This is the idiom.</p><ol><li>List &lt; String &gt; list = Arrays.asList(<strong>new</strong> String<!-- -->[size]<!-- -->);  </li></ol><p>Note that a reference to the backing array is not retained.</p><h4>13.5.8.2 Immutable Multiple-Copy List</h4><p>Occasionally you&#x27;ll need an immutable List consisting of multiple copies of the same element. The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#nCopies-int-T-">Collections.nCopies</a> method returns such a list. This implementation has two main uses. The first is to initialize a newly created List; for example, suppose you want an ArrayList initially consisting of 1,000 null elements. The following incantation does the trick.</p><ol><li>List &lt; Type &gt; list = <strong>new</strong> ArrayList &lt; Type &gt; (Collections.nCopies(1000, (Type) <strong>null</strong>);  </li></ol><p>Of course, the initial value of each element need not be null. The second main use is to grow an existing List. For example, suppose you want to add 69 copies of the string &quot;fruit bat&quot; to the end of a <code>List&lt;String&gt;</code>. It&#x27;s not clear why you&#x27;d want to do such a thing, but let&#x27;s just suppose you did. The following is how you&#x27;d do it.</p><ol><li>lovablePets.addAll(Collections.nCopies(69, &quot;fruit bat&quot;));  </li></ol><p>By using the form of addAll that takes both an index and a Collection, you can add the new elements to the middle of a List instead of to the end of it.</p><h4>13.5.8.3 Immutable Singleton Set</h4><p>Sometimes you&#x27;ll need an immutable <em>singleton</em> Set, which consists of a single, specified element. The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singleton-T-">Collections.singleton</a> method returns such a Set. One use of this implementation is to remove all occurrences of a specified element from a Collection.</p><ol><li>c.removeAll(Collections.singleton(e));  </li></ol><p>A related idiom removes all elements that map to a specified value from a Map. For example, suppose you have a Map --- job --- that maps people to their line of work and suppose you want to eliminate all the lawyers. The following one-liner will do the deed.</p><ol><li>job.values().removeAll(Collections.singleton(LAWYER));  </li></ol><p>One more use of this implementation is to provide a single input value to a method that is written to accept a collection of values.</p><h4>13.5.8.4 Empty Set, List, and Map Constants</h4><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html">Collections</a> class provides methods to return the empty Set, List, and Map --- <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#emptySet--">emptySet</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#emptyList--">emptyList</a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#emptyMap--">emptyMap</a>. The main use of these constants is as input to methods that take a Collection of values when you don&#x27;t want to provide any values at all, as in this example.</p><ol><li>tourist.declarePurchases(Collections.emptySet());  </li></ol><h3>13.5.9 Summary of Implementations</h3><p>Implementations are the data objects used to store collections, which implement the interfaces described in the <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html">Interfaces lesson</a>.</p><p>The Java Collections Framework provides several general-purpose implementations of the core interfaces:</p><ul><li>For the Set interface, HashSet is the most commonly used implementation.</li><li>For the List interface, ArrayList is the most commonly used implementation.</li><li>For the Map interface, HashMap is the most commonly used implementation.</li><li>For the Queue interface, LinkedList is the most commonly used implementation.</li><li>For the Deque interface, ArrayDeque is the most commonly used implementation.</li></ul><p>Each of the general-purpose implementations provides all optional operations contained in its interface.</p><p>The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior.</p><p>The java.util.concurrent package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.</p><p>The Collections class (as opposed to the Collection interface), provides static methods that operate on or return collections, which are known as Wrapper implementations.</p><p>Finally, there are several Convenience implementations, which can be more efficient than general-purpose implementations when you don&#x27;t need their full power. The Convenience implementations are made available through static factory methods.</p><h2>13.6 Algorithms</h2><p>The <em>polymorphic algorithms</em> described here are pieces of reusable functionality provided by the Java platform. All of them come from the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html">Collections</a> class, and all take the form of static methods whose first argument is the collection on which the operation is to be performed. The great majority of the algorithms provided by the Java platform operate on <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">List</a> instances, but a few of them operate on arbitrary <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection</a> instances. This section briefly describes the following algorithms:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/collections/algorithms/index.html#sorting">Sorting</a></li><li><a href="https://docs.oracle.com/javase/tutorial/collections/algorithms/index.html#shuffling">Shuffling</a></li><li><a href="https://docs.oracle.com/javase/tutorial/collections/algorithms/index.html#rdm">Routine Data Manipulation</a></li><li><a href="https://docs.oracle.com/javase/tutorial/collections/algorithms/index.html#searching">Searching</a></li><li><a href="https://docs.oracle.com/javase/tutorial/collections/algorithms/index.html#composition">Composition</a></li><li><a href="https://docs.oracle.com/javase/tutorial/collections/algorithms/index.html#fev">Finding Extreme Values</a></li></ul><h3>13.6.1 Sorting</h3><p>The sort algorithm reorders a List so that its elements are in ascending order according to an ordering relationship. Two forms of the operation are provided. The simple form takes a List and sorts it according to its elements&#x27; <em>natural ordering</em>. If you&#x27;re unfamiliar with the concept of natural ordering, read the <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/order.html">Object Ordering</a> section.</p><p>The sort operation uses a slightly optimized <em>merge sort</em> algorithm that is fast and stable:</p><ul><li><strong>Fast</strong>: It is guaranteed to run in n log(n) time and runs substantially faster on nearly sorted lists. Empirical tests showed it to be as fast as a highly optimized quicksort. A quicksort is generally considered to be faster than a merge sort but isn&#x27;t stable and doesn&#x27;t guarantee n log(n) performance.</li><li><strong>Stable</strong>: It doesn&#x27;t reorder equal elements. This is important if you sort the same list repeatedly on different attributes. If a user of a mail program sorts the inbox by mailing date and then sorts it by sender, the user naturally expects that the now-contiguous list of messages from a given sender will (still) be sorted by mailing date. This is guaranteed only if the second sort was stable.</li></ul><p>The following <a href="https://docs.oracle.com/javase/tutorial/collections/algorithms/examples/Sort.java">trivial program</a> prints out its arguments in lexicographic (alphabetical) order.</p><pre><code class="language-java">1.  **import** java.util.*;  
2.  **public** **class** Sort {  
3.      **public** **static** **void** main(String[] args) {  
4.          List &lt; String &gt; list = Arrays.asList(args);  
5.          Collections.sort(list);  
6.          System.out.println(list);  
7.      }  
8.  }  
</code></pre><ol start="9"><li>Let &#x27;s run the program. </li><li>% java Sort i walk the line </li><li>The following output is produced.<!-- -->[i, line, the, walk]<!-- -->  </li></ol><p>The program was included only to show you that algorithms really are as easy to use as they appear to be.</p><p>The second form of sort takes a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html">Comparator</a> in addition to a List and sorts the elements with the Comparator. Suppose you want to print out the anagram groups from our earlier example in reverse order of size --- largest anagram group first. The example that follows shows you how to achieve this with the help of the second form of the sort method.</p><p>Recall that the anagram groups are stored as values in a Map, in the form of List instances. The revised printing code iterates through the Map&#x27;s values view, putting every List that passes the minimum-size test into a Listof Lists. Then the code sorts this List, using a Comparator that expects List instances, and implements reverse size-ordering. Finally, the code iterates through the sorted List, printing its elements (the anagram groups). The following code replaces the printing code at the end of the main method in the Anagrams example.</p><pre><code class="language-java">1.  // Make a List of all anagram groups above size threshold.  
2.  List &lt; List &lt; String &gt;&gt; winners = **new** ArrayList &lt; List &lt; String &gt;&gt; ();  
3.  **for** (List &lt; String &gt; l: m.values())  
4.      **if** (l.size() &gt;= minGroupSize) winners.add(l); // Sort anagram groups according to size  
5.  Collections.sort(winners, **new** Comparator &lt; List &lt; String &gt;&gt; () {  
6.      **public** **int** compare(List &lt; String &gt; o1, List &lt; String &gt; o2) {  
7.          **return** o2.size() - o1.size();  
8.      }  
9.  }); // Print anagram groups.  
10. **for** (List &lt; String &gt; l: winners) System.out.println(l.size() + &quot;: &quot; + l);  
</code></pre><p>Running <a href="https://docs.oracle.com/javase/tutorial/collections/algorithms/examples/Anagrams2.java">the program</a> on the <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/examples/dictionary.txt">same dictionary</a> as in <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html">The Map Interface</a> section, with the same minimum anagram group size (eight), produces the following output.</p><p>[]{#bookmark=id.2005hpz}</p><ol><li>12: <!-- -->[apers, apres, asper, pares, parse, pears, prase, presa, rapes, reaps, spare, spear]<!-- --> </li><li>11: <!-- -->[alerts, alters, artels, estral, laster, ratels, salter, slater, staler, stelar, talers]<!-- --> </li><li>10: <!-- -->[least, setal, slate, stale, steal, stela, taels, tales, teals, tesla]<!-- --> </li><li>9: <!-- -->[estrin, inerts, insert, inters, niters, nitres, sinter, triens, trines]<!-- --> </li><li>9: <!-- -->[capers, crapes, escarp, pacers, parsec, recaps, scrape, secpar, spacer]<!-- --> </li><li>9: <!-- -->[palest, palets, pastel, petals, plates, pleats, septal, staple, tepals]<!-- --> </li><li>9: <!-- -->[anestri, antsier, nastier, ratines, retains, retinas, retsina, stainer, stearin]<!-- --> </li><li>8: <!-- -->[lapse, leaps, pales, peals, pleas, salep, sepal, spale]<!-- --> </li><li>8: <!-- -->[aspers, parses, passer, prases, repass, spares, sparse, spears]<!-- --> </li><li>8: <!-- -->[enters, nester, renest, rentes, resent, tenser, ternes, ��treens]<!-- --> </li><li>8: <!-- -->[arles, earls, lares, laser, lears, rales, reals, seral]<!-- --> </li><li>8: <!-- -->[earings, erasing, gainers, reagins, regains, reginas, searing, seringa]<!-- --> </li><li>8: <!-- -->[peris, piers, pries, prise, ripes, speir, spier, spire]<!-- --> </li><li>8: <!-- -->[ates, east, eats, etas, sate, seat, seta, teas]<!-- --> </li><li>8: <!-- -->[carets, cartes, caster, caters, crates, reacts, recast, ��traces]<!-- -->  </li></ol><h3>13.6.2 Shuffling</h3><p>The shuffle algorithm does the opposite of what sort does, destroying any trace of order that may have been present in a List. That is, this algorithm reorders the List based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance. For example, it could be used to shuffle a List of Card objects representing a deck. Also, it&#x27;s useful for generating test cases.</p><p>This operation has two forms: one takes a List and uses a default source of randomness, and the other requires the caller to provide a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Random.html">Random</a> object to use as a source of randomness. The code for this algorithm is used as an example in the <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html#shuffle">List section</a>.[]{#bookmark=id.2z53all}</p><h3>13.6.3 Routine Data Manipulation</h3><p>The Collections class provides five algorithms for doing routine data manipulation on List objects, all of which are pretty straightforward:</p><ul><li>reverse --- reverses the order of the elements in a List.</li><li>fill --- overwrites every element in a List with the specified value. This operation is useful for reinitializing a List.</li><li>copy --- takes two arguments, a destination List and a source List, and copies the elements of the source into the destination, overwriting its contents. The destination List must be at least as long as the source. If it is longer, the remaining elements in the destination List are unaffected.</li><li>swap --- swaps the elements at the specified positions in a List.</li><li>addAll --- adds all the specified elements to a Collection. The elements to be added may be specified individually or as an array.</li></ul><h3>13.6.4 Searching</h3><p>The binarySearch algorithm searches for a specified element in a sorted List. This algorithm has two forms. The first takes a List and an element to search for (the &quot;search key&quot;). This form assumes that the List is sorted in ascending order according to the natural ordering of its elements. The second form takes a Comparator in addition to the List and the search key, and assumes that the List is sorted into ascending order according to the specified Comparator. The sort algorithm can be used to sort the List prior to calling binarySearch.</p><p>The return value is the same for both forms. If the List contains the search key, its index is returned. If not, the return value is (-(insertion point) - 1), where the insertion point is the point at which the value would be inserted into the List, or the index of the first element greater than the value or list.size() if all elements in the List are less than the specified value. This admittedly ugly formula guarantees that the return value will be &gt;= 0 if and only if the search key is found. It&#x27;s basically a hack to combine a boolean (found) and an integer (index) into a single int return value.</p><p>The following idiom, usable with both forms of the binarySearch operation, looks for the specified search key and inserts it at the appropriate position if it&#x27;s not already present.</p><p>[]{#bookmark=id.2dfbdp0}</p><ol><li><strong>int</strong> pos = Collections.binarySearch(list, key);  </li><li><strong>if</strong> (pos &lt; 0) l.add(-pos - 1, key);  </li></ol><h3>13.6.5 Composition</h3><p>The frequency and disjoint algorithms test some aspect of the composition of one or more Collections:</p><ul><li>frequency --- counts the number of times the specified element occurs in the specified collection</li><li>disjoint --- determines whether two Collections are disjoint; that is, whether they contain no elements in common</li></ul><h3>13.6.6 Finding Extreme Values</h3><p>The min and the max algorithms return, respectively, the minimum and maximum element contained in a specified Collection. Both of these operations come in two forms. The simple form takes only a Collection and returns the minimum (or maximum) element according to the elements&#x27; natural ordering. The second form takes a Comparator in addition to the Collection and returns the minimum (or maximum) element according to the specified Comparator.</p><h3>13.6.7 Custom Collection Implementations</h3><p>Many programmers will never need to implement their own Collections classes. You can go pretty far using the implementations described in the preceding sections of this chapter. However, someday you might want to write your own implementation. It is fairly easy to do this with the aid of the abstract implementations provided by the Java platform. Before we discuss <em>how</em> to write an implementation, let&#x27;s discuss why you might want to write one.</p><h4>13.6.7.1 Reasons to Write an Implementation</h4><p>The following list illustrates the sort of custom Collections you might want to implement. It is not intended to be exhaustive:</p><ul><li><strong>Persistent</strong>: All of the built-in Collection implementations reside in main memory and vanish when the program exits. If you want a collection that will still be present the next time the program starts, you can implement it by building a veneer over an external database. Such a collection might be concurrently accessible by multiple programs.</li><li><strong>Application-specific</strong>: This is a very broad category. One example is an unmodifiable Map containing real-time telemetry data. The keys could represent locations, and the values could be read from sensors at these locations in response to the get operation.</li><li><strong>High-performance, special-purpose</strong>: Many data structures take advantage of restricted usage to offer better performance than is possible with general-purpose implementations. For instance, consider a Listcontaining long runs of identical element values. Such lists, which occur frequently in text processing, can be <em>run-length encoded</em> --- runs can be represented as a single object containing the repeated element and the number of consecutive repetitions. This example is interesting because it trades off two aspects of performance: It requires less space but more time than an ArrayList.</li><li><strong>High-performance, general-purpose</strong>: The Java Collections Framework&#x27;s designers tried to provide the best general-purpose implementations for each interface, but many, many data structures could have been used, and new ones are invented every day. Maybe you can come up with something faster!</li><li><strong>Enhanced functionality</strong>: Suppose you need an efficient bag implementation (also known as a <em>multiset</em>): a Collection that offers constant-time containment checks while allowing duplicate elements. It&#x27;s reasonably straightforward to implement such a collection atop a HashMap.</li><li><strong>Convenience</strong>: You may want additional implementations that offer conveniences beyond those offered by the Java platform. For instance, you may frequently need List instances representing a contiguous range of Integers.</li><li><strong>Adapter</strong>: Suppose you are using a legacy API that has its own ad hoc collections&#x27; API. You can write an adapter implementation that permits these collections to operate in the Java Collections Framework. An <em>adapter implementation</em> is a thin veneer that wraps objects of one type and makes them behave like objects of another type by translating operations on the latter type into operations on the former.</li></ul><h4>13.6.7.2 How to Write a Custom Implementation</h4><p>Writing a custom implementation is surprisingly easy. The Java Collections Framework provides abstract implementations designed expressly to facilitate custom implementations. We&#x27;ll start with the following example of an implementation of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-">Arrays.asList</a>.</p><pre><code class="language-java">1.  **public** **static** &lt; T &gt; List &lt; T &gt; asList(T[] a) {  
2.      **return** **new** MyArrayList &lt; T &gt; (a);  
3.  }  
4.  **private** **static** **class** MyArrayList &lt; T &gt; **extends** AbstractList &lt; T &gt; {  
5.      **private** **final** T[] a;  
6.      MyArrayList(T[] array) {  
7.          a = array;  
8.      }  
9.      **public** T get(**int** index) {  
10.         **return** a[index];  
11.     }  
12.     **public** T set(**int** index, T element) {  
13.         T oldValue = a[index];  
14.         a[index] = element;  
15.         **return** oldValue;  
16.     }  
17.     **public** **int** size() {  
18.         **return** a.length;  
19.     }  
20. }  
</code></pre><p>Believe it or not, this is very close to the implementation that is contained in java.util.Arrays. It&#x27;s that simple! You provide a constructor and the get, set, and size methods, and AbstractList does all the rest. You get the ListIterator, bulk operations, search operations, hash code computation, comparison, and string representation for free.</p><p>Suppose you want to make the implementation a bit faster. The API documentation for abstract implementations describes precisely how each method is implemented, so you&#x27;ll know which methods to override to get the performance you want. The preceding implementation&#x27;s performance is fine, but it can be improved a bit. In particular, the toArray method iterates over the List, copying one element at a time. Given the internal representation, it&#x27;s a lot faster and more sensible just to clone the array.</p><pre><code class="language-java">1.  **public** Object[] toArray() {  
2.      **return** (Object[]) a.clone();  
3.  }  
</code></pre><p>With the addition of this override and a few more like it, this implementation is exactly the one found in java.util.Arrays. In the interest of full disclosure, it&#x27;s a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it&#x27;s still not that difficult.</p><p>The following list summarizes the abstract implementations:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html">AbstractCollection</a> --- a Collection that is neither a Set nor a List. At a minimum, you must provide the iterator and the size methods.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractSet.html">AbstractSet</a> --- a Set; use is identical to AbstractCollection.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractList.html">AbstractList</a> --- a List backed up by a random-access data store, such as an array. At a minimum, you must provide the positional access methods (get and, optionally, set, remove, and add) and the sizemethod. The abstract class takes care of listIterator (and iterator).</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractSequentialList.html">AbstractSequentialList</a> --- a List backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the listIterator and size methods. The abstract class takes care of the positional access methods. (This is the opposite of AbstractList.)</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractQueue.html">AbstractQueue</a> --- at a minimum, you must provide the offer, peek, poll, and size methods and an iterator supporting remove.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractMap.html">AbstractMap</a> --- a Map. At a minimum you must provide the entrySet view. This is typically implemented with the AbstractSet class. If the Map is modifiable, you must also provide the put method.</li></ul><p>The process of writing a custom implementation follows:</p><p>Choose the appropriate abstract implementation class from the preceding list.</p><p>Provide implementations for all the abstract methods of the class. If your custom collection is to be modifiable, you will have to override one or more of the concrete methods as well. The API documentation for the abstract implementation class will tell you which methods to override.</p><p>Test and, if necessary, debug the implementation. You now have a working custom collection implementation.</p><p>If you are concerned about performance, read the API documentation of the abstract implementation class for all the methods whose implementations you&#x27;re inheriting. If any seem too slow, override them. If you override any methods, be sure to measure the performance of the method before and after the override. How much effort you put into tweaking performance should be a function of how much use the implementation will get and how critical to performance its use is. (Often this step is best omitted.)</p><h3>13.6.8 Interoperability</h3><p>In this section, you&#x27;ll learn about the following two aspects of interoperability:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/collections/interoperability/compatibility.html">Compatibility</a>: This subsection describes how collections can be made to work with older APIs that predate the addition of Collections to the Java platform.</li><li><a href="https://docs.oracle.com/javase/tutorial/collections/interoperability/api-design.html">API Design</a>: This subsection describes how to design new APIs so that they will interoperate seamlessly with one another.</li></ul><h4>13.6.8.1 Compatibility</h4><p>The Java Collections Framework was designed to ensure complete interoperability between the core <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html">collection interfaces</a> and the types that were used to represent collections in the early versions of the Java platform: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html">Vector</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Hashtable.html">Hashtable</a>, <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html">array</a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html">Enumeration</a>. In this section, you&#x27;ll learn how to transform old collections to the Java Collections Framework collections and vice versa.</p><h5>13.6.8.1.1 Upward Compatibility</h5><p>Suppose that you&#x27;re using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you&#x27;ll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy.</p><p>Suppose the old API returns an array of objects and the new API requires a Collection. The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a List. You use <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-">Arrays.asList</a> to pass an array to any method requiring a Collection or a List.</p><pre><code class="language-java">1.  Foo[] result = oldMethod(arg);  
2.  newMethod(Arrays.asList(result));  
</code></pre><p>If the old API returns a Vector or a Hashtable, you have no work to do at all because Vector was retrofitted to implement the List interface, and Hashtable was retrofitted to implement Map. Therefore, a Vector may be passed directly to any method calling for a Collection or a List.</p><pre><code class="language-java">1.  Vector result = oldMethod(arg);  
2.  newMethod(result);  
</code></pre><p>Similarly, a Hashtable may be passed directly to any method calling for a Map.</p><pre><code class="language-java">1.  Hashtable result = oldMethod(arg);  
2.  newMethod(result);  
</code></pre><p>Less frequently, an API may return an Enumeration that represents a collection of objects. The Collections.list method translates an Enumeration into a Collection.</p><pre><code class="language-java">1.  Enumeration e = oldMethod(arg);  
2.  newMethod(Collections.list(e));  
</code></pre><h5>13.6.8.1.2 Backward Compatibility</h5><p>Suppose you&#x27;re using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy.</p><p>Suppose the new API returns a Collection, and the old API requires an array of Object. As you&#x27;re probably aware, the Collection interface contains a toArray method designed expressly for this situation.</p><pre><code class="language-java">1.  Collection c = newMethod();  
2.  oldMethod(c.toArray());  
</code></pre><p>What if the old API requires an array of String (or another type) instead of an array of Object? You just use the other form of toArray --- the one that takes an array on input.</p><pre><code class="language-java">1.  Collection c = newMethod();  
2.  oldMethod((String[]) c.toArray(**new** String[0]));  
</code></pre><p>If the old API requires a Vector, the standard collection constructor comes in handy.</p><pre><code class="language-java">1.  Collection c = newMethod();  
2.  oldMethod(**new** Vector(c));  
</code></pre><p>The case where the old API requires a Hashtable is handled analogously.</p><pre><code class="language-java">1.  Map m = newMethod();  
2.  oldMethod(**new** Hashtable(m));  
</code></pre><p>Finally, what do you do if the old API requires an Enumeration? This case isn&#x27;t common, but it does happen from time to time, and the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-">Collections.enumeration</a> method was provided to handle it. This is a static factory method that takes a Collection and returns an Enumeration over the elements of the Collection.</p><pre><code class="language-java">1.  Collection c = newMethod();  
2.  oldMethod(Collections.enumeration(c));  
</code></pre><h4>13.6.8.2 API Design</h4><p>In this short but important section, you&#x27;ll learn a few simple guidelines that will allow your API to interoperate seamlessly with all other APIs that follow these guidelines. In essence, these rules define what it takes to be a good &quot;citizen&quot; in the world of collections.</p><h5>13.6.8.2.1 Parameters</h5><p>If your API contains a method that requires a collection on input, it is of paramount importance that you declare the relevant parameter type to be one of the collection <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html">interface</a> types. <strong>Never</strong> use an <a href="https://docs.oracle.com/javase/tutorial/collections/implementations/index.html">implementation</a> type because this defeats the purpose of an interface-based Collections Framework, which is to allow collections to be manipulated without regard to implementation details.</p><p>Further, you should always use the least-specific type that makes sense. For example, don&#x27;t require a <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html">List</a> or a <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html">Set</a> if a <a href="https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html">Collection</a> would do. It&#x27;s not that you should never require a List or a Set on input; it is correct to do so if a method depends on a property of one of these interfaces. For example, many of the algorithms provided by the Java platform require a List on input because they depend on the fact that lists are ordered. As a general rule, however, the best types to use on input are the most general: Collection and Map.</p><p><strong>Caution:</strong> Never define your own ad hoc collection class and require objects of this class on input. By doing this, you&#x27;d lose all the <a href="https://docs.oracle.com/javase/tutorial/collections/intro/index.html">benefits provided by the Java Collections Framework</a>.</p><h5>13.6.8.2.2 Return Values</h5><p>You can afford to be much more flexible with return values than with input parameters. It&#x27;s fine to return an object of any type that implements or extends one of the collection interfaces. This can be one of the interfaces or a special-purpose type that extends or implements one of these interfaces.</p><p>For example, one could imagine an image-processing package, called ImageList, that returned objects of a new class that implements List. In addition to the List operations, ImageListcould support any application-specific operations that seemed desirable. For example, it might provide an indexImage operation that returned an image containing thumbnail images of each graphic in the ImageList. It&#x27;s critical to note that even if the API furnishes ImageList instances on output, it should accept arbitrary Collection (or perhaps List) instances on input.</p><p>In one sense, return values should have the opposite behavior of input parameters: It&#x27;s best to return the most specific applicable collection interface rather than the most general. For example, if you&#x27;re sure that you&#x27;ll always return a SortedMap, you should give the relevant method the return type of SortedMap rather than Map. SortedMap instances are more time-consuming to build than ordinary Map instances and are also more powerful. Given that your module has already invested the time to build a SortedMap, it makes good sense to give the user access to its increased power. Furthermore, the user will be able to pass the returned object to methods that demand a SortedMap, as well as those that accept any Map.</p><h5>13.6.8.2.3 Legacy APIs</h5><p>There are currently plenty of APIs out there that define their own ad hoc collection types. While this is unfortunate, it&#x27;s a fact of life, given that there was no Collections Framework in the first two major releases of the Java platform. Suppose you own one of these APIs; here&#x27;s what you can do about it.</p><p>If possible, retrofit your legacy collection type to implement one of the standard collection interfaces. Then all the collections you return will interoperate smoothly with other collection-based APIs. If this is impossible (for example, because one or more of the preexisting type signatures conflict with the standard collection interfaces), define an <em>adapter class</em> that wraps one of your legacy collections objects, allowing it to function as a standard collection. (The Adapter class is an example of a <a href="https://docs.oracle.com/javase/tutorial/collections/custom-implementations/index.html"><em>custom implementation</em></a>.)</p><p>Retrofit your API with new calls that follow the input guidelines to accept objects of a standard collection interface, if possible. Such calls can coexist with the calls that take the legacy collection type. If this is impossible, provide a constructor or static factory for your legacy type that takes an object of one of the standard interfaces and returns a legacy collection containing the same elements (or mappings). Either of these approaches will allow users to pass arbitrary collections into your API.</p><h1>14 Concurrency</h1><p>The Java platform is designed from the ground up to support concurrent programming, with basic concurrency support in the Java programming language and the Java class libraries. Since version 5.0, the Java platform has also included high-level concurrency APIs.</p><h2>14.1 Processes and Threads</h2><p>In concurrent programming, there are two basic units of execution: <em>processes</em> and <em>threads</em>. In the Java programming language, concurrent programming is mostly concerned with threads.</p><p>A computer system normally has many active processes and threads. Even in systems that only have a single execution core, and thus only have one thread actually executing at any given moment. Processing time for a single core is shared among processes and threads through an OS feature called time slicing.</p><p>It&#x27;s becoming more and more common for computer systems to have multiple processors or processors with multiple execution cores. This greatly enhances a system&#x27;s capacity for concurrent execution of processes and threads</p><h2>14.2 Processes</h2><p>A process has a self-contained execution environment. A process generally has a complete, private set of basic run-time resources; in particular, each process has its own memory space.</p><p>Processes are often seen as synonymous with programs or applications. However, what the user sees as a single application may in fact be a set of cooperating processes. To facilitate communication between processes, most operating systems support <em>Inter Process Communication</em> (IPC) resources, such as pipes and sockets. IPC is used not just for communication between processes on the same system, but processes on different systems.</p><p>Most implementations of the Java virtual machine run as a single process. A Java application can create additional processes using a <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html">ProcessBuilder</a> object. Multiprocess applications are beyond the scope of this lesson.</p><h3>14.2.1 Threads</h3><p>Threads are sometimes called <em>lightweight processes</em>. Both processes and threads provide an execution environment, but creating a new thread requires fewer resources than creating a new process.</p><p>Threads exist within a process --- every process has at least one. Threads share the process&#x27;s resources, including memory and open files. This makes for efficient, but potentially problematic, communication.</p><p>Multithreaded execution is an essential feature of the Java platform. Every application has at least one thread --- or several, if you count &quot;system&quot; threads that do things like memory management and signal handling. But from the application programmer&#x27;s point of view, you start with just one thread, called the <em>main thread</em>. This thread has the ability to create additional threads, as we&#x27;ll demonstrate in the next section.</p><h2>14.3 Thread Objects</h2><p>Each thread is associated with an instance of the class <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread</a>. There are two basic strategies for using Thread objects to create a concurrent application.</p><ul><li>To directly control thread creation and management, simply instantiate Thread each time the application needs to initiate an asynchronous task.</li><li>To abstract thread management from the rest of your application, pass the application&#x27;s tasks to an <em>executor</em>.</li></ul><h2>14.4 Defining and Starting a Thread</h2><p>An application that creates an instance of Thread must provide the code that will run in that thread. There are two ways to do this:</p><p><em>Provide a Runnable object.</em> The <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">Runnable</a> interface defines a single method, run, meant to contain the code executed in the thread. The Runnable object is passed to the Thread constructor, as in the <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/HelloRunnable.java">HelloRunnable</a> example:</p><pre><code class="language-java">1.  **public** **class** HelloRunnable **implements** Runnable {  
2.      **public** **void** run() {  
3.          System.out.println(&quot;Hello from a thread!&quot;);  
4.      }  
5.      **public** **static** **void** main(String args[]) {  
6.          (**new** Thread(**new** HelloRunnable())).start();  
7.      }  
8.  }  
</code></pre><p><em>Subclass Thread.</em> The Thread class itself implements Runnable, though its run method does nothing. An application can subclass Thread, providing its own implementation of run, as in the <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/HelloThread.java">HelloThread</a> example:</p><pre><code class="language-java">1.  **public** **class** HelloThread **extends** Thread {  
2.      **public** **void** run() {  
3.          System.out.println(&quot;Hello from a thread!&quot;);  
4.      }  
5.      **public** **static** **void** main(String args[]) {  
6.          (**new** HelloThread()).start();  
7.      }  
8.  }  
</code></pre><p>Notice that both examples <strong>invoke Thread.start</strong> in order to start the new thread.</p><p>Which of these idioms should you use? The first idiom, which employs a Runnable object, is more general, because the Runnable object can subclass a class other than Thread. The second idiom is easier to use in simple applications, but is limited by the fact that your task class must be a descendant of Thread. This lesson focuses on the first approach, which separates the Runnable task from the Thread object that executes the task.</p><p>The Thread class defines a number of methods useful for thread management. These include static methods, which provide information about, or affect the status of, the thread invoking the method. The other methods are invoked from other threads involved in managing the thread and Thread object.</p><h3>14.4.1 Pausing Execution with Sleep</h3><p>Thread.sleep causes the current thread to suspend execution for a specified period. This is an efficient means of making processor time available to the other threads of an application or other applications that might be running on a computer system. The sleep method can also be used for pacing, as shown in the example that follows, and waiting for another thread with duties that are understood to have time requirements, as with the SimpleThreads example in a later section.</p><p>Two overloaded versions of sleep are provided: one that specifies the sleep time to the millisecond and one that specifies the sleep time to the nanosecond. However, these sleep times are not guaranteed to be precise, because they are limited by the facilities provided by the underlying OS. Also, the <strong>sleep period can be terminated by interrupts</strong>, as we&#x27;ll see in a later section. <strong>In any case, you cannot assume that invoking sleep will suspend the thread for precisely the time period specified</strong>.</p><p>The <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/SleepMessages.java">SleepMessages</a> example uses sleep to print messages at four-second intervals:</p><pre><code class="language-java">1.  **public** **class** SleepMessages {  
2.      **public** **static** **void** main(String args[]) **throws** InterruptedException {  
3.          String importantInfo[] = {  
4.              &quot;Mares eat oats&quot;, &quot;Does eat oats&quot;, &quot;Little lambs eat ivy&quot;, &quot;A kid will eat ivy too&quot;  
5.          };  
6.          **for** (**int** i = 0; i &lt; importantInfo.length; i++) { //Pause for 4 seconds  
7.              Thread.sleep(4000); //Print a message  
8.              System.out.println(importantInfo[i]);  
9.          }  
10.     }  
11. }  
</code></pre><p>Notice that main declares that it throws InterruptedException. This is an exception that sleep throws when another thread interrupts the current thread while sleep is active. Since this application has not defined another thread to cause the interrupt, it doesn&#x27;t bother to catch InterruptedException.</p><h2>14.5 Interrupts</h2><p>An <em>interrupt</em> is an indication to a thread that it should stop what it is doing and do something else. It&#x27;s up to the programmer to decide exactly how a thread responds to an interrupt, but it is very common for the thread to terminate. This is the usage emphasized in this lesson.</p><p>A thread sends an interrupt by invoking <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#interrupt--">interrupt</a> on the Thread object for the thread to be interrupted. For the interrupt mechanism to work correctly, the interrupted thread must support its own interruption.</p><h3>14.5.1 Supporting Interruption</h3><p>How does a thread support its own interruption? This depends on what it&#x27;s currently doing. If the thread is frequently invoking methods that throw InterruptedException, it simply returns from the run method after it catches that exception. For example, suppose the central message loop in the SleepMessages example were in the run method of a thread&#x27;s Runnable object. Then it might be modified as follows to support interrupts:</p><pre><code class="language-java">1.  **for** (**int** i = 0; i &lt; importantInfo.length; i++) { // Pause for 4 seconds  
2.      **try** {  
3.          Thread.sleep(4000);  
4.      } **catch** (InterruptedException e) { // We&#x27;ve been interrupted: no more messages.  
5.          **return**;  
6.      } // Print a message  
7.      System.out.println(importantInfo[i]);  
8.  }  
</code></pre><p>Many methods that throw InterruptedException, such as sleep, are designed to cancel their current operation and return immediately when an interrupt is received.</p><p>What if a thread goes a long time without invoking a method that throws InterruptedException? Then it must periodically invoke Thread.interrupted, which returns true if an interrupt has been received. For example:</p><pre><code class="language-java">1.  **for** (**int** i = 0; i &lt; inputs.length; i++) {  
2.      heavyCrunch(inputs[i]);  
3.      **if** (Thread.interrupted()) { // We&#x27;ve been interrupted: no more crunching.  
4.          **return**;  
5.      }  
6.  }  
</code></pre><p>In this simple example, the code simply tests for the interrupt and exits the thread if one has been received. In more complex applications, it might make more sense to throw an InterruptedException:</p><pre><code class="language-java">1.  **if** (Thread.interrupted()) {  
2.      **throw** **new** InterruptedException();  
3.  }  
</code></pre><p>This allows interrupt handling code to be centralized in a catch clause.</p><h3>14.5.2 The Interrupt Status Flag</h3><p>The interrupt mechanism is implemented using an <strong>internal flag known as the <em>interrupt status</em></strong>. Invoking Thread.interrupt sets this flag. When a thread checks for an interrupt by invoking the static method Thread.interrupted, interrupt status is cleared. The non-static isInterrupted method, which is used by one thread to query the interrupt status of another, does not change the interrupt status flag.</p><p>By convention, any method that exits by throwing an InterruptedException clears interrupt status when it does so. However, it&#x27;s always possible that interrupt status will immediately be set again, by another thread invoking interrupt.</p><h2>14.6 Joins</h2><p>The join method allows one thread to wait for the completion of another. If t is a Thread object whose thread is currently executing,</p><pre><code class="language-java">1.  t.join();  
</code></pre><p>causes the current thread to pause execution until t&#x27;s thread terminates. Overloads of join allow the programmer to specify a waiting period. However, as with sleep, join is dependent on the OS for timing, so you should not assume that join will wait exactly as long as you specify.</p><p>Like sleep, join responds to an interrupt by exiting with an InterruptedException.</p><h2>14.7 The SimpleThreads Example</h2><p>The following example brings together some of the concepts of this section. <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/SimpleThreads.java">SimpleThreads</a> consists of two threads. The first is the main thread that every Java application has. The main thread creates a new thread from the Runnable object, MessageLoop, and waits for it to finish. If the MessageLoop thread takes too long to finish, the main thread interrupts it.</p><p>The MessageLoop thread prints out a series of messages. If interrupted before it has printed all its messages, the MessageLoop thread prints a message and exits.</p><pre><code class="language-java">1.  **public** **class** SimpleThreads { // Display a message, preceded by // the name of the current thread  
2.      **static** **void** threadMessage(String message) {  
3.          String threadName = Thread.currentThread().getName();  
4.          System.out.format(&quot;%s: %s%n&quot;, threadName, message);  
5.      }  
6.      **private** **static** **class** MessageLoop **implements** Runnable {  
7.          **public** **void** run() {  
8.              String importantInfo[] = {  
9.                  &quot;Mares eat oats&quot;, &quot;Does eat oats&quot;, &quot;Little lambs eat ivy&quot;, &quot;A kid will eat ivy too&quot;  
10.             };  
11.             **try** {  
12.                 **for** (**int** i = 0; i &lt; importantInfo.length; i++) { // Pause for 4 seconds  
13.                     Thread.sleep(4000); // Print a message  
14.                     threadMessage(importantInfo[i]);  
15.                 }  
16.             } **catch** (InterruptedException e) {  
17.                 threadMessage(&quot;I wasn&#x27;t done!&quot;);  
18.             }  
19.         }  
20.     }  
21.     **public** **static** **void** main(String args[]) **throws** InterruptedException { // Delay, in milliseconds before // we interrupt MessageLoop // thread (default one hour).  
22.         **long** patience = 1000 \* 60 \* 60; // If command line argument // present, gives patience // in seconds.  
23.         **if** (args.length &gt; 0) {  
24.             **try** {  
25.                 patience = Long.parseLong(args[0]) \* 1000;  
26.             } **catch** (NumberFormatException e) {  
27.                 System.err.println(&quot;Argument must be an integer.&quot;);  
28.                 System.exit(1);  
29.             }  
30.         }  
31.         threadMessage(&quot;Starting MessageLoop thread&quot;);  
32.         **long** startTime = System.currentTimeMillis();  
33.         Thread t = **new** Thread(**new** MessageLoop());  
34.         t.start();  
35.         threadMessage(&quot;Waiting for MessageLoop thread to finish&quot;); // loop until MessageLoop // thread exits  
36.         **while** (t.isAlive()) {  
37.             threadMessage(&quot;Still waiting\...&quot;); // Wait maximum of 1 second // for MessageLoop thread // to finish.  
38.             t.join(1000);  
39.             **if** (((System.currentTimeMillis() - startTime) &gt; patience) &amp;&amp; t.isAlive()) {  
40.                 threadMessage(&quot;Tired of waiting!&quot;);  
41.                 t.interrupt(); // Shouldn&#x27;t be long now // -- wait indefinitely  
42.                 t.join();  
43.             }  
44.         }  
45.         threadMessage(&quot;Finally!&quot;);  
46.     }  
47. }  
</code></pre><h2>14.8 Synchronization</h2><p>Threads communicate primarily by sharing access to fields and the objects reference fields refer to. This form of communication is extremely efficient, but makes two kinds of errors possible: <strong><em>thread interference</em> and <em>memory consistency errors</em></strong>. The tool needed to prevent these errors is <em>synchronization</em>.</p><p>However, synchronization can introduce []{#bookmark=id.2vz14pi}<strong><em>thread contention</em>, which occurs when two or more threads try to access the same resource simultaneously <em>and</em> cause the Java runtime to execute one or more threads more slowly, or even suspend their execution</strong>. <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html">Starvation and livelock</a> are forms of thread contention. See the section <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/liveness.html">Liveness</a> for more information.</p><h2>14.9 Thread Interference</h2><p>Consider a simple class called <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/Counter.java">Counter</a></p><pre><code class="language-java">1.  **class** Counter {  
2.      **private** **int** c = 0;  
3.      **public** **void** increment() {  
4.          c++;  
5.      }  
6.      **public** **void** decrement() {  
7.          c--;  
8.      }  
9.      **public** **int** value() {  
10.         **return** c;  
11.     }  
12. }  
</code></pre><p>Counter is designed so that each invocation of increment will add 1 to c, and each invocation of decrement will subtract 1 from c. However, if a Counter object is referenced from multiple threads, interference between threads may prevent this from happening as expected.</p><p>Interference happens when two operations, running in different threads, but acting on the same data, <em>interleave</em>. This means that the two operations consist of multiple steps, and the sequences of steps overlap.</p><p>It might not seem possible for operations on instances of Counter to interleave, since both operations on c are single, simple statements. However, even simple statements can translate to multiple steps by the virtual machine. We won&#x27;t examine the specific steps the virtual machine takes --- it is enough to know that the single expression c++ can be decomposed into three steps:</p><ol><li>Retrieve the current value of c.</li><li>Increment the retrieved value by 1.</li><li>Store the incremented value back in c.</li></ol><p>The expression c-- can be decomposed the same way, except that the second step decrements instead of increments.</p><p>Suppose Thread A invokes increment at about the same time Thread B invokes decrement. If the initial value of c is 0, their interleaved actions might follow this sequence:</p><ol><li>Thread A: Retrieve c.</li><li>Thread B: Retrieve c.</li><li>Thread A: Increment retrieved value; result is 1.</li><li>Thread B: Decrement retrieved value; result is -1.</li><li>Thread A: Store result in c; c is now 1.</li><li>Thread B: Store result in c; c is now -1.</li></ol><p>Thread A&#x27;s result is lost, overwritten by Thread B. This particular interleaving is only one possibility. Under different circumstances it might be Thread B&#x27;s result that gets lost, or there could be no error at all. Because they are unpredictable, thread interference bugs can be difficult to detect and fix.</p><h2>14.10 Memory Consistency Errors</h2><p><em>Memory consistency errors</em> occur when different threads have inconsistent views of what should be the same data. The causes of memory consistency errors are complex and beyond the scope of this tutorial. Fortunately, the programmer does not need a detailed understanding of these causes. All that is needed is a strategy for avoiding them.</p><p>The key to avoiding memory consistency errors is understanding the <em>happens-before</em> relationship. This relationship is simply a guarantee that memory writes by one specific statement are visible to another specific statement. To see this, consider the following example. Suppose a simple int field is defined and initialized:</p><pre><code class="language-java">1.  **int** counter = 0;  
</code></pre><p>The counter field is shared between two threads, A and B. Suppose thread A increments counter:</p><pre><code class="language-java">1.  counter++;  
</code></pre><p>Then, shortly afterwards, thread B prints out counter:</p><pre><code class="language-java">1.  System.out.println(counter);  
</code></pre><p>If the two statements had been executed in the same thread, it would be safe to assume that the value printed out would be &quot;1&quot;. But if the two statements are executed in separate threads, the value printed out might well be &quot;0&quot;, because there&#x27;s no guarantee that thread A&#x27;s change to counter will be visible to thread B --- unless the programmer has established a happens-before relationship between these two statements.</p><p>There are several actions that create happens-before relationships. One of them is synchronization, as we will see in the following sections.</p><p>We&#x27;ve already seen two actions that create happens-before relationships.</p><ul><li>When a statement invokes Thread.start, every statement that has a happens-before relationship with that statement also has a happens-before relationship with every statement executed by the new thread. The effects of the code that led up to the creation of the new thread are visible to the new thread.</li><li>When a thread terminates and causes a Thread.join in another thread to return, then all the statements executed by the terminated thread have a happens-before relationship with all the statements following the successful join. The effects of the code in the thread are now visible to the thread that performed the join.</li></ul><p>For a list of actions that create happens-before relationships, refer to the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility">Summary page of the java.util.concurrent package.</a>.</p><h2>14.11 Synchronized Methods</h2><p>The Java programming language provides two basic synchronization idioms: <em>synchronized methods</em> and <em>synchronized statements</em>. To make a method synchronized, simply add the synchronized keyword to its declaration:</p><pre><code class="language-java">1.  **public** **class** SynchronizedCounter {  
2.      **private** **int** c = 0;  
3.      **public** **synchronized** **void** increment() {  
4.          c++;  
5.      }  
6.      **public** **synchronized** **void** decrement() {  
7.          c--;  
8.      }  
9.      **public** **synchronized** **int** value() {  
10.         **return** c;  
11.     }  
12. }  
</code></pre><p>If count is an instance of SynchronizedCounter, then making these methods synchronized has two effects:</p><ul><li>First, it is not possible for two invocations of synchronized methods on the same object to interleave. When one thread is executing a synchronized method for an object, all other threads that invoke synchronized methods for the same object block (suspend execution) until the first thread is done with the object.</li><li>Second, when a synchronized method exits, it automatically establishes a happens-before relationship with <em>any subsequent invocation</em> of a synchronized method for the same object. This guarantees that changes to the state of the object are visible to all threads.</li></ul><p><strong>Note that constructors cannot be synchronized --- using the synchronized keyword with a constructor is a syntax error. Synchronizing constructors doesn&#x27;t make sense, because only the thread that creates an object should have access to it while it is being constructed.</strong></p><p><strong>Warning:</strong> When constructing an object that will be shared between threads, be very careful that a reference to the object does not &quot;leak&quot; prematurely. For example, suppose you want to maintain a List called instances containing every instance of class. You might be tempted to add the following line to your constructor:</p><pre><code class="language-java">1.  instances.add(**this**);  
</code></pre><p>But then other threads can use instances to access the object before construction of the object is complete.</p><p>Synchronized methods enable a simple strategy for preventing thread interference and memory consistency errors: if an object is visible to more than one thread, all reads or writes to that object&#x27;s variables are done through synchronized methods. (An important exception: final fields, which cannot be modified after the object is constructed, can be safely read through non-synchronized methods, once the object is constructed) <strong>This strategy is effective, but can present problems with </strong><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/liveness.html"><strong>liveness</strong></a>.</p><h2>14.12 Intrinsic Locks and Synchronization</h2><p><strong>Synchronization is built around an internal entity known as the <em>intrinsic lock</em> or <em>monitor lock</em>.</strong> (The API specification often refers to this entity simply as a &quot;monitor.&quot;) Intrinsic locks play a role in both aspects of synchronization: enforcing exclusive access to an object&#x27;s state and <strong>establishing happens-before relationships that are essential to visibility</strong>.</p><p>Every object has an intrinsic lock associated with it. By convention, a thread that needs exclusive and consistent access to an object&#x27;s fields has to <em>acquire</em> the object&#x27;s intrinsic lock before accessing them, and then <em>release</em> the intrinsic lock when it&#x27;s done with them. A thread is said to <em>own</em> the intrinsic lock between the time it has acquired the lock and released the lock. As long as a thread owns an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts to acquire the lock.</p><p><strong>When a thread releases an intrinsic lock, a happens-before relationship is established between that action and any subsequent acquisition of the same lock.</strong></p><h3>14.12.1 Locks in Synchronized Methods</h3><p>When a thread invokes a synchronized method, it automatically acquires the intrinsic lock for that method&#x27;s object and releases it when the method returns. The lock release occurs even if the return was caused by an uncaught exception.</p><p>You might wonder what happens when a static synchronized method is invoked, since a static method is associated with a class, not an object. In this case, the thread acquires the intrinsic lock for the Class object associated with the class. Thus access to class&#x27;s static fields is controlled by a lock that&#x27;s distinct from the lock for any instance of the class.</p><h3>14.12.2 Synchronized Statements</h3><p>Another way to create synchronized code is with <em>synchronized statements</em>. Unlike synchronized methods, synchronized statements must specify the object that provides the intrinsic lock:</p><pre><code class="language-java">1.  **public** **void** addName(String name) {  
2.      **synchronized**(**this**) {  
3.          lastName = name;  
4.          nameCount++;  
5.      }  
6.      nameList.add(name);  
7.  }  
</code></pre><p>In this example, the addName method needs to synchronize changes to lastName and nameCount, but also needs to avoid synchronizing invocations of other objects&#x27; methods. (Invoking other objects&#x27; methods from synchronized code can create problems that are described in the section on <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/liveness.html">Liveness</a>.) Without synchronized statements, there would have to be a separate, unsynchronized method for the sole purpose of invoking nameList.add.</p><p>Synchronized statements are also useful for improving concurrency with fine-grained synchronization. Suppose, for example, class MsLunch has two instance fields, c1 and c2, that are never used together. <strong>All updates of these fields must be synchronized, but there&#x27;s no reason to prevent an update of c1 from being interleaved with an update of c2 --- and doing so reduces concurrency by creating unnecessary blocking. Instead of using synchronized methods or otherwise using the lock associated with this, we create two objects solely to provide locks.</strong></p><pre><code class="language-java">1.  **public** **class** MsLunch {  
2.      **private** **long** c1 = 0;  
3.      **private** **long** c2 = 0;  
4.      **private** Object lock1 = **new** Object();  
5.      **private** Object lock2 = **new** Object();  
6.      **public** **void** inc1() {  
7.          **synchronized**(lock1) {  
8.              c1++;  
9.          }  
10.     }  
11.     **public** **void** inc2() {  
12.         **synchronized**(lock2) {  
13.             c2++;  
14.         }  
15.     }  
16. }  
</code></pre><p>Use this idiom with extreme care. You must be absolutely sure that it really is safe to interleave access of the affected fields.</p><h3>14.12.3 Reentrant Synchronization</h3><p>Recall that a thread cannot acquire a lock owned by another thread. <strong>But a thread <em>can</em> acquire a lock that it already owns. Allowing a thread to acquire the same lock more than once enables <em>reentrant synchronization</em>. This describes a situation where synchronized code, directly or indirectly, invokes a method that also contains synchronized code, and both sets of code use the same lock.</strong> Without reentrant synchronization, synchronized code would have to take many additional precautions to avoid having a thread cause itself to block.</p><h2>14.13 Atomic Access</h2><p>In programming, an <em>atomic</em> action is one that effectively happens all at once. An atomic action cannot stop in the middle: it either happens completely, or it doesn&#x27;t happen at all. No side effects of an atomic action are visible until the action is complete.</p><p>We have already seen that an increment expression, <strong>such as c++, does not describe an atomic action. Even very simple expressions can define complex actions that can decompose into other actions.</strong> However, there are actions you can specify that are atomic:</p><ul><li>Reads and writes are atomic for reference variables and for most primitive variables (all types except long and double).</li><li>Reads and writes are atomic for <em>all</em> variables declared volatile (<em>including</em> long and double variables).</li></ul><p>Atomic actions cannot be interleaved, so they can be used without fear of thread interference. However, this does not eliminate all need to synchronize atomic actions, because memory consistency errors are still possible. Using volatile variables reduces the risk of memory consistency errors, because any write to a volatile variable establishes a happens-before relationship with subsequent reads of that same variable. This means that changes to a volatile variable are always visible to other threads. What&#x27;s more, it also means that when a thread reads a volatile variable, it sees not just the latest change to the volatile, but also the side effects of the code that led up the change.</p><p>Using simple atomic variable access is more efficient than accessing these variables through synchronized code, but requires more care by the programmer to avoid memory consistency errors. Whether the extra effort is worthwhile depends on the size and complexity of the application.</p><p>Some of the classes in the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html">java.util.concurrent</a> package provide atomic methods that do not rely on synchronization. We&#x27;ll discuss them in the section on <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/highlevel.html">High Level Concurrency Objects</a>.</p><h2>14.14 Liveness</h2><p>A concurrent application&#x27;s ability to execute in a timely manner is known as its <em>liveness</em>. This section describes the most common kind of liveness problem, <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/deadlock.html">deadlock</a>, and goes on to briefly describe two other liveness problems, <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html">starvation and livelock</a>.</p><h2>14.15 Deadlock</h2><p><em>Deadlock</em> describes a situation where two or more threads are blocked forever, waiting for each other. Here&#x27;s an example. Alphonse and Gaston are friends, and great believers in courtesy. A strict rule of courtesy is that when you bow to a friend, you must remain bowed until your friend has a chance to return the bow. Unfortunately, this rule does not account for the possibility that two friends might bow to each other at the same time. This example application, <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/Deadlock.java">Deadlock</a>, models this possibility:</p><pre><code class="language-java">1.  **public** **class** Deadlock {  
2.      **static** **class** Friend {  
3.          **private** **final** String name;  
4.          **public** Friend(String name) {  
5.              **this**.name = name;  
6.          }  
7.          **public** String getName() {  
8.              **return** **this**.name;  
9.          }  
10.         **public** **synchronized** **void** bow(Friend bower) {  
11.             System.out.format(&quot;%s: %s&quot; + &quot;  has bowed to me!%n&quot;, **this**.name, bower.getName());  
12.             bower.bowBack(**this**);  
13.         }  
14.         **public** **synchronized** **void** bowBack(Friend bower) {  
15.             System.out.format(&quot;%s: %s&quot; + &quot; has bowed back to me!%n&quot;, **this**.name, bower.getName());  
16.         }  
17.     }  
18.     **public** **static** **void** main(String[] args) {  
19.         **final** Friend alphonse = **new** Friend(&quot;Alphonse&quot;);  
20.         **final** Friend gaston = **new** Friend(&quot;Gaston&quot;);  
21.         **new** Thread(**new** Runnable() {  
22.             **public** **void** run() {  
23.                 alphonse.bow(gaston);  
24.             }  
25.         }).start();  
26.         **new** Thread(**new** Runnable() {  
27.             **public** **void** run() {  
28.                 gaston.bow(alphonse);  
29.             }  
30.         }).start();  
31.     }  
32. }  
</code></pre><p>When Deadlock runs, it&#x27;s extremely likely that both threads will block when they attempt to invoke bowBack. Neither block will ever end, because each thread is waiting for the other to exit bow.</p><h2>14.16 Starvation and Livelock</h2><p>Starvation and livelock are much less common a problem than deadlock, but are still problems that every designer of concurrent software is likely to encounter.</p><h3>14.16.1 Starvation</h3><p><em>Starvation</em> describes a situation <strong>where a thread is unable to gain regular access to shared resources and is unable to make progress. This happens when shared resources are made unavailable for long periods by &quot;greedy&quot; threads</strong>. For example, <strong>suppose an object provides a synchronized method that often takes a long time to return.</strong> If one thread invokes this method frequently, other threads that also need frequent synchronized access to the same object will often be blocked.</p><h3>14.16.2 Livelock</h3><p>A thread often acts in response to the action of another thread. <strong>If the other thread&#x27;s action is also a response to the action of another thread, then <em>livelock</em> may result. As with deadlock, livelocked threads are unable to make further progress.</strong> However, the threads are not blocked --- they are simply too busy responding to each other to resume work. This is comparable to two people attempting to pass each other in a corridor: <strong>Alphonse moves to his left to let Gaston pass, while Gaston moves to his right to let Alphonse pass. Seeing that they are still blocking each other, Alphone moves to his right, while Gaston moves to his left. They&#x27;re still blocking each other, so<!-- -->.<!-- -->..</strong></p><h2>14.17 Guarded Blocks</h2><p>Threads often have to coordinate their actions. The most common coordination idiom is the <em>guarded block</em>. Such a block begins by polling a condition that must be true before the block can proceed. There are a number of steps to follow in order to do this correctly.</p><p>Suppose, for example guardedJoy is a method that must not proceed until a shared variable joy has been set by another thread. Such a method could, in theory, simply loop until the condition is satisfied, but that loop is wasteful, since it executes continuously while waiting.</p><ol><li><strong>public</strong> <strong>void</strong> guardedJoy() { // Simple loop guard. Wastes // processor time. Don&#x27;t do this!  </li><li>    <strong>while</strong> (!joy) {}  </li><li>    System.out.println(&quot;Joy has been achieved!&quot;);  </li><li>}  </li></ol><p>A more efficient guard invokes <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--">Object.wait</a> to suspend the current thread. The invocation of wait does not return until another thread has issued a notification that some special event may have occurred --- though not necessarily the event this thread is waiting for:</p><pre><code class="language-java">1.  **public** **synchronized** **void** guardedJoy() { // This guard only loops once for each special event, which may not // be the event we&#x27;re waiting for.  
2.      **while** (!joy) {  
3.          **try** {  
4.              wait();  
5.          } **catch** (InterruptedException e) {}  
6.      }  
7.      System.out.println(&quot;Joy and efficiency have been achieved!&quot;);  
8.  }  
</code></pre><p><strong>Note:</strong> Always invoke wait inside a loop that tests for the condition being waited for. Don&#x27;t assume that the interrupt was for the particular condition you were waiting for, or that the condition is still true.</p><p>Like many methods that suspend execution, wait can throw InterruptedException. In this example, we can just ignore that exception --- we only care about the value of joy.</p><p>Why is this version of guardedJoy synchronized? Suppose d is the object we&#x27;re using to invoke wait. When a thread invokes d.wait, it must own the intrinsic lock for d --- otherwise an error is thrown. Invoking wait inside a synchronized method is a simple way to acquire the intrinsic lock.</p><p>When wait is invoked, the thread releases the lock and suspends execution. At some future time, another thread will acquire the same lock and invoke <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll--">Object.notifyAll</a>, informing all threads waiting on that lock that something important has happened:</p><pre><code class="language-java">1.  **public** **synchronized** notifyJoy() {  
2.      joy = **true**;  
3.      notifyAll();  
4.  }  
</code></pre><p>Sometime after the second thread has released the lock, the first thread reacquires the lock and resumes by returning from the invocation of wait.</p><p><strong>Note:</strong> There is a second notification method, notify, which wakes up a single thread. Because notify doesn&#x27;t allow you to specify the thread that is woken up, it is useful only in massively parallel applications --- that is, programs with a large number of threads, all doing similar chores. In such an application, you don&#x27;t care which thread gets woken up.</p><p>Let&#x27;s use guarded blocks to create a <em>Producer-Consumer</em> application. This kind of application shares data between two threads: the <em>producer</em>, that creates the data, and the <em>consumer</em>, that does something with it. The two threads communicate using a shared object. Coordination is essential: the consumer thread must not attempt to retrieve the data before the producer thread has delivered it, and the producer thread must not attempt to deliver new data if the consumer hasn&#x27;t retrieved the old data.</p><p>In this example, the data is a series of text messages, which are shared through an object of type <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/Drop.java">Drop</a>:</p><pre><code class="language-java">1.  **public** **class** Drop { // Message sent from producer // to consumer.  
2.      **private** String message; // True if consumer should wait // for producer to send message, // false if producer should wait for // consumer to retrieve message.  
3.      **private** **boolean** empty = **true**;  
4.      **public** **synchronized** String take() { // Wait until message is // available.  
5.          **while** (empty) {  
6.              **try** {  
7.                  wait();  
8.              } **catch** (InterruptedException e) {}  
9.          } // Toggle status.  
10.         empty = **true**; // Notify producer that // status has changed.  
11.         notifyAll();  
12.         **return** message;  
13.     }  
14.     **public** **synchronized** **void** put(String message) { // Wait until message has // been retrieved.  
15.         **while** (!empty) {  
16.             **try** {  
17.                 wait();  
18.             } **catch** (InterruptedException e) {}  
19.         } // Toggle status.  
20.         empty = **false**; // Store message.  
21.         **this**.message = message; // Notify consumer that status // has changed.  
22.         notifyAll();  
23.     }  
24. }  
</code></pre><p>The producer thread, defined in <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/Producer.java">Producer</a>, sends a series of familiar messages. The string &quot;DONE&quot; indicates that all messages have been sent. To simulate the unpredictable nature of real-world applications, the producer thread pauses for random intervals between messages.</p><pre><code class="language-java">+-----------------------------------------------------------------------+
| import java.util.Random;\                                             |
| public class Producer implements Runnable {\                          |
| private Drop drop;\                                                   |
| public Producer(Drop drop) {\                                         |
| this.drop = drop;\                                                    |
| }\                                                                    |
| public void run() {\                                                  |
| String importantInfo[] = {\                                         |
| &quot;Mares eat oats&quot;, &quot;Does eat oats&quot;, &quot;Little lambs eat ivy&quot;, &quot;A  |
| kid will eat ivy too&quot;\                                               |
| };\                                                                   |
| Random random = new Random();\                                        |
| for (int i = 0; i &lt; importantInfo.length; i++) {\                    |
| drop.put(importantInfo[i]);\                                        |
| try {\                                                                |
| Thread.sleep(random.nextInt(5000));\                                  |
| } catch (InterruptedException e) {}\                                  |
| }\                                                                    |
| drop.put(&quot;DONE&quot;);\                                                  |
| }\                                                                    |
| }                                                                     |
+-----------------------------------------------------------------------
</code></pre><p>The consumer thread, defined in <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/Consumer.java">Consumer</a>, simply retrieves the messages and prints them out, until it retrieves the &quot;DONE&quot; string. This thread also pauses for random intervals.</p><pre><code class="language-java">1.  **import** java.util.Random;  
2.  **public** **class** Consumer **implements** Runnable {  
3.      **private** Drop drop;  
4.      **public** Consumer(Drop drop) {  
5.          **this**.drop = drop;  
6.      }  
7.      **public** **void** run() {  
8.          Random random = **new** Random();  
9.          **for** (String message = drop.take(); !message.equals(&quot;DONE&quot;); message = drop.take()) {  
10.             System.out.format(&quot;MESSAGE RECEIVED: %s%n&quot;, message);  
11.             **try** {  
12.                 Thread.sleep(random.nextInt(5000));  
13.             } **catch** (InterruptedException e) {}  
14.         }  
15.     }  
16. }  
</code></pre><p>Finally, here is the main thread, defined in <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/ProducerConsumerExample.java">ProducerConsumerExample</a>, that launches the producer and consumer threads.</p><pre><code class="language-java">1.  **public** **class** ProducerConsumerExample {  
2.      **public** **static** **void** main(String[] args) {  
3.          Drop drop = **new** Drop();  
4.          (**new** Thread(**new** Producer(drop))).start();  
5.          (**new** Thread(**new** Consumer(drop))).start();  
6.      }  
7.  }  
</code></pre><p><strong>Note:</strong> The Drop class was written in order to demonstrate guarded blocks. To avoid re-inventing the wheel, examine the existing data structures in the <a href="https://docs.oracle.com/javase/tutorial/collections/index.html">Java Collections Framework</a>before trying to code your own data-sharing objects. For more information, refer to the <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/QandE/questions.html">Questions and Exercises</a> section.</p><h2>14.18 Immutable Objects</h2><p>An object is considered <em>immutable</em> if its <strong>state cannot change after it is constructed</strong>. Maximum reliance on immutable objects is widely accepted as a sound strategy for creating simple, reliable code.</p><p>Immutable objects are particularly useful in concurrent applications. Since they cannot change state, they cannot be corrupted by thread interference or observed in an inconsistent state.</p><p>Programmers are often reluctant to employ immutable objects, because they worry about the cost of creating a new object as opposed to updating an object in place. The impact of object creation is often overestimated and can be offset by some of the efficiencies associated with immutable objects. These include decreased overhead due to garbage collection, and the elimination of code needed to protect mutable objects from corruption.</p><p>The following subsections take a class whose instances are mutable and derives a class with immutable instances from it. In so doing, they give general rules for this kind of conversion and demonstrate some of the advantages of immutable objects.</p><h2>14.19 A Synchronized Class Example</h2><p>The class, <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/SynchronizedRGB.java">SynchronizedRGB</a>, defines objects that represent colors. Each object represents the color as three integers that stand for primary color values and a string that gives the name of the color.</p><pre><code class="language-java">1.  **public** **class** SynchronizedRGB { // Values must be between 0 and 255.  
2.      **private** **int** red;  
3.      **private** **int** green;  
4.      **private** **int** blue;  
5.      **private** String name;  
6.      **private** **void** check(**int** red, **int** green, **int** blue) {  
7.          **if** (red &lt; 0 \|\| red &gt; 255 \|\| green &lt; 0 \|\| green &gt; 255 \|\| blue &lt; 0 \|\| blue &gt; 255) {  
8.              **throw** **new** IllegalArgumentException();  
9.          }  
10.     }  
11.     **public** SynchronizedRGB(**int** red, **int** green, **int** blue, String name) {  
12.         check(red, green, blue);  
13.         **this**.red = red;  
14.         **this**.green = green;  
15.         **this**.blue = blue;  
16.         **this**.name = name;  
17.     }  
18.     **public** **void** set(**int** red, **int** green, **int** blue, String name) {  
19.         check(red, green, blue);  
20.         **synchronized**(**this**) {  
21.             **this**.red = red;  
22.             **this**.green = green;  
23.             **this**.blue = blue;  
24.             **this**.name = name;  
25.         }  
26.     }  
27.     **public** **synchronized** **int** getRGB() {  
28.         **return** ((red &lt;&lt; 16) \| (green &lt;&lt; 8) \| blue);  
29.     }  
30.     **public** **synchronized** String getName() {  
31.         **return** name;  
32.     }  
33.     **public** **synchronized** **void** invert() {  
34.         red = 255 - red;  
35.         green = 255 - green;  
36.         blue = 255 - blue;  
37.         name = &quot;Inverse of &quot; + name;  
38.     }  
39. }  
</code></pre><p>SynchronizedRGB must be used carefully to avoid being seen in an inconsistent state. Suppose, for example, a thread executes the following code:</p><pre><code class="language-java">1.  SynchronizedRGB color = **new** SynchronizedRGB(0, 0, 0, &quot;Pitch Black&quot;);\...**int** myColorInt = color.getRGB(); //Statement 1  
2.  String myColorName = color.getName(); //Statement 2  
</code></pre><p>If another thread invokes color.set after Statement 1 but before Statement 2, the value of myColorInt won&#x27;t match the value of myColorName. To avoid this outcome, the two statements must be bound together:</p><pre><code class="language-java">1.  **synchronized**(color) {  
2.      **int** myColorInt = color.getRGB();  
3.      String myColorName = color.getName();  
4.  }  
</code></pre><p>This kind of inconsistency is only possible for mutable objects --- it will not be an issue for the immutable version of SynchronizedRGB.</p><h2>14.20 A Strategy for Defining Immutable Objects</h2><p>The following rules define a simple strategy for creating immutable objects. Not all classes documented as &quot;immutable&quot; follow these rules. This does not necessarily mean the creators of these classes were sloppy --- they may have good reason for believing that instances of their classes never change after construction. However, such strategies require sophisticated analysis and are not for beginners.</p><ul><li><strong>Don&#x27;t provide &quot;setter&quot; methods</strong> --- methods that modify fields or objects referred to by fields.</li><li><strong>Make all fields final and private</strong>.</li><li><strong>Don&#x27;t allow subclasses to override methods</strong>. The simplest way to do this is to <strong>declare the class as final</strong>. A more sophisticated approach is to make <strong>the constructor private and construct instances in factory methods</strong>.</li><li>If the instance fields include <strong>references to mutable objects, don&#x27;t allow those objects to be changed</strong>:<ul><li><strong>Don&#x27;t provide methods that modify the mutable objects</strong>.</li><li><strong>Don&#x27;t share references to the mutable objects</strong>. Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods.</li></ul></li></ul><p>Applying this strategy to SynchronizedRGB results in the following steps:</p><ul><li>There are two setter methods in this class. The first one, set, arbitrarily transforms the object, and has no place in an immutable version of the class. The second one, invert, can be adapted by having it create a new object instead of modifying the existing one.</li><li>All fields are already private; they are further qualified as final.</li><li>The class itself is declared final.</li><li>Only one field refers to an object, and that object is itself immutable. Therefore, no safeguards against changing the state of &quot;contained&quot; mutable objects are necessary.</li></ul><p>After these changes, we have <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/ImmutableRGB.java">ImmutableRGB</a>:</p><pre><code class="language-java">1.  **final** **public** **class** ImmutableRGB { // Values must be between 0 and 255.  
2.      **final** **private** **int** red;  
3.      **final** **private** **int** green;  
4.      **final** **private** **int** blue;  
5.      **final** **private** String name;  
6.      **private** **void** check(**int** red, **int** green, **int** blue) {  
7.          **if** (red &lt; 0 \|\| red &gt; 255 \|\| green &lt; 0 \|\| green &gt; 255 \|\| blue &lt; 0 \|\| blue &gt; 255) {  
8.              **throw** **new** IllegalArgumentException();  
9.          }  
10.     }  
11.     **public** ImmutableRGB(**int** red, **int** green, **int** blue, String name) {  
12.         check(red, green, blue);  
13.         **this**.red = red;  
14.         **this**.green = green;  
15.         **this**.blue = blue;  
16.         **this**.name = name;  
17.     }  
18.     **public** **int** getRGB() {  
19.         **return** ((red &lt;&lt; 16) \| (green &lt;&lt; 8) \| blue);  
20.     }  
21.     **public** String getName() {  
22.         **return** name;  
23.     }  
24.     **public** ImmutableRGB invert() {  
25.         **return** **new** ImmutableRGB(255 - red, 255 - green, 255 - blue, &quot;Inverse of &quot; + name);  
26.     }  
27. }  
</code></pre><h2>14.21 High Level Concurrency Objects</h2><p>So far, this lesson has focused on the low-level APIs that have been part of the Java platform from the very beginning. These APIs are adequate for very basic tasks, but higher-level building blocks are needed for more advanced tasks. This is especially true for massively concurrent applications that fully exploit today&#x27;s multiprocessor and multi-core systems.</p><p>In this section we&#x27;ll look at some of the high-level concurrency features introduced with version 5.0 of the Java platform. Most of these features are implemented in the new java.util.concurrent packages. There are also new concurrent data structures in the Java Collections Framework.</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/newlocks.html">Lock objects</a> support locking idioms that simplify many concurrent applications.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/executors.html">Executors</a> define a high-level API for launching and managing threads. Executor implementations provided by java.util.concurrent provide thread pool management suitable for large-scale applications.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/collections.html">Concurrent collections</a> make it easier to manage large collections of data, and can greatly reduce the need for synchronization.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/atomicvars.html">Atomic variables</a> have features that minimize synchronization and help avoid memory consistency errors.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/threadlocalrandom.html">ThreadLocalRandom</a> (in JDK 7) provides efficient generation of pseudorandom numbers from multiple threads.</li></ul><h2>14.22 Lock Objects</h2><p>Synchronized code relies on a simple kind of reentrant lock. This kind of lock is easy to use but has many limitations. More sophisticated locking idioms are supported by the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/package-summary.html">java.util.concurrent.locks</a> package. We won&#x27;t examine this package in detail, but instead will focus on its most basic interface, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html">Lock</a>.</p><p>Lock objects work very much like the implicit locks used by synchronized code. As with implicit locks, only one thread can own a Lock object at a time. Lock objects also support a wait/notify mechanism, through their associated <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html">Condition</a> objects.</p><p>The biggest advantage of <strong>Lock objects over implicit locks is their ability to back out of an attempt to acquire a lock</strong>. <strong>The tryLock method backs out if the lock is not available immediately or before a timeout expires (if specified). The lockInterruptibly method backs out if another thread sends an interrupt before the lock is acquired.</strong></p><p>Let&#x27;s use Lock objects to solve the deadlock problem we saw in <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/liveness.html">Liveness</a>. Alphonse and Gaston have trained themselves to notice when a friend is about to bow. We model this improvement by requiring that our Friend objects must acquire locks for <em>both</em> participants before proceeding with the bow. Here is the source code for the improved model, <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/Safelock.java">Safelock</a>. To demonstrate the versatility of this idiom, we assume that Alphonse and Gaston are so infatuated with their newfound ability to bow safely that they can&#x27;t stop bowing to each other:</p><pre><code class="language-java">1.  **import** java.util.concurrent.locks.Lock;  
2.  **import** java.util.concurrent.locks.ReentrantLock;  
3.  **import** java.util.Random;  
4.  **public** **class** Safelock {  
5.      **static** **class** Friend {  
6.          **private** **final** String name;  
7.          **private** **final** Lock lock = **new** ReentrantLock();  
8.          **public** Friend(String name) {  
9.              **this**.name = name;  
10.         }  
11.         **public** String getName() {  
12.             **return** **this**.name;  
13.         }  
14.         **public** **boolean** impendingBow(Friend bower) {  
15.             Boolean myLock = **false**;  
16.             Boolean yourLock = **false**;  
17.             **try** {  
18.                 myLock = lock.tryLock();  
19.                 yourLock = bower.lock.tryLock();  
20.             } **finally** {  
21.                 **if** (!(myLock &amp;&amp; yourLock)) {  
22.                     **if** (myLock) {  
23.                         lock.unlock();  
24.                     }  
25.                     **if** (yourLock) {  
26.                         bower.lock.unlock();  
27.                     }  
28.                 }  
29.             }  
30.             **return** myLock &amp;&amp; yourLock;  
31.         }  
32.         **public** **void** bow(Friend bower) {  
33.             **if** (impendingBow(bower)) {  
34.                 **try** {  
35.                     System.out.format(&quot;%s: %s has&quot; + &quot; bowed to me!%n&quot;, **this**.name, bower.getName());  
36.                     bower.bowBack(**this**);  
37.                 } **finally** {  
38.                     lock.unlock();  
39.                     bower.lock.unlock();  
40.                 }  
41.             } **else** {  
42.                 System.out.format(&quot;%s: %s started&quot; + &quot; to bow to me, but saw that&quot; + &quot; I was already bowing to&quot; + &quot; him.%n&quot;, **this**.name, bower.getName());  
43.             }  
44.         }  
45.         **public** **void** bowBack(Friend bower) {  
46.             System.out.format(&quot;%s: %s has&quot; + &quot; bowed back to me!%n&quot;, **this**.name, bower.getName());  
47.         }  
48.     }  
49.     **static** **class** BowLoop **implements** Runnable {  
50.         **private** Friend bower;  
51.         **private** Friend bowee;  
52.         **public** BowLoop(Friend bower, Friend bowee) {  
53.             **this**.bower = bower;  
54.             **this**.bowee = bowee;  
55.         }  
56.         **public** **void** run() {  
57.             Random random = **new** Random();  
58.             **for** (;;) {  
59.                 **try** {  
60.                     Thread.sleep(random.nextInt(10));  
61.                 } **catch** (InterruptedException e) {}  
62.                 bowee.bow(bower);  
63.             }  
64.         }  
65.     }  
66.     **public** **static** **void** main(String[] args) {  
67.         **final** Friend alphonse = **new** Friend(&quot;Alphonse&quot;);  
68.         **final** Friend gaston = **new** Friend(&quot;Gaston&quot;);  
69.         **new** Thread(**new** BowLoop(alphonse, gaston)).start();  
70.         **new** Thread(**new** BowLoop(gaston, alphonse)).start();  
71.     }  
72. }  
</code></pre><h2>14.23 Executors</h2><p>In all of the previous examples, there&#x27;s a <strong>close connection between the task being done by a new thread, as defined by its Runnable object, and the thread itself</strong>, as defined by a Thread object. This works well for small applications, but in large-scale applications, it makes sense to <strong>separate thread management and creation</strong> from the rest of the application. Objects that encapsulate these functions are known as <em>executors</em>. The following subsections describe executors in detail.</p><h2>14.24 Executor Interfaces</h2><p>The java.util.concurrent package defines three executor interfaces:</p><ul><li>Executor, a simple interface that supports launching new tasks.</li><li>ExecutorService, a subinterface of Executor, <strong>which adds features that help manage the lifecycle</strong>, both of the individual tasks and of the executor itself.</li><li>ScheduledExecutorService, a <strong>subinterface of ExecutorService, supports future and/or periodic execution</strong> of tasks.</li></ul><p>Typically, variables that refer to executor objects are declared as one of these three interface types, not with an executor class type.</p><h3>14.24.1 The Executor Interface</h3><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html">Executor</a> interface provides a single method, execute, designed to be a drop-in replacement for a common thread-creation idiom. If r is a Runnable object, and e is an Executor object you can replace</p><pre><code class="language-java">1.  (**new** Thread(r)).start();  with
2.  e.execute(r);  
</code></pre><p>However, the definition of execute is less specific. The low-level idiom creates a new thread and launches it immediately. Depending on the Executor implementation, execute may do the same thing, but is more likely to use an existing worker thread to run r, or to place r in a queue to wait for a worker thread to become available. (We&#x27;ll describe worker threads in the section on <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html">Thread Pools</a>.)</p><p>The executor implementations in java.util.concurrent are designed to make full use of the more advanced ExecutorService and ScheduledExecutorService interfaces, although they also work with the base Executor interface.</p><h3>14.24.2 The ExecutorService Interface</h3><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a> interface supplements execute with a similar, but more versatile submit method. Like execute, <strong>submit accepts Runnable objects, but also accepts </strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html"><strong>Callable</strong></a> <strong>objects</strong>, which allow the task to return a value. The <strong>submit method returns a </strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html"><strong>Future</strong></a><strong> object, which is used to retrieve the Callable return value and to manage the status of both Callable and Runnable tasks</strong>.</p><p>ExecutorService also provides methods for submitting large collections of Callable objects. Finally, ExecutorService provides a number of methods for managing the shutdown of the executor. To support immediate shutdown, tasks should handle <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/interrupt.html">interrupts</a> correctly.</p><h3>14.24.3 The ScheduledExecutorService Interface</h3><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a> interface supplements the methods of its parent ExecutorService with schedule, which executes a Runnable or Callable task after a specified delay. In addition, the interface defines scheduleAtFixedRate and scheduleWithFixedDelay, which executes specified tasks repeatedly, at defined intervals.</p><h2>14.25 Thread Pools</h2><p>Most of the executor implementations in java.util.concurrent use <em>thread pools</em>, which consist of <em>worker threads</em>. This kind of thread exists separately from the Runnable and Callabletasks it executes and is often used to execute multiple tasks.</p><p>Using worker threads minimizes the overhead due to thread creation. Thread objects use a significant amount of memory, and in a large-scale application, allocating and deallocating many thread objects creates a significant memory management overhead.</p><p>One common type of thread pool is the <em>fixed thread pool</em>. This type of pool always has a specified number of threads running; if a thread is somehow terminated while it is still in use, it is automatically replaced with a new thread. Tasks are submitted to the pool via an internal queue, which holds extra tasks whenever there are more active tasks than threads.</p><p>An important advantage of the fixed thread pool is that applications using it <em>degrade gracefully</em>. To understand this, consider a web server application where each HTTP request is handled by a separate thread. If the application simply creates a new thread for every new HTTP request, and the system receives more requests than it can handle immediately, the application will suddenly stop responding to <em>all</em> requests when the overhead of all those threads exceed the capacity of the system. With a limit on the number of the threads that can be created, the application will not be servicing HTTP requests as quickly as they come in, but it will be servicing them as quickly as the system can sustain.</p><p>A simple way to create an executor that uses a fixed thread pool is to invoke the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newFixedThreadPool-int-">newFixedThreadPool</a> factory method in <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html">java.util.concurrent.Executors</a> This class also provides the following factory methods:</p><ul><li>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newCachedThreadPool-int-">newCachedThreadPool</a> method creates an executor with an expandable thread pool. This executor is suitable for applications that launch many short-lived tasks.</li><li>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newSingleThreadExecutor-int-">newSingleThreadExecutor</a> method creates an executor that executes a single task at a time.</li><li>Several factory methods are ScheduledExecutorService versions of the above executors.</li></ul><p>If none of the executors provided by the above factory methods meet your needs, constructing instances of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html">java.util.concurrent.ThreadPoolExecutor</a> or<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">java.util.concurrent.ScheduledThreadPoolExecutor</a> will give you additional options.</p><h2>14.26 Fork/Join</h2><p>The fork/join framework is an implementation of the ExecutorService interface that helps you take advantage of multiple processors. It is designed for work that can be broken into smaller pieces recursively. The goal is to use all the available processing power to enhance the performance of your application.</p><p>As with any ExecutorService implementation, the fork/join framework distributes tasks to worker threads in a thread pool. The fork/join framework is distinct because it uses a <em>work-stealing</em>algorithm. Worker threads that run out of things to do can steal tasks from other threads that are still busy.</p><p>The center of the fork/join framework is the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a> class, an extension of the AbstractExecutorService class. ForkJoinPool implements the core work-stealing algorithm and can execute <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html">ForkJoinTask</a> processes.</p><h3>14.26.1 Basic Use</h3><p>The first step for using the fork/join framework is to write code that performs a segment of the work. Your code should look similar to the following pseudocode:</p><pre><code class="language-java">1.  **if** (my portion of the work is small enough)  
2.      **do** the work directly  
3.      **else** split my work into two pieces invoke the two pieces and wait  
4.      **for**  
5.      the results  
</code></pre><p>Wrap this code in a ForkJoinTask subclass, typically using one of its more specialized types, either <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveTask.html">RecursiveTask</a> (which can return a result) or <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveAction.html">RecursiveAction</a>.</p><p>After your ForkJoinTask subclass is ready, create the object that represents all the work to be done and pass it to the invoke() method of a ForkJoinPool instance.</p><h3>14.26.2 Blurring for Clarity</h3><p>To help you understand how the fork/join framework works, consider the following example. Suppose that you want to blur an image. The original <em>source</em> image is represented by an array of integers, where each integer contains the color values for a single pixel. The blurred <em>destination</em> image is also represented by an integer array with the same size as the source.</p><p>Performing the blur is accomplished by working through the source array one pixel at a time. Each pixel is averaged with its surrounding pixels (the red, green, and blue components are averaged), and the result is placed in the destination array. Since an image is a large array, this process can take a long time. You can take advantage of concurrent processing on multiprocessor systems by implementing the algorithm using the fork/join framework. Here is one possible implementation:</p><pre><code class="language-java">1.  **public** **class** ForkBlur **extends** RecursiveAction {  
2.      **private** **int**[] mSource;  
3.      **private** **int** mStart;  
4.      **private** **int** mLength;  
5.      **private** **int**[] mDestination; // Processing window size; should be odd.  
6.      **private** **int** mBlurWidth = 15;  
7.      **public** ForkBlur(**int**[] src, **int** start, **int** length, **int**[] dst) {  
8.          mSource = src;  
9.          mStart = start;  
10.         mLength = length;  
11.         mDestination = dst;  
12.     }  
13.     **protected** **void** computeDirectly() {  
14.         **int** sidePixels = (mBlurWidth - 1) / 2;  
15.         **for** (**int** index = mStart; index &lt; mStart + mLength; index++) { // Calculate average.  
16.             **float** rt = 0, gt = 0, bt = 0;  
17.             **for** (**int** mi = -sidePixels; mi &lt;= sidePixels; mi++) {  
18.                 **int** mindex = Math.min(Math.max(mi + index, 0), mSource.length - 1);  
19.                 **int** pixel = mSource[mindex];  
20.                 rt += (**float**)((pixel &amp; 0x00ff0000) &gt;&gt; 16) / mBlurWidth;  
21.                 gt += (**float**)((pixel &amp; 0x0000ff00) &gt;&gt; 8) / mBlurWidth;  
22.                 bt += (**float**)((pixel &amp; 0x000000ff) &gt;&gt; 0) / mBlurWidth;  
23.             } // Reassemble destination pixel.  
24.             **int** dpixel = (0xff000000) \| (((**int**) rt) &lt;&lt; 16) \| (((**int**) gt) &lt;&lt; 8) \| (((**int**) bt) &lt;&lt; 0);  
25.             mDestination[index] = dpixel;  
26.         }  
27.     }\...  
</code></pre><p>Now you implement the abstract compute() method, which either performs the blur directly or splits it into two smaller tasks. A simple array length threshold helps determine whether the work is performed or split.</p><pre><code class="language-java">1.  **protected** **static** **int** sThreshold = 100000;  
2.  **protected** **void** compute() {  
3.      **if** (mLength &lt; sThreshold) {  
4.          computeDirectly();  
5.          **return**;  
6.      }  
7.      **int** split = mLength / 2;  
8.      invokeAll(**new** ForkBlur(mSource, mStart, split, mDestination), **new** ForkBlur(mSource, mStart + split, mLength - split, mDestination));  
9.  }  
</code></pre><p>If the previous methods are in a subclass of the RecursiveAction class, then setting up the task to run in a ForkJoinPool is straightforward, and involves the following steps:</p><ol><li>Create a task that represents all of the work to be done. // source image pixels are in src // destination image pixels are in dst  </li><li>    ForkBlur fb = <strong>new</strong> ForkBlur(src, 0, src.length, dst);  </li><li>Create the  ForkJoinPool  that will run the task.ForkJoinPool pool = <strong>new</strong> ForkJoinPool();  </li><li>Run the task.pool.invoke(fb);  </li></ol><p>For the full source code, including some extra code that creates the destination image file, see the <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/ForkBlur.java">ForkBlur</a> example.</p><h3>14.26.3 Standard Implementations</h3><p>Besides using the fork/join framework to implement custom algorithms for tasks to be performed concurrently on a multiprocessor system (such as the ForkBlur.java example in the previous section), there are some generally useful features in Java SE which are already implemented using the fork/join framework. One such implementation, introduced in Java SE 8, is used by the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html">java.util.Arrays</a> class for its parallelSort() methods. These methods are similar to sort(), but leverage concurrency via the fork/join framework. Parallel sorting of large arrays is faster than sequential sorting when run on multiprocessor systems. However, how exactly the fork/join framework is leveraged by these methods is outside the scope of the Java Tutorials. For this information, see the Java API documentation.</p><p>Another implementation of the fork/join framework is used by methods in the java.util.streams package, which is part of <a href="http://openjdk.java.net/projects/lambda/">Project Lambda</a> scheduled for the Java SE 8 release. For more information, see the <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Lambda Expressions</a> section.</p><h2>14.27 Concurrent Collections</h2><p>The java.util.concurrent package includes a number of additions to the Java Collections Framework. These are most easily categorized by the collection interfaces provided:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html">BlockingQueue</a> defines a first-in-first-out data structure that blocks or times out when you attempt to add to a full queue, or retrieve from an empty queue.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html">ConcurrentMap</a> is a subinterface of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">java.util.Map</a> that defines useful atomic operations. These operations remove or replace a key-value pair only if the key is present, or add a key-value pair only if the key is absent. Making these operations atomic helps avoid synchronization. The standard general-purpose implementation of ConcurrentMap is<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">ConcurrentHashMap</a>, which is a concurrent analog of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a>.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentNavigableMap.html">ConcurrentNavigableMap</a> is a subinterface of ConcurrentMap that supports approximate matches. The standard general-purpose implementation of ConcurrentNavigableMap is<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListMap.html">ConcurrentSkipListMap</a>, which is a concurrent analog of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html">TreeMap</a>.</li></ul><p>All of these collections help avoid <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/memconsist.html">Memory Consistency Errors</a> by defining a happens-before relationship between an operation that adds an object to the collection with subsequent operations that access or remove that object.</p><h2>14.28 Atomic Variables</h2><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html">java.util.concurrent.atomic</a> package defines classes that support atomic operations on single variables. All classes have get and set methods that work like reads and writes on volatile variables. That is, a set has a happens-before relationship with any subsequent get on the same variable. The atomic compareAndSet method also has these memory consistency features, as do the simple atomic arithmetic methods that apply to integer atomic variables.</p><p>To see how this package might be used, let&#x27;s return to the <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/Counter.java">Counter</a> class we originally used to demonstrate thread interference:</p><pre><code class="language-java">1.  **class** Counter {  
2.      **private** **int** c = 0;  
3.      **public** **void** increment() {  
4.          c++;  
5.      }  
6.      **public** **void** decrement() {  
7.          c--;  
8.      }  
9.      **public** **int** value() {  
10.         **return** c;  
11.     }  
12. }  
</code></pre><p>One way to make Counter safe from thread interference is to make its methods synchronized, as in <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/SynchronizedCounter.java">SynchronizedCounter</a>:</p><pre><code class="language-java">1.  **class** SynchronizedCounter {  
2.      **private** **int** c = 0;  
3.      **public** **synchronized** **void** increment() {  
4.          c++;  
5.      }  
6.      **public** **synchronized** **void** decrement() {  
7.          c--;  
8.      }  
9.      **public** **synchronized** **int** value() {  
10.         **return** c;  
11.     }  
12. }  
</code></pre><p>For this simple class, synchronization is an acceptable solution. But for a more complicated class, we might want to avoid the liveness impact of unnecessary synchronization. Replacing the intfield with an AtomicInteger allows us to prevent thread interference without resorting to synchronization, as in <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/AtomicCounter.java">AtomicCounter</a>:</p><pre><code class="language-java">1.  **import** java.util.concurrent.atomic.AtomicInteger;  
2.  **class** AtomicCounter {  
3.      **private** AtomicInteger c = **new** AtomicInteger(0);  
4.      **public** **void** increment() {  
5.          c.incrementAndGet();  
6.      }  
7.      **public** **void** decrement() {  
8.          c.decrementAndGet();  
9.      }  
10.     **public** **int** value() {  
11.         **return** c.get();  
12.     }  
13. }  
</code></pre><h2>14.29 Concurrent Random Numbers</h2><p>In JDK 7, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html">java.util.concurrent</a> includes a convenience class, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadLocalRandom.html">ThreadLocalRandom</a>, for applications that expect to use random numbers from multiple threads or ForkJoinTasks.</p><p>For concurrent access, using ThreadLocalRandom instead of Math.random() results in less contention and, ultimately, better performance.</p><p>All you need to do is call ThreadLocalRandom.current(), then call one of its methods to retrieve a random number. Here is one example:</p><pre><code class="language-java">1.  **int** r = ThreadLocalRandom.current().nextInt(4, 77);  
</code></pre><h2>14.30 Fail Fast and Fail safe Iterators</h2><p>In this article, I am going to explain how those collections behave which doesn&#x27;t iterate as fail-fast. First of all, there is no term as fail-safe given in many places as Java SE specifications does not use this term. I am using fail safe to segregate between Fail fast and Non fail-fast iterators.</p><p><strong>Concurrent Modification:</strong> Concurrent Modification in programming means to modify an object concurrently when another task is already running over it. For example, in Java to modify a collection when another thread is iterating over it. Some Iterator implementations (including those of all the general purpose collection implementations provided by the JRE) may choose to throw <em>ConcurrentModificationException</em> if this behavior is detected.</p><h3><strong>14.30.1 Fail Fast and Fail Safe Iterators in Java</strong></h3><p><a href="https://contribute.geeksforgeeks.org/iterators-in-java/">Iterators</a> in java are used to iterate over the Collection objects. Fail-Fast iterators immediately throw <em>ConcurrentModificationException</em> if there is <strong>structural modification</strong> of the collection. Structural modification means adding, removing or updating any element from collection while a thread is iterating over that collection. Iterator on ArrayList, HashMap classes are some examples of fail-fast Iterator.</p><p>Fail-Safe iterators don&#x27;t throw any exceptions if a collection is structurally modified while iterating over it. This is because, they operate on the clone of the collection, not on the original collection and that&#x27;s why they are called fail-safe iterators. Iterator on CopyOnWriteArrayList, ConcurrentHashMap classes are examples of fail-safe Iterator.</p><p>To know whether the collection is structurally modified or not, fail-fast iterators use an internal flag called <em>modCount</em> which is updated each time a collection is modified. Fail-fast iterators checks the <em>modCount</em> flag whenever it gets the next value (i.e. using <em>next()</em> method), and if it finds that the <em>modCount</em> has been modified after this iterator has been created, it throws <em>ConcurrentModificationException</em>.</p><pre><code class="language-java">1.  // Java code to illustrate // Fail Fast Iterator in Java  
2.  **import** java.util.HashMap;  
3.  **import** java.util.Iterator;  
4.  **import** java.util.Map;   
5.  **public** **class** FailFastExample {      
6.      **public** **static** **void** main(String[] args)     {          
7.          Map &lt; String, String &gt; cityCode = **new** HashMap &lt; String, String &gt; ();          
8.          cityCode.put(&quot;Delhi&quot;, &quot;India&quot;);          
9.          cityCode.put(&quot;Moscow&quot;, &quot;Russia&quot;);          
10.         cityCode.put(&quot;New York&quot;, &quot;USA&quot;);           
11.         Iterator iterator = cityCode.keySet().iterator();           
12.         **while** (iterator.hasNext()) {              
13.             System.out.println(cityCode.get(iterator.next()));              // adding an element to Map  
14.                          // exception will be thrown on next call  
15.                          // of next() method.  
16.                           
17.             cityCode.put(&quot;Istanbul&quot;, &quot;Turkey&quot;);          
18.         }      
19.     }  
20. }  
</code></pre><ol start="21"><li>India Exception <strong>in</strong> thread &quot;main&quot;  </li><li>java.util.ConcurrentModificationException at java.util.HashMap\$HashIterator.nextNode(HashMap.java: 1442) at java.util.HashMap\$KeyIterator.next(HashMap.java: 1466) at FailFastExample.main(FailFastExample.java: 18)  </li></ol><p>Important points of fail-fast iterators :</p><ul><li>These iterators throw ConcurrentModificationException if a collection is modified while iterating over it.</li><li>They use original collection to traverse over the elements of the collection.</li><li>These iterators don&#x27;t require extra memory.</li><li>Ex : Iterators returned by ArrayList, Vector, HashMap.</li></ul><p>Note 1(from java-docs): The fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw <em>ConcurrentModificationException</em> on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.</p><p>Note 2 : If you remove an element via Iterator <em>remove()</em> method, exception will not be thrown. However, in case of removing via a particular collection <em>remove()</em> method, <em>ConcurrentModificationException</em> will be thrown. Below code snippet will demonstrate this:</p><pre><code class="language-java">1.  // Java code to demonstrate remove // case in Fail-fast iterators  
2.     
3.  **import** java.util.ArrayList;  
4.  **import** java.util.Iterator;   
5.  **public** **class** FailFastExample {      
6.      **public** **static** **void** main(String[] args)     {          
7.          ArrayList &lt; Integer &gt; al = **new** ArrayList &lt; &gt; ();          
8.          al.add(1);          
9.          al.add(2);          
10.         al.add(3);          
11.         al.add(4);          
12.         al.add(5);           
13.         Iterator &lt; Integer &gt; itr = al.iterator();          
14.         **while** (itr.hasNext()) {              
15.             **if** (itr.next() == 2) {                 // will not throw Exception  
16.                                   
17.                 itr.remove();              
18.             }          
19.         }           
20.         System.out.println(al);           
21.         itr = al.iterator();          
22.         **while** (itr.hasNext()) {              
23.             **if** (itr.next() == 3) {                 // will throw Exception on  
24.                                  // next call of next() method  
25.                                   
26.                 al.remove(3);              
27.             }          
28.         }      
29.     }  
30. }
</code></pre><p>[1, 3, 4, 5]<!-- --> Exception <strong>in</strong> thread &quot;main&quot;  
31. java.util.ConcurrentModificationException at java.util.ArrayList\$Itr.checkForComodification(ArrayList.java: 901) at java.util.ArrayList\$Itr.next(ArrayList.java: 851) at FailFastExample.main(FailFastExample.java: 28)  </p><h3>14.30.2 Fail Safe Iterator</h3><p>First of all, there is no term as fail-safe given in many places as Java SE specifications does not use this term. I am using this term to demonstrate the difference between Fail Fast and Non-Fail Fast Iterator. These iterators make a copy of the internal collection (object array) and iterates over the copied collection. Any structural modification done to the iterator affects the copied collection, <strong>not original collection</strong>. So, original collection remains structurally <strong>unchanged</strong>.</p><ul><li>Fail-safe iterators allow modifications of a collection while iterating over it.</li><li>These iterators don&#x27;t throw any Exception if a collection is modified while iterating over it.</li><li>They use copy of original collection to traverse over the elements of the collection.</li><li>These iterators require extra memory for cloning of collection. Ex : ConcurrentHashMap, CopyOnWriteArrayList</li></ul><pre><code class="language-java">1.  // Java code to illustrate // Fail Safe Iterator in Java  
2.  **import** java.util.concurrent.CopyOnWriteArrayList;  
3.  **import** java.util.Iterator;   
4.  **class** FailSafe {      
5.      **public** **static** **void** main(String args[])     {          
6.          CopyOnWriteArrayList &lt; Integer &gt; list = **new** CopyOnWriteArrayList &lt; Integer &gt; (**new** Integer[] {  
7.              1, 3, 5, 8  
8.          });          
9.          Iterator itr = list.iterator();          
10.         **while** (itr.hasNext()) {              
11.             Integer no = (Integer) itr.next();              
12.             System.out.println(no);              
13.             **if** (no == 8)                  // This will not print,  
14.                              // hence it has created separate copy  
15.                              list.add(14);          
16.         }      
17.     }  
18. }  
</code></pre><ol start="19"><li>1 3 5 8  </li></ol><p>Also, those collections which don&#x27;t use fail-fast concept may not necessarily create clone/snapshot of it in memory to avoid ConcurrentModificationException. For example, in case of ConcurrentHashMap, it does not operate on a separate copy although it is not fail-fast. Instead, it has semantics that is described by the official specification as weakly consistent(memory consistency properties in Java). Below code snippet will demonstrate this:</p><h4>14.30.2.1 Example of Fail-Safe Iterator which does not create separate copy</h4><pre><code class="language-java">+-----------------------------------------------------------------------+
| 1.  // Java program to illu                                           |
| strate // Fail-Safe Iterator which // does not create separate copy   |
| 2.  **import** java.util.concurrent.ConcurrentHashMap;                |
| 3.  **import** java.util.Iterator;                                    |
| 4.  **public** **class** FailSafeItr {                                |
| 5.      **public** **static** **void** m                              |
| ain(String[] args)     {          // Creating a ConcurrentHashMap   |
| 6.                                                                    |
| 7.          ConcurrentHashMap &lt; String, Integer &gt;                   |
|  map = **new** ConcurrentHashMap &lt; String, Integer &gt; ();            |
| 8.          map.put(&quot;ONE&quot;, 1);                                      |
| 9.          map.put(&quot;TWO&quot;, 2);                                      |
| 10.         map.put(&quot;THREE&quot;, 3);                                    |
| 11.                                                                   |
|      map.put(&quot;FOUR&quot;, 4);          // Getting an Iterator from map   |
| 12.                                                                   |
| 13.         Iterator it = map.keySet().iterator();                    |
| 14.         **while** (it.hasNext()) {                                |
| 15.             String key = (String) it.next();                      |
| 16.             System.out.println(key + &quot; :                         |
|  &quot; + map.get(key));              // This will reflect in iterator.   |
| 17.                                                                   |
|                          // Hence, it has not created separate copy   |
| 18.                                                                   |
| 19.             map.put(&quot;SEVEN&quot;, 7);                                |
| 20.         }                                                         |
| 21.     }                                                             |
| 22. }                                                                 |
+-----------------------------------------------------------------------+
</code></pre><ol><li>Output ONE: 1 FOUR: 4 TWO: 2 THREE: 3 SEVEN: 7  </li></ol><p><strong>Note(from java-docs)</strong> : The iterators returned by ConcurrentHashMap is weakly consistent. This means that this iterator can tolerate concurrent modification, traverses elements as they existed when iterator was constructed and may (but not guaranteed to) reflect modifications to the collection after the construction of the iterator.</p><h3>14.30.3 Difference between Fail Fast Iterator and Fail Safe Iterator</h3><p>The major difference is fail-safe iterator doesn&#x27;t throw any Exception, contrary to fail-fast Iterator.This is because they work on a clone of Collection instead of the original collection and that&#x27;s why they are called as the fail-safe iterator.</p><h2>14.31 Further Reading</h2><ul><li><em>Concurrent Programming in Java: Design Principles and Pattern (2nd Edition)</em> by Doug Lea. A comprehensive work by a leading expert, who&#x27;s also the architect of the Java platform&#x27;s concurrency framework.</li><li><em>Java Concurrency in Practice</em> by Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea. A practical guide designed to be accessible to the novice.</li><li><em>Effective Java Programming Language Guide (2nd Edition)</em> by Joshua Bloch. Though this is a general programming guide, its chapter on threads contains essential &quot;best practices&quot; for concurrent programming.</li><li><em>Concurrency: State Models &amp; Java Programs (2nd Edition)</em>, by Jeff Magee and Jeff Kramer. An introduction to concurrent programming through a combination of modeling and practical examples.</li><li><a href="http://sourceforge.net/projects/javaconcurrenta/"><em>Java Concurrent Animated</em></a><em>:</em> Animations that show usage of concurrency features.</li></ul><h1>15 Oracle Official Code Standard</h1><p>Oracle official style guide for the Java Programming Language is a standard followed by developers at Oracle and</p><p>recommended to be followed by any other Java developer. It covers filenames, file organization, indentation,</p><p>comments, declarations, statements, white space, naming conventions, programming practices and includes a code</p><p>example.</p><p>[<a href="https://cr.openjdk.java.net/~alundblad/styleguide/index-v6.html">Java Style Guidelines</a>]</p><h2>15.1 Naming Conventions</h2><h3>15.1.1 Package names</h3><ul><li>Package names should be all lower case without underscores or other special characters.</li><li>Package names begin with the reversed authority part of the web address of the company of the developer.</li><li>This part can be followed by project/program structure dependent package substructure.</li><li>Don&#x27;t use plural form. Follow the convention of the standard API which uses for instance java.lang.annotation and not java.lang.annotations.</li><li>Examples: com.yourcompany.widget.button, com.yourcompany.core.api</li></ul><h3>15.1.2 Class, Interface and Enum Names</h3><ul><li>Class and enum names should typically be nouns.</li><li>Interface names should typically be nouns or adjectives ending with ...able.</li><li>Use mixed case with the first letter in each word in upper case (i.e. CamelCase).</li><li>Match the regular expression \^<!-- -->[A-Z][a-zA-Z0-9]<!-- -->*<!-- -->\$.</li><li>Use whole words and avoid using abbreviations unless the abbreviation is more widely used than the long form.</li><li>Format an abbreviation as a word if the it is part of a longer class name.</li><li>Examples: ArrayList, BigInteger, ArrayIndexOutOfBoundsException, Iterable.</li></ul><h3>15.1.3 Method Names</h3><p>Method names should typically be verbs or other descriptions of actions</p><ul><li>They should match the regular expression \^<!-- -->[a-z][a-zA-Z0-9]<!-- -->*<!-- -->\$.</li><li>Use mixed case with the first letter in lower case.</li><li>Examples: toString, hashCode</li></ul><h3>15.1.4 Variables</h3><p>Variable names should be in mixed case with the first letter in lower case</p><ul><li>Match the regular expression \^<!-- -->[a-z][a-zA-Z0-9]<!-- -->*<!-- -->\$</li><li>Further recommendation: <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html">Variables</a></li><li>Examples: elements, currentIndex</li></ul><h3>15.1.5 Type Variables</h3><p>For simple cases where there are few type variables involved use a single upper case letter.</p><ul><li>Match the regular expression \^<!-- -->[A-Z][0-9]<!-- -->?\$</li><li>If one letter is more descriptive than another (such as K and V for keys and values in maps or R for a function return type) use that, otherwise use T.</li><li>For complex cases where single letter type variables become confusing, use longer names written in all capital letters and use underscore (<!-- -->_<!-- -->) to separate words.</li><li>Examples: T, V, SRC_VERTEX</li></ul><h3>15.1.6 Constants</h3><p>Constants (static final fields whose content is immutable, by language rules or by convention) should be named with all capital letters and underscore (<!-- -->_<!-- -->) to separate words.</p><ul><li>Match the regular expression \^<!-- -->[A-Z][A-Z0-9]<!-- -->*<!-- -->(<!-- -->_<!-- -->[A-Z0-9]<!-- -->+)<!-- -->*<!-- -->\$</li><li>Examples: BUFFER_SIZE, MAX_LEVEL</li></ul><h3>15.1.7 Other guidelines on naming</h3><ul><li>Avoid hiding/shadowing methods, variables and type variables in outer scopes.</li><li>Let the verbosity of the name correlate to the size of the scope. (For instance, use descriptive names for</li><li>fields of large classes and brief names for local short-lived variables.)</li><li>When naming public static members, let the identifier be self descriptive if you believe they will be statically</li><li>imported.</li><li>Further reading: <a href="http://cr.openjdk.java.net/~alundblad/styleguide/index-v6.html#toc-naming">Naming Section</a> (in the official Java Style Guide)</li></ul><h2>15.2 Class Structure</h2><h2>15.3 Order of class members</h2><p>Class members should be ordered as follows:</p><ol><li>Fields (in order of public, protected and private)</li><li>Constructors</li><li>Factory methods</li><li>Other Methods (in order of public, protected and private)</li></ol><p>Ordering fields and methods primarily by their access modifiers or identifier is not required.</p><p>Here is an example of this order:</p><pre><code class="language-java">+-----------------------------------------------------------------------+
| class Example {\                                                      |
| private int i;\                                                       |
| Example(int i) {\                                                     |
| this.i = i;\                                                          |
| }\                                                                    |
| static Example getExample(int i) {\                                   |
| return new Example(i);\                                               |
| }\                                                                    |
| \@Override\                                                           |
| public String toString() {\                                           |
| return &quot;An example [&quot; + i + &quot;]&quot;;\                               |
| }                                                                     |
|                                                                       |
| } 
</code></pre><h3>15.3.1 Grouping of class members</h3><ul><li>Related fields should be grouped together.</li><li>A nested type may be declared right before its first use; otherwise it should be declared before the fields.</li><li>Constructors and overloaded methods should be grouped together by functionality and ordered with</li><li>increasing arity. This implies that delegation among these constructs flow downward in the code. Constructors should be grouped together without other members between.</li><li>Overloaded variants of a method should be grouped together without other members between.</li></ul><h2>15.4 Annotations</h2><p>Declaration annotations should be put on a separate line from the declaration being annotated.</p><pre><code class="language-java">+-----------------------------------------------------------------------+
| \@SuppressWarnings(&quot;unchecked&quot;)\                                    |
| public T[] toArray(T[] typeHolder) {\                             |
| \...\                                                                 |
| }                                                                     |
+-----------------------------------------------------------------------
</code></pre><p>However, few or short annotations annotating a single-line method may be put on the same line as the method if it improves readability. For example, one may write:</p><pre><code class="language-java">|                                              |
|----------------------------------------------|
| \@Nullable String getName() { return name; } |
</code></pre><p>For a matter of consistency and readability, either all annotations should be put on the same line or each annotation should be put on a separate line.</p><pre><code class="language-java">+-----------------------------------------------------------------------+
| // Bad.\                                                              |
| \@Deprecated \@SafeVarargs\                                           |
| \@CustomAnnotation\                                                   |
| public final Tuple&lt;T&gt; extend(T\... elements) {\                     |
| \...\                                                                 |
| }\                                                                    |
| // Even worse.\                                                       |
| \@Deprecated \@SafeVarargs\                                           |
| \@CustomAnnotation public final Tuple&lt;T&gt; extend(T\... elements) {\  |
| \...\                                                                 |
| }\                                                                    |
| // Good.\                                                             |
| \@Deprecated\                                                         |
| \@SafeVarargs\                                                        |
| \@CustomAnnotation\                                                   |
| public final Tuple&lt;T&gt; extend(T\... elements) {\                     |
| \...\                                                                 |
| }\                                                                    |
| // Good.\                                                             |
| \@Deprecated \@SafeVarargs \@CustomAnnotation\                        |
| public final Tuple&lt;T&gt; extend(T\... elements) {\                     |
| \...\                                                                 |
| }                                                                     |
+-----------------------------------------------------------------------```

## 15.5 Import statements
```java
+-----------------------------------------------------------------------+
| // First java/javax packages\                                         |
| import java.util.ArrayList;\                                          |
| import javax.tools.JavaCompiler;\                                     |
| // Then third party libraries\                                        |
| import com.fasterxml.jackson.annotation.JsonProperty;\                |
| // Then project imports\                                              |
| import com.example.my.package.ClassA;\                                |
| import com.example.my.package.ClassB;\                                |
| // Then static imports (in the same order as above)\                  |
| import static java.util.stream.Collectors.toList;                     |
+-----------------------------------------------------------------------
</code></pre><ul><li>Import statements should be sorted...<ul><li>...primarily by non-static / static with non-static imports first.</li><li>...secondarily by package origin according to the following order<ul><li>java packages</li><li>javax packages</li><li>external packages (e.g. org.xml)</li><li>internal packages (e.g. com.sun)</li></ul></li><li>...tertiary by package and class identifier in lexicographical order</li></ul></li><li>Import statements should not be line wrapped, regardless of whether it exceeds the recommended maximum length of a line.</li><li>No unused imports should be present.</li></ul><h3>15.5.1 Wildcard imports</h3><ul><li>Wildcard imports should in general not be used.</li><li>When importing a large number of closely-related classes (such as implementing a visitor over a tree with dozens of distinct &quot;node&quot; classes), a wildcard import may be used.</li><li>In any case, no more than one wildcard import per file should be used.</li></ul><h2>15.6 Braces</h2><pre><code class="language-java">+-----------------------------------------------------------------------+
| class Example {\                                                      |
| void method(boolean error) {\                                         |
| if (error) {\                                                         |
| Log.error(&quot;Error occurred!&quot;);\                                      |
| System.out.println(&quot;Error!&quot;);\                                      |
| } else { // Use braces since the other block uses braces.\            |
| System.out.println(&quot;No error&quot;);\                                    |
| }\                                                                    |
| }\                                                                    |
| }                                                                     |
+-----------------------------------------------------------------------+
</code></pre><ul><li>Opening braces should be put on the end of the current line rather than on a line by its own.</li><li>There should be a new line in front of a closing brace unless the block is empty (see Short Forms below)</li><li>Braces are recommended even where the language makes them optional, such as single-line if and loop bodies.<ul><li>If a block spans more than one line (including comments) it must have braces.</li><li>If one of the blocks in a if / else statement has braces, the other block must too.</li><li>If the block comes last in an enclosing block, it must have braces.</li></ul></li><li>The else, catch and the while keyword in do...while loops go on the same line as the closing brace of the preceding block.</li></ul><h3>15.6.1 Short forms</h3><pre><code class="language-java">+-----------------------------------------------------------------------+
| enum Response { YES, NO, MAYBE }\                                     |
| public boolean isReference() { return true; }                         |
+-----------------------------------------------------------------------+
</code></pre><p>The above recommendations are intended to improve uniformity (and thus increase familiarity / readability). In some cases &quot;short forms&quot; that deviate from the above guidelines are just as readable and may be used instead. These cases include for instance simple enum declarations and trivial methods and lambda expressions.</p><h2>15.7 Redundant Parentheses</h2><pre><code class="language-java">return flag ? &quot;yes&quot; : &quot;no&quot;;

String cmp = (flag1 != flag2) ? &quot;not equal&quot; : &quot;equal&quot;;

// Don&#x27;t do this

return (flag ? &quot;yes&quot; : &quot;no&quot;);
</code></pre><ul><li>Redundant grouping parentheses (i.e. parentheses that does not affect evaluation) may be used if they improve readability.</li><li>Redundant grouping parentheses should typically be left out in shorter expressions involving common operators but included in longer expressions or expressions involving operators whose precedence and associativity is unclear without parentheses. Ternary expressions with non-trivial conditions belong to the latter.</li><li>The entire expression following a return keyword must not be surrounded by parentheses.</li></ul><h2>15.8 Modifiers</h2><pre><code class="language-java">+-----------------------------------------------------------------------+
| class ExampleClass {\                                                 |
| // Access modifiers first (don&#x27;t do for instance &quot;static public&quot;)\ |
| public static void main(String[] args) {\                           |
| System.out.println(&quot;Hello World&quot;);\                                 |
| }\                                                                    |
| }\                                                                    |
| interface ExampleInterface {\                                         |
| // Avoid &#x27;public&#x27; and &#x27;abstract&#x27; since they are implicit\         |
| void sayHello();\                                                     |
| }                                                                     |
+-----------------------------------------------------------------------+
</code></pre><ul><li>Modifiers should go in the following order<ul><li>Access modifier (public / private / protected)</li><li>abstract</li><li>static</li><li>final</li><li>transient</li><li>volatile</li><li>default</li><li>synchronized</li><li>native</li><li>strictfp</li></ul></li><li>Modifiers should not be written out when they are implicit. For example, interface methods should neither be declared public nor abstract, and nested enums and interfaces should not be declared static.</li><li>Method parameters and local variables should not be declared final unless it improves readability or documents an actual design decision.</li><li>Fields should be declared final unless there is a compelling reason to make them mutable.</li></ul><h2>15.9 Indentation</h2><ul><li>Indentation level is four spaces.</li><li>Only space characters may be used for indentation. No tabs.</li><li>Empty lines must not be indented. (This is implied by the no trailing white space rule.)</li><li>case lines should be indented with four spaces, and statements within the case should be indented with another four spaces.</li></ul><p>Refer to Wrapping statements for guidelines on how to indent continuation lines.</p><h2>15.10 Literals</h2><pre><code class="language-java">+-----------------------------------------------------------------------+
| long l = 5432L;\                                                      |
| int i = 0x123 + 0xABC;\                                               |
| byte b = 0b1010;\                                                     |
| float f1 = 1 / 5432f;\                                                |
| float f2 = 0.123e4f;\                                                 |
| double d1 = 1 / 5432d; // or 1 / 5432.0\                              |
| double d2 = 0x1.3p2;                                                  |
+-----------------------------------------------------------------------+
</code></pre><ul><li>long literals should use the upper case letter L suffix.</li><li>Hexadecimal literals should use upper case letters A-F.</li><li>All other numerical prefixes, infixes, and suffixes should use lowercase letters.</li></ul><h2>15.11 Package declaration</h2><pre><code class="language-java">package com.example.my.package;
</code></pre><p>The package declaration should not be line wrapped, regardless of whether it exceeds the recommended maximum length of a line.</p><h2>15.12 Lambda Expressions</h2><pre><code class="language-java">+-----------------------------------------------------------------------+
| Runnable r = () -&gt; System.out.println(&quot;Hello World&quot;);\             |
| Supplier&lt;String&gt; c = () -&gt; &quot;Hello World&quot;;\                       |
| // Collection::contains is a simple unary method and its behavior is\ |
| // clear from the context. A method reference is preferred here.\     |
| appendFilter(goodStrings::contains);\                                 |
| // A lambda expression is easier to understand than just tempMap::put |
| in this case\                                                         |
| trackTemperature((time, temp) -&gt; tempMap.put(time, temp));           |
+-----------------------------------------------------------------------+
</code></pre><ul><li>Expression lambdas are preferred over single-line block lambdas.</li><li>Method references should generally be preferred over lambda expressions.</li><li>For bound instance method references, or methods with arity greater than one, a lambda expression may be easier to understand and therefore preferred. Especially if the behavior of the method is not clear from the context.</li><li>The parameter types should be omitted unless they improve readability.</li><li>If a lambda expression stretches over more than a few lines, consider creating a method.</li></ul><h2>15.13 Java Source Files</h2><ul><li>All lines must be terminated with a line feed character (LF, ASCII value 10) and not for instance CR or CR+LF.</li><li>There may be no trailing white space at the end of a line.</li><li>The name of a source file must equal the name of the class it contains followed by the .java extension, even for files that only contain a package private class. This does not apply to files that do not contain any class declarations, such as package-info.java.</li></ul><h2>15.14 Wrapping statements</h2><ul><li>Source code and comments should generally not exceed 80 characters per line and rarely if ever exceed 100 characters per line, including indentation.</li></ul><p>The character limit must be judged on a case by case basis. What really matters is the semantical &quot;density&quot; and readability of the line. Making lines gratuitously long makes them hard to read; similarly, making &quot;heroic attempts&quot; to fit them into 80 columns can also make them hard to read. The flexibility outlined here aims to enable developers to avoid these extremes, not to maximize use of monitor real-estate.</p><ul><li>URLs or example commands should not be wrapped.</li></ul><pre><code class="language-java">+-----------------------------------------------------------------------+
| // Ok even though it might exceed max line width when indented.\      |
| Error e = isTypeParam\                                                |
| ?                                                                     |
| Errors.InvalidRepeatableAnnotationNotApplicable(targetContainerType,  |
| on)\                                                                  |
| :                                                                     |
| Errors.Inva                                                           |
| lidRepeatableAnnotationNotApplicableInContext(targetContainerType));\ |
| // Wrapping preferable\                                               |
| String pretty = Stream.of(args)\                                      |
| .map(Argument::prettyPrint)\                                          |
| .collectors(joining(&quot;, &quot;));\                                        |
| // Too strict interpretation of max line width. Readability suffers.\ |
| Error e = isTypeParam\                                                |
| ? Errors.InvalidRepeatableAnnotationNotApplicable(\                   |
| targetContainerType, on)\                                             |
| : Errors.InvalidRepeatableAnnotationNotApplicableInContext(\          |
| targetContainerType);\                                                |
| // Should be wrapped even though it fits within the character limit\  |
| String pretty =                                                       |
| Stream.of(args).map(Argument::prettyPrint).collectors(joining(&quot;,     |
| &quot;));                                                                 |
+-----------------------------------------------------------------------+
</code></pre><ul><li>Wrapping at a higher syntactical level is preferred over wrapping at a lower syntactical level.</li><li>There should be at most 1 statement per line.</li><li>A continuation line should be indented in one of the following four ways<ul><li>Variant 1: With 8 extra spaces relative to the indentation of the previous line.</li><li>Variant 2: With 8 extra spaces relative to the starting column of the wrapped expression.</li><li>Variant 3: Aligned with previous sibling expression (as long as it is clear that it&#x27;s a continuation line)</li><li>Variant 4: Aligned with previous method call in a chained expression.</li></ul></li></ul><h2>15.15 Wrapping Method Declarations</h2><pre><code class="language-java">+-----------------------------------------------------------------------+
| int someMethod(String aString,\                                       |
| List&lt;Integer&gt; aList,\                                               |
| Map&lt;String, String&gt; aMap,\                                          |
| int anInt,\                                                           |
| long aLong,\                                                          |
| Set&lt;Number&gt; aSet,\                                                  |
| double aDouble) {\                                                    |
| \...\                                                                 |
| }\                                                                    |
| int someMethod(String aString, List&lt;Integer&gt; aList,\                |
| Map&lt;String, String&gt; aMap, int anInt, long aLong,\                   |
| double aDouble, long aLong) {\                                        |
| \...\                                                                 |
| }\                                                                    |
| int someMethod(String aString,\                                       |
| List&lt;Map&lt;Integer, StringBuffer&gt;&gt; aListOfMaps,\                    |
| Map&lt;String, String&gt; aMap)\                                          |
| throws IllegalArgumentException {\                                    |
| \...\                                                                 |
| }\                                                                    |
| int someMethod(String aString, List&lt;Integer&gt; aList,\                |
| Map&lt;String, String&gt; aMap, int anInt)\                               |
| throws IllegalArgumentException {\                                    |
| \...\                                                                 |
| }                                                                     |
+-----------------------------------------------------------------------+
</code></pre><ul><li>Method declarations can be formatted by listing the arguments vertically, or by a new line and +8 extra spaces</li><li>If a throws clause needs to be wrapped, put the line break in front of the throws clause and make sure it stands out from the argument list, either by indenting +8 relative to the function declaration, or +8 relative to the previous line.</li></ul><h2>15.16 Wrapping Expressions</h2><ul><li>If a line approaches the maximum character limit, always consider breaking it down into multiple statements / expressions instead of wrapping the line.</li><li>Break before operators.</li><li>Break before the . in chained method calls.</li></ul><pre><code class="language-java">+-----------------------------------------------------------------------+
| popupMsg(&quot;Inbox notification: You have &quot;\                           |
| + newMsgs + &quot; new messages&quot;);\                                      |
| // Don&#x27;t! Looks like two arguments\                                  |
| popupMsg(&quot;Inbox notification: You have &quot; +\                         |
| newMsgs + &quot; new messages&quot;);                                         |
+-----------------------------------------------------------------------+
</code></pre><h2>15.17 Whitespace</h2><h3>15.17.1 Vertical Whitespace</h3><ul><li>A single blank line should be used to separate...<ul><li>Package declaration</li><li>Class declarations</li><li>Constructors</li><li>Methods</li><li>Static initializers</li><li>Instance initializers</li></ul></li><li>...and may be used to separate logical groups of<ul><li>import statements</li><li>fields</li><li>statements</li></ul></li><li>Multiple consecutive blank lines should only be used to separate groups of related members and not as the standard inter-member spacing.</li></ul><h3>15.17.2 Horizontal Whitespace</h3><ul><li>A single space should be used...<ul><li>To separate keywords from neighboring opening or closing brackets and braces</li><li>Before and after all binary operators and operator like symbols such as arrows in lambda expressions and the colon in enhanced for loops (but not before the colon of a label)</li><li>After // that starts a comment.</li><li>After commas separating arguments and semicolons separating the parts of a for loop.</li><li>After the closing parenthesis of a cast.</li></ul></li><li>In variable declarations it is not recommended to align types and variables.</li></ul><h2>15.18 Special Characters</h2><ul><li>Apart from LF the only allowed white space character is Space (ASCII value 32). Note that this implies that other white space characters (in, for instance, string and character literals) must be written in escaped form.</li><li>\<!-- -->&#x27;, <!-- -->\<!-- -->&quot;, <!-- -->\<!-- -->\<!-- -->, <!-- -->\<!-- -->t, <!-- -->\<!-- -->b, <!-- -->\<!-- -->r, <!-- -->\<!-- -->f, and <!-- -->\<!-- -->n should be preferred over corresponding octal (e.g. <!-- -->\<!-- -->047) or Unicode (e.g. <!-- -->\<!-- -->u0027) escaped characters.</li><li>Should there be a need to go against the above rules for the sake of testing, the test should generate the required input programmatically.</li></ul><h2>15.19 Variable Declarations</h2><ul><li>One variable per declaration (and at most one declaration per line)</li><li>Square brackets of arrays should be at the type (String[] args) and not on the variable (String args[]).</li><li>Declare a local variable right before it is first used, and initialize it as close to the declaration as possible.</li></ul><h1>16 The Platform Environment</h1><p>An application runs in a <em>platform environment</em>, defined by the underlying operating system, the Java virtual machine, the class libraries, and various configuration data supplied when the application is launched. This lesson describes some of the APIs an application uses to examine and configure its platform environment. The lesson consists of three sections:</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/environment/config.html">Configuration Utilities</a> describes APIs used to access configuration data supplied when the application is deployed, or by the application&#x27;s user.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/environment/system.html">System Utilities</a> describes miscellaneous APIs defined in the System and Runtime classes.</li><li><a href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html">PATH and CLASSPATH</a> describes environment variables used to configure JDK development tools and other applications.</li></ul><h2>16.1 Configuration Utilities</h2><p>This section describes some of the configuration utilities that help an application access its startup context.</p><h3>16.1.1 Properties</h3><p><em>Properties</em> are configuration values managed as <em>key/value pairs</em>. In each pair, the key and value are both <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html">String</a> values. The key identifies, and is used to retrieve, the value, much as a variable name is used to retrieve the variable&#x27;s value. For example, an application capable of downloading files might use a property named &quot;download.lastDirectory&quot; to keep track of the directory used for the last download.</p><p>To manage properties, create instances of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html">java.util.Properties</a>. This class provides methods for the following:</p><ul><li>loading key/value pairs into a Properties object from a stream,</li><li>retrieving a value from its key,</li><li>listing the keys and their values,</li><li>enumerating over the keys, and</li><li>saving the properties to a stream.</li></ul><p>For an introduction to streams, refer to the section <a href="https://docs.oracle.com/javase/tutorial/essential/io/streams.html">I/O Streams</a> in the <a href="https://docs.oracle.com/javase/tutorial/essential/io/index.html">Basic I/O</a> lesson.</p><p>Properties extends <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Hashtable.html">java.util.Hashtable</a>. Some of the methods inherited from Hashtable support the following actions:</p><ul><li>testing to see if a particular key or value is in the Properties object,</li><li>getting the current number of key/value pairs,</li><li>removing a key and its value,</li><li>adding a key/value pair to the Properties list,</li><li>enumerating over the values or the keys,</li><li>retrieving a value by its key, and</li><li>finding out if the Properties object is empty.</li></ul><p><strong>Security Considerations:</strong> Access to properties is subject to approval by the current security manager. The example code segments in this section are assumed to be in standalone applications, which, by default, have no security manager. The same code in an applet may not work depending on the browser in which it is running. See <a href="https://docs.oracle.com/javase/tutorial/deployment/applet/security.html">What Applets Can and Cannot Do</a> in the <a href="https://docs.oracle.com/javase/tutorial/deployment/applet/index.html">Java Applets</a> lesson for information about security restrictions on applets.</p><p>The System class maintains a Properties object that defines the configuration of the current working environment. For more about these properties, see <a href="https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html">System Properties</a>. The remainder of this section explains how to use properties to manage application configuration.</p><h4>16.1.1.1 Properties in the Application Life Cycle</h4><p>The following figure illustrates how a typical application might manage its configuration data with a Properties object over the course of its execution.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8RAwAIwgLhRLs1HgAAAABJRU5ErkJggg==" alt="Possible lifecycle of a Properties object"/></p><ul><li>Starting Up
The actions given in the first three boxes occur when the application is starting up. First, the application loads the default properties from a well-known location into a Properties object. Normally, the default properties are stored in a file on disk along with the .class and other resource files for the application.
Next, the application creates another Properties object and loads the properties that were saved from the last time the application was run. Many applications store properties on a per-user basis, so the properties loaded in this step are usually in a specific file in a particular directory maintained by this application in the user&#x27;s home directory. Finally, the application uses the default and remembered properties to initialize itself.
The key here is consistency. The application must always load and save properties to the same location so that it can find them the next time it&#x27;s executed.</li><li>Running
During the execution of the application, the user may change some settings, perhaps in a Preferences window, and the Properties object is updated to reflect these changes. If the users changes are to be remembered in future sessions, they must be saved.</li><li>Exiting
Upon exiting, the application saves the properties to its well-known location, to be loaded again when the application is next started up.</li></ul><h4>16.1.1.2 Setting Up the Properties Object</h4><p>The following Java code performs the first two steps described in the previous section: loading the default properties and loading the remembered properties:</p><pre><code class="language-java">// create and load default properties

Properties defaultProps = new Properties();

FileInputStream in = new FileInputStream(&quot;defaultProperties&quot;);

defaultProps.load(in);

in.close();

// create application properties with default

Properties applicationProps = new Properties(defaultProps);

// now load properties

// from last invocation

in = new FileInputStream(&quot;appProperties&quot;);

applicationProps.load(in);

in.close();
</code></pre><p>First, the application sets up a default Properties object. This object contains the set of properties to use if values are not explicitly set elsewhere. Then the load method reads the default values from a file on disk named defaultProperties.</p><p>Next, the application uses a different constructor to create a second Properties object, applicationProps, whose default values are contained in defaultProps. The defaults come into play when a property is being retrieved. If the property can&#x27;t be found in applicationProps, then its default list is searched.</p><p>Finally, the code loads a set of properties into applicationProps from a file named appProperties. The properties in this file are those that were saved from the application the last time it was invoked, as explained in the next section.</p><h4>16.1.1.3 Saving Properties</h4><p>The following example writes out the application properties from the previous example using Properties.store. The default properties don&#x27;t need to be saved each time because they never change.</p><pre><code class="language-java">FileOutputStream out = new FileOutputStream(&quot;appProperties&quot;);

applicationProps.store(out, &quot;---No Comment---&quot;);

out.close();
</code></pre><p>The store method needs a stream to write to, as well as a string that it uses as a comment at the top of the output.</p><h4>16.1.1.4 Getting Property Information</h4><p>Once the application has set up its Properties object, the application can query the object for information about various keys and values that it contains. An application gets information from a Properties object after start up so that it can initialize itself based on choices made by the user. The Properties class has several methods for getting property information:</p><ul><li>contains(Object value) and containsKey(Object key)
Returns true if the value or the key is in the Properties object. Properties inherits these methods from Hashtable. Thus they accept Object arguments, but only String values should be used.</li><li>getProperty(String key) and getProperty(String key, String default)
Returns the value for the specified property. The second version provides for a default value. If the key is not found, the default is returned.</li><li>list(PrintStream s) and list(PrintWriter w)
Writes all of the properties to the specified stream or writer. This is useful for debugging.</li><li>elements(), keys(), and propertyNames()
Returns an Enumeration containing the keys or values (as indicated by the method name) contained in the Properties object. The keys method only returns the keys for the object itself; the propertyNames method returns the keys for default properties as well.</li><li>stringPropertyNames()
Like propertyNames, but returns a <code>Set&lt;String&gt;</code>, and only returns names of properties where both key and value are strings. Note that the Set object is not backed by the Properties object, so changes in one do not affect the other.</li><li>size()
Returns the current number of key/value pairs.</li></ul><h4>16.1.1.5 Setting Properties</h4><p>A user&#x27;s interaction with an application during its execution may impact property settings. These changes should be reflected in the Properties object so that they are saved when the application exits (and calls the store method). The following methods change the properties in a Properties object:</p><ul><li>setProperty(String key, String value)
Puts the key/value pair in the Properties object.</li><li>remove(Object key)
Removes the key/value pair associated with key.</li></ul><p><strong>Note:</strong> Some of the methods described above are defined in Hashtable, and thus accept key and value argument types other than String. Always use Strings for keys and values, even if the method allows other types. Also do not invoke Hashtable.set or Hastable.setAll on Properties objects; always use Properties.setProperty.</p><h3>16.1.2 Command-Line Arguments</h3><p>A Java application can accept any number of arguments from the command line. This allows the user to specify configuration information when the application is launched.</p><p>The user enters command-line arguments when invoking the application and specifies them after the name of the class to be run. For example, suppose a Java application called Sort sorts lines in a file. To sort the data in a file named friends.txt, a user would enter:</p><p>java Sort friends.txt</p><p>When an application is launched, the runtime system passes the command-line arguments to the application&#x27;s main method via an array of Strings. In the previous example, the command-line arguments passed to the Sort application in an array that contains a single String: &quot;friends.txt&quot;.</p><h4>16.1.2.1 Echoing Command-Line Arguments</h4><p>The <a href="https://docs.oracle.com/javase/tutorial/essential/environment/examples/Echo.java">Echo</a> example displays each of its command-line arguments on a line by itself:</p><p>public class Echo {</p><p>public static void main (String[] args) {</p><p>for (String s: args) {</p><p>System.out.println(s);</p><p>}</p><p>}</p><p>}</p><p>The following example shows how a user might run Echo. User input is in italics.</p><p><em>java Echo Drink Hot Java</em></p><p>Drink</p><p>Hot</p><p>Java</p><p>Note that the application displays each word --- Drink, Hot, and Java --- on a line by itself. This is because the space character separates command-line arguments. To have Drink, Hot, and Java interpreted as a single argument, the user would join them by enclosing them within quotation marks.</p><p><em>java Echo &quot;Drink Hot Java&quot;</em></p><p>Drink Hot Java</p><h4>16.1.2.2 Parsing Numeric Command-Line Arguments</h4><p>If an application needs to support a numeric command-line argument, it must convert a String argument that represents a number, such as &quot;34&quot;, to a numeric value. Here is a code snippet that converts a command-line argument to an int:</p><p>int firstArg;</p><p>if (args.length &gt; 0) {</p><p>try {</p><p>firstArg = Integer.parseInt(args<!-- -->[0]<!-- -->);</p><p>} catch (NumberFormatException e) {</p><p>System.err.println(&quot;Argument&quot; + args<!-- -->[0]<!-- --> + &quot; must be an integer.&quot;);</p><p>System.exit(1);</p><p>}</p><p>}</p><p>parseInt throws a NumberFormatException if the format of args<!-- -->[0]<!-- --> isn&#x27;t valid. All of the Number classes --- Integer, Float, Double, and so on --- have parseXXX methods that convert a String representing a number to an object of their type.</p><h3>16.1.3 Environment Variables</h3><p>Many operating systems use <em>environment variables</em> to pass configuration information to applications. Like properties in the Java platform, environment variables are key/value pairs, where both the key and the value are strings. The conventions for setting and using environment variables vary between operating systems, and also between command line interpreters. To learn how to pass environment variables to applications on your system, refer to your system documentation.</p><h4>16.1.3.1 Querying Environment Variables</h4><p>On the Java platform, an application uses <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getenv--">System.getenv</a> to retrieve environment variable values. Without an argument, getenv returns a read-only instance of java.util.Map, where the map keys are the environment variable names, and the map values are the environment variable values. This is demonstrated in the <a href="https://docs.oracle.com/javase/tutorial/essential/environment/examples/EnvMap.java">EnvMap</a> example:</p><pre><code class="language-java">import java.util.Map;

public class EnvMap {

public static void main (String[] args) {

Map&lt;String, String&gt; env = System.getenv();

for (String envName : env.keySet()) {

System.out.format(&quot;%s=%s%n&quot;,

envName,

env.get(envName));

}

}

}
</code></pre><p>With a String argument, getenv returns the value of the specified variable. If the variable is not defined, getenv returns null. The <a href="https://docs.oracle.com/javase/tutorial/essential/environment/examples/Env.java">Env</a> example uses getenv this way to query specific environment variables, specified on the command line:</p><pre><code class="language-java">public class Env {

public static void main (String[] args) {

for (String env: args) {

String value = System.getenv(env);

if (value != null) {

System.out.format(&quot;%s=%s%n&quot;,

env, value);

} else {

System.out.format(&quot;%s is&quot;

+ &quot; not assigned.%n&quot;, env);

}

}

}

}
</code></pre><h4>16.1.3.2 Passing Environment Variables to New Processes</h4><p>When a Java application uses a <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html">ProcessBuilder</a> object to create a new process, the default set of environment variables passed to the new process is the same set provided to the application&#x27;s virtual machine process. The application can change this set using ProcessBuilder.environment.</p><h4>16.1.3.3 Platform Dependency Issues</h4><p>There are many subtle differences between the way environment variables are implemented on different systems. For example, Windows ignores case in environment variable names, while UNIX does not. The way environment variables are used also varies. For example, Windows provides the user name in an environment variable called USERNAME, while UNIX implementations might provide the user name in USER, LOGNAME, or both.</p><p>To maximize portability, never refer to an environment variable when the same value is available in a system property. For example, if the operating system provides a user name, it will always be available in the system property user.name.</p><h3>16.1.4 Other Configuration Utilities</h3><p>Here is a summary of some other configuration utilities.</p><p>The <em>Preferences API</em> allows applications to store and retrieve configuration data in an implementation-dependent backing store. Asynchronous updates are supported, and the same set of preferences can be safely updated by multiple threads and even multiple applications. For more information, refer to the <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/preferences/index.html">Preferences API Guide</a>.</p><p>An application deployed in a <em>JAR archive</em> uses a <em>manifest</em> to describe the contents of the archive. For more information, refer to the <a href="https://docs.oracle.com/javase/tutorial/deployment/jar/index.html">Packaging Programs in JAR Files</a> lesson.</p><p>The configuration of a <em>Java Web Start application</em> is contained in a <em>JNLP file</em>. For more information, refer to the <a href="https://docs.oracle.com/javase/tutorial/deployment/webstart/index.html">Java Web Start</a> lesson.</p><p>The configuration of a <em>Java Plug-in applet</em> is partially determined by the HTML tags used to embed the applet in the web page. Depending on the applet and the browser, these tags can include <code>&lt;applet&gt;</code>, <code>&lt;object&gt;</code>, <code>&lt;embed&gt;</code>, and <code>&lt;param&gt;</code>. For more information, refer to the <a href="https://docs.oracle.com/javase/tutorial/deployment/applet/index.html">Java Applets</a> lesson.</p><p>The class <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">java.util.ServiceLoader</a> provides a simple <em>service provider</em> facility. A service provider is an implementation of a <em>service</em> --- a well-known set of interfaces and (usually abstract) classes. The classes in a service provider typically implement the interfaces and subclass the classes defined in the service. Service providers can be installed as extensions (see <a href="https://docs.oracle.com/javase/tutorial/ext/index.html">The Extension Mechanism</a>). Providers can also be made available by adding them to the class path or by some other platform-specific means.</p><h2>16.2 System Utilities</h2><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html">System</a> class implements a number of system utilities. Some of these have already been covered in the previous section on <a href="https://docs.oracle.com/javase/tutorial/essential/environment/config.html">Configuration Utilities</a>. This section covers some of the other system utilities.</p><h3>16.2.1 Command-Line I/O Objects</h3><p>System provides several predefined I/O objects that are useful in a Java application that is meant to be launched from the command line. These implement the Standard I/O streams provided by most operating systems, and also a console object that is useful for entering passwords. For more information, refer to <a href="https://docs.oracle.com/javase/tutorial/essential/io/cl.html">I/O from the Command Line</a> in the <a href="https://docs.oracle.com/javase/tutorial/essential/io/index.html">Basic I/O</a> lesson.</p><h2>16.3 System Properties</h2><p>In <a href="https://docs.oracle.com/javase/tutorial/essential/environment/properties.html">Properties</a>, we examined the way an application can use Properties objects to maintain its configuration. The Java platform itself uses a Properties object to maintain its own configuration. The System class maintains a Properties object that describes the configuration of the current working environment. System properties include information about the current user, the current version of the Java runtime, and the character used to separate components of a file path name.</p><p>The following table describes some of the most important system properties</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Key</strong></td><td><strong>Meaning</strong></td></tr><tr><td>&quot;file.separator&quot;</td><td>Character that separates components of a file path. This is &quot;/&quot; on UNIX and &quot;<!-- -->\<!-- -->&quot; on Windows.</td></tr><tr><td>&quot;java.class.path&quot;</td><td>Path used to find directories and JAR archives containing class files. Elements of the class path are separated by a platform-specific character specified in the path.separator property.</td></tr><tr><td>&quot;java.home&quot;</td><td>Installation directory for Java Runtime Environment (JRE)</td></tr><tr><td>&quot;java.vendor&quot;</td><td>JRE vendor name</td></tr><tr><td>&quot;java.vendor.url&quot;</td><td>JRE vendor URL</td></tr><tr><td>&quot;java.version&quot;</td><td>JRE version number</td></tr><tr><td>&quot;line.separator&quot;</td><td>Sequence used by operating system to separate lines in text files</td></tr><tr><td>&quot;os.arch&quot;</td><td>Operating system architecture</td></tr><tr><td>&quot;os.name&quot;</td><td>Operating system name</td></tr><tr><td>&quot;os.version&quot;</td><td>Operating system version</td></tr><tr><td>&quot;path.separator&quot;</td><td>Path separator character used in java.class.path</td></tr><tr><td>&quot;user.dir&quot;</td><td>User working directory</td></tr><tr><td>&quot;user.home&quot;</td><td>User home directory</td></tr><tr><td>&quot;user.name&quot;</td><td>User account name</td></tr></tbody></table><p><strong>Security consideration:</strong> Access to system properties can be restricted by the <a href="https://docs.oracle.com/javase/tutorial/essential/environment/security.html">Security Manager</a>. This is most often an issue in applets, which are prevented from reading some system properties, and from writing <em>any</em> system properties. For more on accessing system properties in applets, refer to <a href="https://docs.oracle.com/javase/tutorial/deployment/doingMoreWithRIA/properties.html">System Properties</a> in the <a href="https://docs.oracle.com/javase/tutorial/deployment/doingMoreWithRIA/index.html">Doing More With Java Rich Internet Applications</a> lesson.</p><h3>16.3.1 Reading System Properties</h3><p>The System class has two methods used to read system properties: getProperty and getProperties.</p><p>The System class has two different versions of getProperty. Both retrieve the value of the property named in the argument list. The simpler of the two getProperty methods takes a single argument, a property key For example, to get the value of path.separator, use the following statement:</p><p>System.getProperty(&quot;path.separator&quot;);</p><p>The getProperty method returns a string containing the value of the property. If the property does not exist, this version of getProperty returns null.</p><p>The other version of getProperty requires two String arguments: the first argument is the key to look up and the second argument is a default value to return if the key cannot be found or if it has no value. For example, the following invocation of getProperty looks up the System property called subliminal.message. This is not a valid system property, so instead of returning null, this method returns the default value provided as a second argument: &quot;Buy StayPuft Marshmallows!&quot;</p><pre><code class="language-java">System.getProperty(&quot;subliminal.message&quot;, &quot;Buy StayPuft Marshmallows!&quot;);
``
The last method provided by the System class to access property values is the getProperties method, which returns a [Properties](https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html) object. This object contains a complete set of system property definitions.

### 16.3.2 Writing System Properties

To modify the existing set of system properties, use System.setProperties. This method takes a Properties object that has been initialized to contain the properties to be set. This method replaces the entire set of system properties with the new set represented by the Properties object.

**Warning:** Changing system properties is potentially dangerous and should be done with discretion. Many system properties are not reread after start-up and are there for informational purposes. Changing some properties may have unexpected side-effects.

The next example, [PropertiesTest](https://docs.oracle.com/javase/tutorial/essential/environment/examples/PropertiesTest.java), creates a Properties object and initializes it from [myProperties.txt](https://docs.oracle.com/javase/tutorial/essential/environment/examples/myProperties.txt) .

subliminal.message=Buy StayPuft Marshmallows!

PropertiesTest then uses System.setProperties to install the new Properties objects as the current set of system properties.

import java.io.FileInputStream;

import java.util.Properties;

public class PropertiesTest {

public static void main(String[] args)

throws Exception {

// set up new properties object

// from file &quot;myProperties.txt&quot;

FileInputStream propFile =

new FileInputStream( &quot;myProperties.txt&quot;);

Properties p =

new Properties(System.getProperties());

p.load(propFile);

// set the system properties

System.setProperties(p);

// display new properties

System.getProperties().list(System.out);

}

}

Note how PropertiesTest creates the Properties object, p, which is used as the argument to setProperties:

Properties p = new Properties(System.getProperties());

This statement initializes the new properties object, p, with the current set of system properties, which in the case of this small application, is the set of properties initialized by the runtime system. Then the application loads additional properties into p from the file myProperties.txt and sets the system properties to p. This has the effect of adding the properties listed in myProperties.txt to the set of properties created by the runtime system at startup. Note that an application can create p without any default Properties object, like this:

Properties p = new Properties();

Also note that the value of system properties can be overwritten! For example, if myProperties.txt contains the following line, the java.vendor system property will be overwritten:

java.vendor=Acme Software Company

In general, be careful not to overwrite system properties.

The setProperties method changes the set of system properties for the current running application. These changes are not persistent. That is, changing the system properties within an application will not affect future invocations of the Java interpreter for this or any other application. The runtime system re-initializes the system properties each time its starts up. If changes to system properties are to be persistent, then the application must write the values to some file before exiting and read them in again upon startup.

## 16.4 The Security Manager

A *security manager* is an object that defines a security policy for an application. This policy specifies actions that are unsafe or sensitive. Any actions not allowed by the security policy cause a[SecurityException](https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityException.html) to be thrown. An application can also query its security manager to discover which actions are allowed.

Typically, a web applet runs with a security manager provided by the browser or Java Web Start plugin. Other kinds of applications normally run without a security manager, unless the application itself defines one. If no security manager is present, the application has no security policy and acts without restrictions.

This section explains how an application interacts with an existing security manager. For more detailed information, including information on how to design a security manager, refer to the[Security Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html).

### 16.4.1 Interacting with the Security Manager

The security manager is an object of type [SecurityManager](https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityManager.html); to obtain a reference to this object, invoke System.getSecurityManager.

SecurityManager appsm = System.getSecurityManager();

If there is no security manager, this method returns null.

Once an application has a reference to the security manager object, it can request permission to do specific things. Many classes in the standard libraries do this. For example, System.exit, which terminates the Java virtual machine with an exit status, invokes SecurityManager.checkExit to ensure that the current thread has permission to shut down the application.

The SecurityManager class defines many other methods used to verify other kinds of operations. For example, SecurityManager.checkAccess verifies thread accesses, and SecurityManager.checkPropertyAccess verifies access to the specified property. Each operation or group of operations has its own check*XXX*() method.

In addition, the set of check*XXX*() methods represents the set of operations that are already subject to the protection of the security manager. Typically, an application does not have to directly invoke any check*XXX*() methods.

### 16.4.2 Recognizing a Security Violation

Many actions that are routine without a security manager can throw a SecurityException when run with a security manager. This is true even when invoking a method that isn&#x27;t documented as throwing SecurityException. For example, consider the following code used to read a file:

reader = new FileReader(&quot;xanadu.txt&quot;);

In the absence of a security manager, this statement executes without error, provided xanadu.txt exists and is readable. But suppose this statement is inserted in a web applet, which typically runs under a security manager that does not allow file input. The following error messages might result:
```bash
*appletviewer fileApplet.html*
Exception in thread &quot;AWT-EventQueue-1&quot; java.security.AccessControlException: access denied (java.io.FilePermission characteroutput.txt write)
at java.security.AccessControlContext.checkPermission(AccessControlContext.java:323)
at java.security.AccessController.checkPermission(AccessController.java:546)
at java.lang.SecurityManager.checkPermission(SecurityManager.java:532)
at java.lang.SecurityManager.checkWrite(SecurityManager.java:962)
at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:169)
at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:70)
at java.io.FileWriter.&lt;init&gt;(FileWriter.java:46)
</code></pre><p>Note that the specific exception thrown in this case, <a href="https://docs.oracle.com/javase/8/docs/api/java/security/AccessControlException.html">java.security.AccessControlException</a>, is a subclass of SecurityException.</p><h2>16.5 Miscellaneous Methods in System</h2><p>This section describes some of the methods in System that aren&#x27;t covered in the previous sections.</p><p>The arrayCopy method efficiently copies data between arrays. For more information, refer to <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html">Arrays</a> in the <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/index.html">Language Basics</a> lesson.</p><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#currentTimeMillis--">currentTimeMillis</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#nanoTime--">nanoTime</a> methods are useful for measuring time intervals during execution of an application. To measure a time interval in milliseconds, invoke currentTimeMillis twice, at the beginning and end of the interval, and subtract the first value returned from the second. Similarly, invoking nanoTime twice measures an interval in nanoseconds.</p><p><strong>Note:</strong> The accuracy of both currentTimeMillis and nanoTime is limited by the time services provided by the operating system. Do not assume that currentTimeMillis is accurate to the nearest millisecond or that nanoTime is accurate to the nearest nanosecond. Also, neither currentTimeMillis nor nanoTime should be used to determine the current time. Use a high-level method, such as <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--">java.util.Calendar.getInstance</a>.</p><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#exit-int-">exit</a> method causes the Java virtual machine to shut down, with an integer exit status specified by the argument. The exit status is available to the process that launched the application. By convention, an exit status of 0 indicates normal termination of the application, while any other value is an error code.</p><h2>16.6 PATH and CLASSPATH</h2><p>This section explains how to use the PATH and CLASSPATH environment variables on Microsoft Windows, Solaris, and Linux. Consult the installation instructions included with your installation of the Java Development Kit (JDK) software bundle for current information.</p><p>After installing the software, the JDK directory will have the structure shown below.</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8rAwAI6AL0EK/o3wAAAABJRU5ErkJggg==" alt="JDK directory structure"/></p><p>The bin directory contains both the compiler and the launcher.</p><h3>16.6.1 Update the PATH Environment Variable (Microsoft Windows)</h3><p>You can run Java applications just fine without setting the PATH environment variable. Or, you can optionally set it as a convenience.</p><p>Set the PATH environment variable if you want to be able to conveniently run the executables (javac.exe, java.exe, javadoc.exe, and so on) from any directory without having to type the full path of the command. If you do not set the PATH variable, you need to specify the full path to the executable every time you run it, such as:</p><p>C:<!-- -->\<!-- -->Java<!-- -->\<!-- -->jdk1.7.0<!-- -->\<!-- -->bin<!-- -->\<!-- -->javac MyClass.java</p><p>The PATH environment variable is a series of directories separated by semicolons (;). Microsoft Windows looks for programs in the PATH directories in order, from left to right. You should have only one bin directory for the JDK in the path at a time (those following the first are ignored), so if one is already present, you can update that particular entry.</p><p>The following is an example of a PATH environment variable:</p><p>C:<!-- -->\<!-- -->Java<!-- -->\<!-- -->jdk1.7.0<!-- -->\<!-- -->bin;C:<!-- -->\<!-- -->Windows<!-- -->\<!-- -->System32<!-- -->\<!-- -->;C:<!-- -->\<!-- -->Windows<!-- -->\<!-- -->;C:<!-- -->\<!-- -->Windows<!-- -->\<!-- -->System32<!-- -->\<!-- -->Wbem</p><p>It is useful to set the PATH environment variable permanently so it will persist after rebooting. To make a permanent change to the PATH variable, use the <strong>System</strong> icon in the Control Panel. The precise procedure varies depending on the version of Windows:</p><p><strong>Windows XP</strong></p><ol><li>Select <strong>Start</strong>, select <strong>Control Panel</strong>. double click <strong>System</strong>, and select the <strong>Advanced</strong> tab.</li><li>Click <strong>Environment Variables</strong>. In the section <strong>System Variables</strong>, find the PATH environment variable and select it. Click <strong>Edit</strong>. If the PATH environment variable does not exist, click New.</li><li>In the <strong>Edit System Variable</strong> (or <strong>New System Variable</strong>) window, specify the value of the PATH environment variable. Click <strong>OK</strong>. Close all remaining windows by clicking <strong>OK</strong>.</li></ol><p><strong>Windows Vista:</strong></p><ol><li>From the desktop, right click the <strong>My Computer</strong> icon.</li><li>Choose <strong>Properties</strong> from the context menu.</li><li>Click the <strong>Advanced</strong> tab (<strong>Advanced system settings</strong> link in Vista).</li><li>Click <strong>Environment Variables</strong>. In the section <strong>System Variables</strong>, find the PATH environment variable and select it. Click <strong>Edit</strong>. If the PATH environment variable does not exist, click New.</li><li>In the <strong>Edit System Variable</strong> (or <strong>New System Variable</strong>) window, specify the value of the PATH environment variable. Click <strong>OK</strong>. Close all remaining windows by clicking <strong>OK</strong>.</li></ol><p><strong>Windows 7:</strong></p><ol><li>From the desktop, right click the <strong>Computer</strong> icon.</li><li>Choose <strong>Properties</strong> from the context menu.</li><li>Click the <strong>Advanced system settings</strong> link.</li><li>Click <strong>Environment Variables</strong>. In the section <strong>System Variables</strong>, find the PATH environment variable and select it. Click <strong>Edit</strong>. If the PATH environment variable does not exist, click New.</li><li>In the <strong>Edit System Variable</strong> (or <strong>New System Variable</strong>) window, specify the value of the PATH environment variable. Click <strong>OK</strong>. Close all remaining windows by clicking <strong>OK</strong>.</li></ol><p><strong>Note:</strong> You may see a PATH environment variable similar to the following when editing it from the Control Panel:</p><p>%JAVA_HOME%<!-- -->\<!-- -->bin;%SystemRoot%<!-- -->\<!-- -->system32;%SystemRoot%;%SystemRoot%<!-- -->\<!-- -->System32<!-- -->\<!-- -->Wbem</p><p>Variables enclosed in percentage signs (%) are existing environment variables. If one of these variables is listed in the <strong>Environment Variables</strong> window from the Control Panel (such as JAVA_HOME), then you can edit its value. If it does not appear, then it is a special environment variable that the operating system has defined. For example, SystemRoot is the location of the Microsoft Windows system folder. To obtain the value of an environment variable, enter the following at a command prompt. (This example obtains the value of the SystemRootenvironment variable):</p><p>echo %SystemRoot%</p><h3>16.6.2 Update the PATH Variable (Solaris and Linux)</h3><p>You can run the JDK just fine without setting the PATH variable, or you can optionally set it as a convenience. However, you should set the path variable if you want to be able to run the executables (javac, java, javadoc, and so on) from any directory without having to type the full path of the command. If you do not set the PATH variable, you need to specify the full path to the executable every time you run it, such as:</p><p>\% /usr/local/jdk1.7.0/bin/javac MyClass.java</p><p>To find out if the path is properly set, execute:</p><p>\% java -version</p><p>This will print the version of the java tool, if it can find it. If the version is old or you get the error <strong>java: Command not found</strong>, then the path is not properly set.</p><p>To set the path permanently, set the path in your startup file.</p><p>For C shell (csh), edit the startup file (~/.cshrc):</p><pre><code class="language-bash">set path=(/usr/local/jdk1.7.0/bin \$path)
</code></pre><p>For bash, edit the startup file (~/.bashrc):</p><pre><code class="language-bash">PATH=/usr/local/jdk1.7.0/bin:\$PATH

export PATH
</code></pre><p>For ksh, the startup file is named by the environment variable, ENV. To set the path:</p><pre><code class="language-bash">PATH=/usr/local/jdk1.7.0/bin:\$PATH

export PATH
</code></pre><p>For sh, edit the profile file (~/.profile):</p><pre><code class="language-bash">PATH=/usr/local/jdk1.7.0/bin:\$PATH

export PATH
</code></pre><p>Then load the startup file and verify that the path is set by repeating the java command:</p><p>For C shell (csh):</p><pre><code class="language-bash">\% source ~/.cshrc

\% java -version

For ksh, bash, or sh:

\% . /.profile

\% java -version
</code></pre><h3>16.6.3 Checking the CLASSPATH variable (All platforms)</h3><p>The CLASSPATH variable is one way to tell applications, including the JDK tools, where to look for user classes. (Classes that are part of the JRE, JDK platform, and extensions should be defined through other means, such as the bootstrap class path or the extensions directory.)</p><p>The preferred way to specify the class path is by using the -cp command line switch. This allows the CLASSPATH to be set individually for each application without affecting other applications. <em>Setting the CLASSPATH can be tricky and should be performed with care.</em></p><p>The default value of the class path is &quot;.&quot;, meaning that only the current directory is searched. Specifying either the CLASSPATH variable or the -cp command line switch overrides this value.</p><p>To check whether CLASSPATH is set on Microsoft Windows NT/2000/XP, execute the following:</p><p>C:&gt; echo %CLASSPATH%</p><p>On Solaris or Linux, execute the following:</p><p>\% echo \$CLASSPATH</p><p>If CLASSPATH is not set you will get a <strong>CLASSPATH: Undefined variable</strong> error (Solaris or Linux) or simply <strong>%CLASSPATH%</strong> (Microsoft Windows NT/2000/XP).</p><p>To modify the CLASSPATH, use the same procedure you used for the PATH variable.</p><p>Class path wildcards allow you to include an entire directory of .jar files in the class path without explicitly naming them individually. For more information, including an explanation of class path wildcards, and a detailed description on how to clean up the CLASSPATH environment variable, see the <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/classpath.html">Setting the Class Path</a> technical note.</p><h1>17 Regular Expressions</h1><p>This lesson explains how to use the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/package-summary.html">java.util.regex</a> API for pattern matching with regular expressions. Although the syntax accepted by this package is similar to the <a href="http://www.perl.com/">Perl</a> programming language, knowledge of Perl is not a prerequisite. This lesson starts with the basics, and gradually builds to cover more advanced techniques.</p><h2>17.1 Introduction</h2><h3>17.1.1 What Are Regular Expressions?</h3><p><em>Regular expressions</em> are a way to describe a set of strings based on common characteristics shared by each string in the set. They can be used to search, edit, or manipulate text and data. You must learn a specific syntax to create regular expressions --- one that goes beyond the normal syntax of the Java programming language. Regular expressions vary in complexity, but once you understand the basics of how they&#x27;re constructed, you&#x27;ll be able to decipher (or create) any regular expression.</p><p>This trail teaches the regular expression syntax supported by the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/package-summary.html">java.util.regex</a> API and presents several working examples to illustrate how the various objects interact. In the world of regular expressions, there are many different flavors to choose from, such as grep, Perl, Tcl, Python, PHP, and awk. The regular expression syntax in the java.util.regex API is most similar to that found in Perl.</p><h3>17.1.2 How Are Regular Expressions Represented in This Package?</h3><p>The java.util.regex package primarily consists of three classes: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">Pattern</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html">Matcher</a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html">PatternSyntaxException</a>.</p><ul><li>A Pattern object is a compiled representation of a regular expression. The Pattern class provides no public constructors. To create a pattern, you must first invoke one of its public static compile methods, which will then return a Pattern object. These methods accept a regular expression as the first argument; the first few lessons of this trail will teach you the required syntax.</li><li>A Matcher object is the engine that interprets the pattern and performs match operations against an input string. Like the Pattern class, Matcher defines no public constructors. You obtain a Matcher object by invoking the matcher method on a Pattern object.</li><li>A PatternSyntaxException object is an unchecked exception that indicates a syntax error in a regular expression pattern.</li></ul><p>The last few lessons of this trail explore each class in detail. But first, you must understand how regular expressions are actually constructed. Therefore, the next section introduces a simple test harness that will be used repeatedly to explore their syntax.</p><h2>17.2 Test Harness</h2><p>This section defines a reusable test harness, <a href="https://docs.oracle.com/javase/tutorial/essential/regex/examples/RegexTestHarness.java">RegexTestHarness.java</a> , for exploring the regular expression constructs supported by this API. The command to run this code is java RegexTestHarness; no command-line arguments are accepted. The application loops repeatedly, prompting the user for a regular expression and input string. Using this test harness is optional, but you may find it convenient for exploring the test cases discussed in the following pages.</p><pre><code class="language-java">import java.io.Console;

import java.util.regex.Pattern;

import java.util.regex.Matcher;

public class RegexTestHarness {

public static void main(String[] args){

Console console = System.console();

if (console == null) {

System.err.println(&quot;No console.&quot;);

System.exit(1);

}

while (true) {

Pattern pattern =

Pattern.compile(console.readLine(&quot;%nEnter your regex: &quot;));

Matcher matcher =

pattern.matcher(console.readLine(&quot;Enter input string to search: &quot;));

boolean found = false;

while (matcher.find()) {

console.format(&quot;I found the text&quot; +

&quot; \\&quot;%s\\&quot; starting at &quot; +

&quot;index %d and ending at index %d.%n&quot;,

matcher.group(),

matcher.start(),

matcher.end());

found = true;

}

if(!found){

console.format(&quot;No match found.%n&quot;);

}

}

}

}
</code></pre><p>Before continuing to the next section, save and compile this code to ensure that your development environment supports the required packages.</p><h2>17.3 String Literals</h2><p>The most basic form of pattern matching supported by this API is the match of a string literal. For example, if the regular expression is foo and the input string is foo, the match will succeed because the strings are identical. Try this out with the test harness:</p><p>Enter your regex: foo</p><p>Enter input string to search: foo</p><p>I found the text foo starting at index 0 and ending at index 3.</p><p>This match was a success. Note that while the input string is 3 characters long, the start index is 0 and the end index is 3. By convention, ranges are inclusive of the beginning index and exclusive of the end index, as shown in the following figure:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP4//8xAwAIxALiFoIhigAAAABJRU5ErkJggg==" alt="The string literal foo, with numbered cells and index values."/></p><p>The string literal foo, with numbered cells and index values.</p><p>Each character in the string resides in its own <em>cell</em>, with the index positions pointing between each cell. The string &quot;foo&quot; starts at index 0 and ends at index 3, even though the characters themselves only occupy cells 0, 1, and 2.</p><p>With subsequent matches, you&#x27;ll notice some overlap; the start index for the next match is the same as the end index of the previous match:</p><p>Enter your regex: foo</p><p>Enter input string to search: foofoofoo</p><p>I found the text foo starting at index 0 and ending at index 3.</p><p>I found the text foo starting at index 3 and ending at index 6.</p><p>I found the text foo starting at index 6 and ending at index 9.</p><h3>17.3.1 Metacharacters</h3><p>This API also supports a number of special characters that affect the way a pattern is matched. Change the regular expression to cat. and the input string to cats. The output will appear as follows:</p><p>Enter your regex: cat.</p><p>Enter input string to search: cats</p><p>I found the text cats starting at index 0 and ending at index 4.</p><p>The match still succeeds, even though the dot &quot;.&quot; is not present in the input string. It succeeds because the dot is a <em>metacharacter</em> --- a character with special meaning interpreted by the matcher. The metacharacter &quot;.&quot; means &quot;any character&quot; which is why the match succeeds in this example.</p><p>The metacharacters supported by this API are: &lt;(<!-- -->[{<!-- -->\<!-- -->\^-=\$!<!-- -->|]<!-- -->})?<!-- -->*<!-- -->+.&gt;</p><p><strong>Note:</strong> In certain situations the special characters listed above will <em>not</em> be treated as metacharacters. You&#x27;ll encounter this as you learn more about how regular expressions are constructed. You can, however, use this list to check whether or not a specific character will ever be considered a metacharacter. For example, the characters @ and <!-- -->#<!-- --> never carry a special meaning.</p><p>There are two ways to force a metacharacter to be treated as an ordinary character:</p><ul><li>precede the metacharacter with a backslash, or</li><li>enclose it within <!-- -->\<!-- -->Q (which starts the quote) and <!-- -->\<!-- -->E (which ends it).</li></ul><p>When using this technique, the <!-- -->\<!-- -->Q and <!-- -->\<!-- -->E can be placed at any location within the expression, provided that the <!-- -->\<!-- -->Q comes first.</p><h2>17.4 Character Classes</h2><p>If you browse through the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">Pattern</a> class specification, you&#x27;ll see tables summarizing the supported regular expression constructs. In the &quot;Character Classes&quot; section you&#x27;ll find the following:</p><p>+-----------------------------------+-----------------------------------+
| []{#bookmark=id.3a54938}          | <strong>Description</strong>                   |
|                                   |                                   |
| <strong>Construct</strong>                     |                                   |
+-----------------------------------+-----------------------------------+
| <!-- -->[abc]<!-- -->                           | a, b, or c (simple class)         |
+-----------------------------------+-----------------------------------+
| <!-- -->[\^abc]<!-- -->                         | Any character except a, b, or c   |
|                                   | (negation)                        |
+-----------------------------------+-----------------------------------+
| <!-- -->[a-zA-Z]<!-- -->                        | a through z, or A through Z,      |
|                                   | inclusive (range)                 |
+-----------------------------------+-----------------------------------+
| [a-d<!-- -->[m-p]<!-- -->]                    | a through d, or m through p:      |
|                                   | <!-- -->[a-dm-p]<!-- --> (union)                |
+-----------------------------------+-----------------------------------+
| [a-z&amp;&amp;<!-- -->[def]<!-- -->]                  | d, e, or f (intersection)         |
+-----------------------------------+-----------------------------------+
| [a-z&amp;&amp;<!-- -->[\^bc]<!-- -->]                 | a through z, except for b and c:  |
|                                   | <!-- -->[ad-z]<!-- --> (subtraction)            |
+-----------------------------------+-----------------------------------+
| [a-z&amp;&amp;<!-- -->[\^m-p]<!-- -->]                | a through z, and not m through p: |
|                                   | <!-- -->[a-lq-z]<!-- --> (subtraction)          |
+-----------------------------------+-----------------------------------+</p><p>The left-hand column specifies the regular expression constructs, while the right-hand column describes the conditions under which each construct will match.</p><p><strong>Note:</strong> The word &quot;class&quot; in the phrase &quot;character class&quot; does not refer to a .class file. In the context of regular expressions, a <em>character class</em> is a set of characters enclosed within square brackets. It specifies the characters that will successfully match a single character from a given input string.</p><h3>17.4.1 Simple Classes</h3><p>The most basic form of a character class is to simply place a set of characters side-by-side within square brackets. For example, the regular expression <!-- -->[bcr]<!-- -->at will match the words &quot;bat&quot;, &quot;cat&quot;, or &quot;rat&quot; because it defines a character class (accepting either &quot;b&quot;, &quot;c&quot;, or &quot;r&quot;) as its first character.</p><p>Enter your regex: <!-- -->[bcr]<!-- -->at</p><p>Enter input string to search: bat</p><p>I found the text &quot;bat&quot; starting at index 0 and ending at index 3.</p><p>Enter your regex: <!-- -->[bcr]<!-- -->at</p><p>Enter input string to search: cat</p><p>I found the text &quot;cat&quot; starting at index 0 and ending at index 3.</p><p>Enter your regex: <!-- -->[bcr]<!-- -->at</p><p>Enter input string to search: rat</p><p>I found the text &quot;rat&quot; starting at index 0 and ending at index 3.</p><p>Enter your regex: <!-- -->[bcr]<!-- -->at</p><p>Enter input string to search: hat</p><p>No match found.</p><p>In the above examples, the overall match succeeds only when the first letter matches one of the characters defined by the character class.</p><h4>17.4.1.1 Negation</h4><p>To match all characters <em>except</em> those listed, insert the &quot;\^&quot; metacharacter at the beginning of the character class. This technique is known as <em>negation</em>.</p><p>Enter your regex: <!-- -->[\^bcr]<!-- -->at</p><p>Enter input string to search: bat</p><p>No match found.</p><p>Enter your regex: <!-- -->[\^bcr]<!-- -->at</p><p>Enter input string to search: cat</p><p>No match found.</p><p>Enter your regex: <!-- -->[\^bcr]<!-- -->at</p><p>Enter input string to search: rat</p><p>No match found.</p><p>Enter your regex: <!-- -->[\^bcr]<!-- -->at</p><p>Enter input string to search: hat</p><p>I found the text &quot;hat&quot; starting at index 0 and ending at index 3.</p><p>The match is successful only if the first character of the input string does <em>not</em> contain any of the characters defined by the character class.</p><h4>17.4.1.2 Ranges</h4><p>Sometimes you&#x27;ll want to define a character class that includes a range of values, such as the letters &quot;a through h&quot; or the numbers &quot;1 through 5&quot;. To specify a range, simply insert the &quot;-&quot; metacharacter between the first and last character to be matched, such as <!-- -->[1-5]<!-- --> or <!-- -->[a-h]<!-- -->. You can also place different ranges beside each other within the class to further expand the match possibilities. For example, <!-- -->[a-zA-Z]<!-- --> will match any letter of the alphabet: a to z (lowercase) or A to Z (uppercase).</p><p>Here are some examples of ranges and negation:</p><p>Enter your regex: <!-- -->[a-c]</p><p>Enter input string to search: a</p><p>I found the text &quot;a&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: <!-- -->[a-c]</p><p>Enter input string to search: b</p><p>I found the text &quot;b&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: <!-- -->[a-c]</p><p>Enter input string to search: c</p><p>I found the text &quot;c&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: <!-- -->[a-c]</p><p>Enter input string to search: d</p><p>No match found.</p><p>Enter your regex: foo<!-- -->[1-5]</p><p>Enter input string to search: foo1</p><p>I found the text &quot;foo1&quot; starting at index 0 and ending at index 4.</p><p>Enter your regex: foo<!-- -->[1-5]</p><p>Enter input string to search: foo5</p><p>I found the text &quot;foo5&quot; starting at index 0 and ending at index 4.</p><p>Enter your regex: foo<!-- -->[1-5]</p><p>Enter input string to search: foo6</p><p>No match found.</p><p>Enter your regex: foo<!-- -->[\^1-5]</p><p>Enter input string to search: foo1</p><p>No match found.</p><p>Enter your regex: foo<!-- -->[\^1-5]</p><p>Enter input string to search: foo6</p><p>I found the text &quot;foo6&quot; starting at index 0 and ending at index 4.</p><h4>17.4.1.3 Unions</h4><p>You can also use <em>unions</em> to create a single character class comprised of two or more separate character classes. To create a union, simply nest one class inside the other, such as [0-4<!-- -->[6-8]<!-- -->]. This particular union creates a single character class that matches the numbers 0, 1, 2, 3, 4, 6, 7, and 8.</p><p>Enter your regex: [0-4<!-- -->[6-8]<!-- -->]</p><p>Enter input string to search: 0</p><p>I found the text &quot;0&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: [0-4<!-- -->[6-8]<!-- -->]</p><p>Enter input string to search: 5</p><p>No match found.</p><p>Enter your regex: [0-4<!-- -->[6-8]<!-- -->]</p><p>Enter input string to search: 6</p><p>I found the text &quot;6&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: [0-4<!-- -->[6-8]<!-- -->]</p><p>Enter input string to search: 8</p><p>I found the text &quot;8&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: [0-4<!-- -->[6-8]<!-- -->]</p><p>Enter input string to search: 9</p><p>No match found.</p><h4>17.4.1.4 Intersections</h4><p>To create a single character class matching only the characters common to all of its nested classes, use &amp;&amp;, as in [0-9&amp;&amp;<!-- -->[345]<!-- -->]. This particular intersection creates a single character class matching only the numbers common to both character classes: 3, 4, and 5.</p><p>Enter your regex: [0-9&amp;&amp;<!-- -->[345]<!-- -->]</p><p>Enter input string to search: 3</p><p>I found the text &quot;3&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: [0-9&amp;&amp;<!-- -->[345]<!-- -->]</p><p>Enter input string to search: 4</p><p>I found the text &quot;4&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: [0-9&amp;&amp;<!-- -->[345]<!-- -->]</p><p>Enter input string to search: 5</p><p>I found the text &quot;5&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: [0-9&amp;&amp;<!-- -->[345]<!-- -->]</p><p>Enter input string to search: 2</p><p>No match found.</p><p>Enter your regex: [0-9&amp;&amp;<!-- -->[345]<!-- -->]</p><p>Enter input string to search: 6</p><p>No match found.</p><p>And here&#x27;s an example that shows the intersection of two ranges:</p><p>Enter your regex: [2-8&amp;&amp;<!-- -->[4-6]<!-- -->]</p><p>Enter input string to search: 3</p><p>No match found.</p><p>Enter your regex: [2-8&amp;&amp;<!-- -->[4-6]<!-- -->]</p><p>Enter input string to search: 4</p><p>I found the text &quot;4&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: [2-8&amp;&amp;<!-- -->[4-6]<!-- -->]</p><p>Enter input string to search: 5</p><p>I found the text &quot;5&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: [2-8&amp;&amp;<!-- -->[4-6]<!-- -->]</p><p>Enter input string to search: 6</p><p>I found the text &quot;6&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: [2-8&amp;&amp;<!-- -->[4-6]<!-- -->]</p><p>Enter input string to search: 7</p><p>No match found.</p><h4>17.4.1.5 Subtraction</h4><p>Finally, you can use <em>subtraction</em> to negate one or more nested character classes, such as [0-9&amp;&amp;<!-- -->[\^345]<!-- -->]. This example creates a single character class that matches everything from 0 to 9, <em>except</em> the numbers 3, 4, and 5.</p><p>Enter your regex: [0-9&amp;&amp;<!-- -->[\^345]<!-- -->]</p><p>Enter input string to search: 2</p><p>I found the text &quot;2&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: [0-9&amp;&amp;<!-- -->[\^345]<!-- -->]</p><p>Enter input string to search: 3</p><p>No match found.</p><p>Enter your regex: [0-9&amp;&amp;<!-- -->[\^345]<!-- -->]</p><p>Enter input string to search: 4</p><p>No match found.</p><p>Enter your regex: [0-9&amp;&amp;<!-- -->[\^345]<!-- -->]</p><p>Enter input string to search: 5</p><p>No match found.</p><p>Enter your regex: [0-9&amp;&amp;<!-- -->[\^345]<!-- -->]</p><p>Enter input string to search: 6</p><p>I found the text &quot;6&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: [0-9&amp;&amp;<!-- -->[\^345]<!-- -->]</p><p>Enter input string to search: 9</p><p>I found the text &quot;9&quot; starting at index 0 and ending at index 1.</p><p>Now that we&#x27;ve covered how character classes are created, You may want to review the <a href="https://docs.oracle.com/javase/tutorial/essential/regex/char_classes.html#CHART">Character Classes table</a> before continuing with the next section.</p><h3>17.4.2 Predefined Character Classes</h3><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">Pattern</a> API contains a number of useful <em>predefined character classes</em>, which offer convenient shorthands for commonly used regular expressions:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Construct</strong></td><td><strong>Description</strong></td></tr><tr><td>.</td><td>Any character (may or may not match line terminators)</td></tr><tr><td>\<!-- -->d</td><td>A digit: <!-- -->[0-9]</td></tr><tr><td>\<!-- -->D</td><td>A non-digit: <!-- -->[\^0-9]</td></tr><tr><td>\<!-- -->s</td><td>A whitespace character: <!-- -->[ <!-- -->\<!-- -->t<!-- -->\<!-- -->n<!-- -->\<!-- -->x0B<!-- -->\<!-- -->f<!-- -->\<!-- -->r]</td></tr><tr><td>\<!-- -->S</td><td>A non-whitespace character: <!-- -->[\^<!-- -->\<!-- -->s]</td></tr><tr><td>\<!-- -->w</td><td>A word character: <!-- -->[a-zA-Z_0-9]</td></tr><tr><td>\<!-- -->W</td><td>A non-word character: <!-- -->[\^<!-- -->\<!-- -->w]</td></tr></tbody></table><p>In the table above, each construct in the left-hand column is shorthand for the character class in the right-hand column. For example, <!-- -->\<!-- -->d means a range of digits (0-9), and <!-- -->\<!-- -->w means a word character (any lowercase letter, any uppercase letter, the underscore character, or any digit). Use the predefined classes whenever possible. They make your code easier to read and eliminate errors introduced by malformed character classes.</p><p>Constructs beginning with a backslash are called <em>escaped constructs</em>. We previewed escaped constructs in the <a href="https://docs.oracle.com/javase/tutorial/essential/regex/literals.html">String Literals</a> section where we mentioned the use of backslash and <!-- -->\<!-- -->Q and <!-- -->\<!-- -->E for quotation. If you are using an escaped construct within a string literal, you must precede the backslash with another backslash for the string to compile. For example:</p><p>private final String REGEX = &quot;<!-- -->\<!-- -->\<!-- -->d&quot;; // a single digit</p><p>In this example <!-- -->\<!-- -->d is the regular expression; the extra backslash is required for the code to compile. The test harness reads the expressions directly from the Console, however, so the extra backslash is unnecessary.</p><p>The following examples demonstrate the use of predefined character classes.</p><p>Enter your regex: .</p><p>Enter input string to search: @</p><p>I found the text &quot;@&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: .</p><p>Enter input string to search: 1</p><p>I found the text &quot;1&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: .</p><p>Enter input string to search: a</p><p>I found the text &quot;a&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: <!-- -->\<!-- -->d</p><p>Enter input string to search: 1</p><p>I found the text &quot;1&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: <!-- -->\<!-- -->d</p><p>Enter input string to search: a</p><p>No match found.</p><p>Enter your regex: <!-- -->\<!-- -->D</p><p>Enter input string to search: 1</p><p>No match found.</p><p>Enter your regex: <!-- -->\<!-- -->D</p><p>Enter input string to search: a</p><p>I found the text &quot;a&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: <!-- -->\<!-- -->s</p><p>Enter input string to search:</p><p>I found the text &quot; &quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: <!-- -->\<!-- -->s</p><p>Enter input string to search: a</p><p>No match found.</p><p>Enter your regex: <!-- -->\<!-- -->S</p><p>Enter input string to search:</p><p>No match found.</p><p>Enter your regex: <!-- -->\<!-- -->S</p><p>Enter input string to search: a</p><p>I found the text &quot;a&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: <!-- -->\<!-- -->w</p><p>Enter input string to search: a</p><p>I found the text &quot;a&quot; starting at index 0 and ending at index 1.</p><p>Enter your regex: <!-- -->\<!-- -->w</p><p>Enter input string to search: !</p><p>No match found.</p><p>Enter your regex: <!-- -->\<!-- -->W</p><p>Enter input string to search: a</p><p>No match found.</p><p>Enter your regex: <!-- -->\<!-- -->W</p><p>Enter input string to search: !</p><p>I found the text &quot;!&quot; starting at index 0 and ending at index 1.</p><p>In the first three examples, the regular expression is simply . (the &quot;dot&quot; metacharacter) that indicates &quot;any character.&quot; Therefore, the match is successful in all three cases (a randomly selected \@character, a digit, and a letter). The remaining examples each use a single regular expression construct from the <a href="https://docs.oracle.com/javase/tutorial/essential/regex/pre_char_classes.html#CHART">Predefined Character Classes table</a>. You can refer to this table to figure out the logic behind each match:</p><ul><li>\<!-- -->d matches all digits</li><li>\<!-- -->s matches spaces</li><li>\<!-- -->w matches word characters</li></ul><p>Alternatively, a capital letter means the opposite:</p><ul><li>\<!-- -->D matches non-digits</li><li>\<!-- -->S matches non-spaces</li><li>\<!-- -->W matches non-word characters</li></ul><h2>17.5 Quantifiers</h2><p><em>Quantifiers</em> allow you to specify the number of occurrences to match against. For convenience, the three sections of the Pattern API specification describing greedy, reluctant, and possessive quantifiers are presented below. At first glance it may appear that the quantifiers X?, X?? and X?+ do exactly the same thing, since they all promise to match &quot;X, once or not at all&quot;. There are subtle implementation differences which will be explained near the end of this section.</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>Greedy</strong></td><td><strong>Reluctant</strong></td><td><strong>Possessive</strong></td><td><strong>Meaning</strong></td></tr><tr><td>X?</td><td>X??</td><td>X?+</td><td><em>X</em>, once or not at all</td></tr><tr><td>X<!-- -->*</td><td>X<!-- -->*<!-- -->?</td><td>X<!-- -->*<!-- -->+</td><td><em>X</em>, zero or more times</td></tr><tr><td>X+</td><td>X+?</td><td>X++</td><td><em>X</em>, one or more times</td></tr><tr><td>X{n}</td><td>X{n}?</td><td>X{n}+</td><td><em>X</em>, exactly <em>n</em> times</td></tr><tr><td>X{n,}</td><td>X{n,}?</td><td>X{n,}+</td><td><em>X</em>, at least <em>n</em> times</td></tr><tr><td>X{n,m}</td><td>X{n,m}?</td><td>X{n,m}+</td><td><em>X</em>, at least <em>n</em> but not more than <em>m</em> times</td></tr></tbody></table><p>Let&#x27;s start our look at greedy quantifiers by creating three different regular expressions: the letter &quot;a&quot; followed by either ?, <!-- -->*<!-- -->, or +. Let&#x27;s see what happens when these expressions are tested against an empty input string &quot;&quot;:</p><p>Enter your regex: a?</p><p>Enter input string to search:</p><p>I found the text &quot;&quot; starting at index 0 and ending at index 0.</p><p>Enter your regex: a<!-- -->*</p><p>Enter input string to search:</p><p>I found the text &quot;&quot; starting at index 0 and ending at index 0.</p><p>Enter your regex: a+</p><p>Enter input string to search:</p><p>No match found.</p><h3>17.5.1 Zero-Length Matches</h3><p>In the above example, the match is successful in the first two cases because the expressions a? and a<!-- -->*<!-- --> both allow for zero occurrences of the letter a. You&#x27;ll also notice that the start and end indices are both zero, which is unlike any of the examples we&#x27;ve seen so far. The empty input string &quot;&quot; has no length, so the test simply matches nothing at index 0. Matches of this sort are known as a <em>zero-length matches</em>. A zero-length match can occur in several cases: in an empty input string, at the beginning of an input string, after the last character of an input string, or in between any two characters of an input string. Zero-length matches are easily identifiable because they always start and end at the same index position.</p><p>Let&#x27;s explore zero-length matches with a few more examples. Change the input string to a single letter &quot;a&quot; and you&#x27;ll notice something interesting:</p><p>Enter your regex: a?</p><p>Enter input string to search: a</p><p>I found the text &quot;a&quot; starting at index 0 and ending at index 1.</p><p>I found the text &quot;&quot; starting at index 1 and ending at index 1.</p><p>Enter your regex: a<!-- -->*</p><p>Enter input string to search: a</p><p>I found the text &quot;a&quot; starting at index 0 and ending at index 1.</p><p>I found the text &quot;&quot; starting at index 1 and ending at index 1.</p><p>Enter your regex: a+</p><p>Enter input string to search: a</p><p>I found the text &quot;a&quot; starting at index 0 and ending at index 1.</p><p>All three quantifiers found the letter &quot;a&quot;, but the first two also found a zero-length match at index 1; that is, after the last character of the input string. Remember, the matcher sees the character &quot;a&quot; as sitting in the cell between index 0 and index 1, and our test harness loops until it can no longer find a match. Depending on the quantifier used, the presence of &quot;nothing&quot; at the index after the last character may or may not trigger a match.</p><p>Now change the input string to the letter &quot;a&quot; five times in a row and you&#x27;ll get the following:</p><p>Enter your regex: a?</p><p>Enter input string to search: aaaaa</p><p>I found the text &quot;a&quot; starting at index 0 and ending at index 1.</p><p>I found the text &quot;a&quot; starting at index 1 and ending at index 2.</p><p>I found the text &quot;a&quot; starting at index 2 and ending at index 3.</p><p>I found the text &quot;a&quot; starting at index 3 and ending at index 4.</p><p>I found the text &quot;a&quot; starting at index 4 and ending at index 5.</p><p>I found the text &quot;&quot; starting at index 5 and ending at index 5.</p><p>Enter your regex: a<!-- -->*</p><p>Enter input string to search: aaaaa</p><p>I found the text &quot;aaaaa&quot; starting at index 0 and ending at index 5.</p><p>I found the text &quot;&quot; starting at index 5 and ending at index 5.</p><p>Enter your regex: a+</p><p>Enter input string to search: aaaaa</p><p>I found the text &quot;aaaaa&quot; starting at index 0 and ending at index 5.</p><p>The expression a? finds an individual match for each character, since it matches when &quot;a&quot; appears zero or one times. The expression a<!-- -->*<!-- --> finds two separate matches: all of the letter &quot;a&quot;&#x27;s in the first match, then the zero-length match after the last character at index 5. And finally, a+ matches all occurrences of the letter &quot;a&quot;, ignoring the presence of &quot;nothing&quot; at the last index.</p><p>At this point, you might be wondering what the results would be if the first two quantifiers encounter a letter other than &quot;a&quot;. For example, what happens if it encounters the letter &quot;b&quot;, as in &quot;ababaaaab&quot;?</p><p>Let&#x27;s find out:</p><p>Enter your regex: a?</p><p>Enter input string to search: ababaaaab</p><p>I found the text &quot;a&quot; starting at index 0 and ending at index 1.</p><p>I found the text &quot;&quot; starting at index 1 and ending at index 1.</p><p>I found the text &quot;a&quot; starting at index 2 and ending at index 3.</p><p>I found the text &quot;&quot; starting at index 3 and ending at index 3.</p><p>I found the text &quot;a&quot; starting at index 4 and ending at index 5.</p><p>I found the text &quot;a&quot; starting at index 5 and ending at index 6.</p><p>I found the text &quot;a&quot; starting at index 6 and ending at index 7.</p><p>I found the text &quot;a&quot; starting at index 7 and ending at index 8.</p><p>I found the text &quot;&quot; starting at index 8 and ending at index 8.</p><p>I found the text &quot;&quot; starting at index 9 and ending at index 9.</p><p>Enter your regex: a<!-- -->*</p><p>Enter input string to search: ababaaaab</p><p>I found the text &quot;a&quot; starting at index 0 and ending at index 1.</p><p>I found the text &quot;&quot; starting at index 1 and ending at index 1.</p><p>I found the text &quot;a&quot; starting at index 2 and ending at index 3.</p><p>I found the text &quot;&quot; starting at index 3 and ending at index 3.</p><p>I found the text &quot;aaaa&quot; starting at index 4 and ending at index 8.</p><p>I found the text &quot;&quot; starting at index 8 and ending at index 8.</p><p>I found the text &quot;&quot; starting at index 9 and ending at index 9.</p><p>Enter your regex: a+</p><p>Enter input string to search: ababaaaab</p><p>I found the text &quot;a&quot; starting at index 0 and ending at index 1.</p><p>I found the text &quot;a&quot; starting at index 2 and ending at index 3.</p><p>I found the text &quot;aaaa&quot; starting at index 4 and ending at index 8.</p><p>Even though the letter &quot;b&quot; appears in cells 1, 3, and 8, the output reports a zero-length match at those locations. The regular expression a? is not specifically looking for the letter &quot;b&quot;; it&#x27;s merely looking for the presence (or lack thereof) of the letter &quot;a&quot;. If the quantifier allows for a match of &quot;a&quot; zero times, anything in the input string that&#x27;s not an &quot;a&quot; will show up as a zero-length match. The remaining a&#x27;s are matched according to the rules discussed in the previous examples.</p><p>To match a pattern exactly <em>n</em> number of times, simply specify the number inside a set of braces:</p><p>Enter your regex: a{3}</p><p>Enter input string to search: aa</p><p>No match found.</p><p>Enter your regex: a{3}</p><p>Enter input string to search: aaa</p><p>I found the text &quot;aaa&quot; starting at index 0 and ending at index 3.</p><p>Enter your regex: a{3}</p><p>Enter input string to search: aaaa</p><p>I found the text &quot;aaa&quot; starting at index 0 and ending at index 3.</p><p>Here, the regular expression a{3} is searching for three occurrences of the letter &quot;a&quot; in a row. The first test fails because the input string does not have enough a&#x27;s to match against. The second test contains exactly 3 a&#x27;s in the input string, which triggers a match. The third test also triggers a match because there are exactly 3 a&#x27;s at the beginning of the input string. Anything following that is irrelevant to the first match. If the pattern should appear again after that point, it would trigger subsequent matches:</p><p>Enter your regex: a{3}</p><p>Enter input string to search: aaaaaaaaa</p><p>I found the text &quot;aaa&quot; starting at index 0 and ending at index 3.</p><p>I found the text &quot;aaa&quot; starting at index 3 and ending at index 6.</p><p>I found the text &quot;aaa&quot; starting at index 6 and ending at index 9.</p><p>To require a pattern to appear at least <em>n</em> times, add a comma after the number:</p><p>Enter your regex: a{3,}</p><p>Enter input string to search: aaaaaaaaa</p><p>I found the text &quot;aaaaaaaaa&quot; starting at index 0 and ending at index 9.</p><p>With the same input string, this test finds only one match, because the 9 a&#x27;s in a row satisfy the need for &quot;at least&quot; 3 a&#x27;s.</p><p>Finally, to specify an upper limit on the number of occurances, add a second number inside the braces:</p><p>Enter your regex: a{3,6} // find at least 3 (but no more than 6) a&#x27;s in a row</p><p>Enter input string to search: aaaaaaaaa</p><p>I found the text &quot;aaaaaa&quot; starting at index 0 and ending at index 6.</p><p>I found the text &quot;aaa&quot; starting at index 6 and ending at index 9.</p><p>Here the first match is forced to stop at the upper limit of 6 characters. The second match includes whatever is left over, which happens to be three a&#x27;s --- the mimimum number of characters allowed for this match. If the input string were one character shorter, there would not be a second match since only two a&#x27;s would remain.</p><h3>17.5.2 Capturing Groups and Character Classes with Quantifiers</h3><p>Until now, we&#x27;ve only tested quantifiers on input strings containing one character. In fact, quantifiers can only attach to one character at a time, so the regular expression &quot;abc+&quot; would mean &quot;a, followed by b, followed by c one or more times&quot;. It would not mean &quot;abc&quot; one or more times. However, quantifiers can also attach to <a href="https://docs.oracle.com/javase/tutorial/essential/regex/char_classes.html">Character Classes</a> and <a href="https://docs.oracle.com/javase/tutorial/essential/regex/groups.html">Capturing Groups</a>, such as <!-- -->[abc]<!-- -->+ (a or b or c, one or more times) or (abc)+ (the group &quot;abc&quot;, one or more times).</p><p>Let&#x27;s illustrate by specifying the group (dog), three times in a row.</p><p>Enter your regex: (dog){3}</p><p>Enter input string to search: dogdogdogdogdogdog</p><p>I found the text &quot;dogdogdog&quot; starting at index 0 and ending at index 9.</p><p>I found the text &quot;dogdogdog&quot; starting at index 9 and ending at index 18.</p><p>Enter your regex: dog{3}</p><p>Enter input string to search: dogdogdogdogdogdog</p><p>No match found.</p><p>Here the first example finds three matches, since the quantifier applies to the entire capturing group. Remove the parentheses, however, and the match fails because the quantifier {3} now applies only to the letter &quot;g&quot;.</p><p>Similarly, we can apply a quantifier to an entire character class:</p><p>Enter your regex: <!-- -->[abc]<!-- -->{3}</p><p>Enter input string to search: abccabaaaccbbbc</p><p>I found the text &quot;abc&quot; starting at index 0 and ending at index 3.</p><p>I found the text &quot;cab&quot; starting at index 3 and ending at index 6.</p><p>I found the text &quot;aaa&quot; starting at index 6 and ending at index 9.</p><p>I found the text &quot;ccb&quot; starting at index 9 and ending at index 12.</p><p>I found the text &quot;bbc&quot; starting at index 12 and ending at index 15.</p><p>Enter your regex: abc{3}</p><p>Enter input string to search: abccabaaaccbbbc</p><p>No match found.</p><p>Here the quantifier {3} applies to the entire character class in the first example, but only to the letter &quot;c&quot; in the second.[]{#bookmark=id.22pkfa2}</p><h3>17.5.3 Differences Among Greedy, Reluctant, and Possessive Quantifiers</h3><p>There are subtle differences among greedy, reluctant, and possessive quantifiers.</p><p>Greedy quantifiers are considered &quot;greedy&quot; because they force the matcher to read in, or <em>eat</em>, the entire input string prior to attempting the first match. If the first match attempt (the entire input string) fails, the matcher backs off the input string by one character and tries again, repeating the process until a match is found or there are no more characters left to back off from. Depending on the quantifier used in the expression, the last thing it will try matching against is 1 or 0 characters.</p><p>The reluctant quantifiers, however, take the opposite approach: They start at the beginning of the input string, then reluctantly eat one character at a time looking for a match. The last thing they try is the entire input string.</p><p>Finally, the possessive quantifiers always eat the entire input string, trying once (and only once) for a match. Unlike the greedy quantifiers, possessive quantifiers never back off, even if doing so would allow the overall match to succeed.</p><p>To illustrate, consider the input string xfooxxxxxxfoo.</p><p>Enter your regex: .*foo // greedy quantifier</p><p>Enter input string to search: xfooxxxxxxfoo</p><p>I found the text &quot;xfooxxxxxxfoo&quot; starting at index 0 and ending at index 13.</p><p>Enter your regex: .*?foo // reluctant quantifier</p><p>Enter input string to search: xfooxxxxxxfoo</p><p>I found the text &quot;xfoo&quot; starting at index 0 and ending at index 4.</p><p>I found the text &quot;xxxxxxfoo&quot; starting at index 4 and ending at index 13.</p><p>Enter your regex: .*+foo // possessive quantifier</p><p>Enter input string to search: xfooxxxxxxfoo</p><p>No match found.</p><p>The first example uses the greedy quantifier .<em> to find &quot;anything&quot;, zero or more times, followed by the letters &quot;f&quot; &quot;o&quot; &quot;o&quot;. Because the quantifier is greedy, the .</em> portion of the expression first eats the entire input string. At this point, the overall expression cannot succeed, because the last three letters (&quot;f&quot; &quot;o&quot; &quot;o&quot;) have already been consumed. So the matcher slowly backs off one letter at a time until the rightmost occurrence of &quot;foo&quot; has been regurgitated, at which point the match succeeds and the search ends.</p><p>The second example, however, is reluctant, so it starts by first consuming &quot;nothing&quot;. Because &quot;foo&quot; doesn&#x27;t appear at the beginning of the string, it&#x27;s forced to swallow the first letter (an &quot;x&quot;), which triggers the first match at 0 and 4. Our test harness continues the process until the input string is exhausted. It finds another match at 4 and 13.</p><p>The third example fails to find a match because the quantifier is possessive. In this case, the entire input string is consumed by .*+, leaving nothing left over to satisfy the &quot;foo&quot; at the end of the expression. Use a possessive quantifier for situations where you want to seize all of something without ever backing off; it will outperform the equivalent greedy quantifier in cases where the match is not immediately found.</p><h2>17.6 Capturing Groups</h2><p>In the <a href="https://docs.oracle.com/javase/tutorial/essential/regex/quant.html">previous section</a>, we saw how quantifiers attach to one character, character class, or capturing group at a time. But until now, we have not discussed the notion of capturing groups in any detail.</p><p><em>Capturing groups</em> are a way to treat multiple characters as a single unit. They are created by placing the characters to be grouped inside a set of parentheses. For example, the regular expression (dog) creates a single group containing the letters &quot;d&quot; &quot;o&quot; and &quot;g&quot;. The portion of the input string that matches the capturing group will be saved in memory for later recall via backreferences (as discussed below in the section, <a href="https://docs.oracle.com/javase/tutorial/essential/regex/groups.html#backref">Backreferences</a>).</p><h3>17.6.1 Numbering</h3><p>As described in the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">Pattern</a> API, capturing groups are numbered by counting their opening parentheses from left to right. In the expression ((A)(B(C))), for example, there are four such groups:</p><ol><li>((A)(B(C)))</li><li>(<!-- -->A<!-- -->)</li><li>(B(C))</li><li>(<!-- -->C<!-- -->)</li></ol><p>To find out how many groups are present in the expression, call the groupCount method on a matcher object. The groupCount method returns an int showing the number of capturing groups present in the matcher&#x27;s pattern. In this example, groupCount would return the number 4, showing that the pattern contains 4 capturing groups.</p><p>There is also a special group, group 0, which always represents the entire expression. This group is not included in the total reported by groupCount. Groups beginning with (? are pure, <em>non-capturing groups</em> that do not capture text and do not count towards the group total. (You&#x27;ll see examples of non-capturing groups later in the section <a href="https://docs.oracle.com/javase/tutorial/essential/regex/pattern.html">Methods of the Pattern Class</a>.)</p><p>It&#x27;s important to understand how groups are numbered because some Matcher methods accept an int specifying a particular group number as a parameter:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#start-int-">public int start(int group)</a>: Returns the start index of the subsequence captured by the given group during the previous match operation.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#end-int-">public int end (int group)</a>: Returns the index of the last character, plus one, of the subsequence captured by the given group during the previous match operation.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#group-int-">public String group (int group)</a>: Returns the input subsequence captured by the given group during the previous match operation.</li></ul><h3>17.6.2 Backreferences</h3><p>The section of the input string matching the capturing group(s) is saved in memory for later recall via <em>backreference</em>. A backreference is specified in the regular expression as a backslash (<!-- -->\<!-- -->) followed by a digit indicating the number of the group to be recalled. For example, the expression (<!-- -->\<!-- -->d<!-- -->\<!-- -->d) defines one capturing group matching two digits in a row, which can be recalled later in the expression via the backreference <!-- -->\<!-- -->1.</p><p>To match any 2 digits, followed by the exact same two digits, you would use (<!-- -->\<!-- -->d<!-- -->\<!-- -->d)<!-- -->\<!-- -->1 as the regular expression:</p><p>Enter your regex: (<!-- -->\<!-- -->d<!-- -->\<!-- -->d)<!-- -->\<!-- -->1</p><p>Enter input string to search: 1212</p><p>I found the text &quot;1212&quot; starting at index 0 and ending at index 4.</p><p>If you change the last two digits the match will fail:</p><p>Enter your regex: (<!-- -->\<!-- -->d<!-- -->\<!-- -->d)<!-- -->\<!-- -->1</p><p>Enter input string to search: 1234</p><p>No match found.</p><p>For nested capturing groups, backreferencing works in exactly the same way: Specify a backslash followed by the number of the group to be recalled.</p><h2>17.7 Boundary Matchers</h2><p>Until now, we&#x27;ve only been interested in whether or not a match is found <em>at some location</em> within a particular input string. We never cared about <em>where</em> in the string the match was taking place.</p><p>You can make your pattern matches more precise by specifying such information with <em>boundary matchers</em>. For example, maybe you&#x27;re interested in finding a particular word, but only if it appears at the beginning or end of a line. Or maybe you want to know if the match is taking place on a word boundary, or at the end of the previous match.</p><p>The following table lists and explains all the boundary matchers.</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Boundary Construct</strong></td><td><strong>Description</strong></td></tr><tr><td>\^</td><td>The beginning of a line</td></tr><tr><td>\$</td><td>The end of a line</td></tr><tr><td>\<!-- -->b</td><td>A word boundary</td></tr><tr><td>\<!-- -->B</td><td>A non-word boundary</td></tr><tr><td>\<!-- -->A</td><td>The beginning of the input</td></tr><tr><td>\<!-- -->G</td><td>The end of the previous match</td></tr><tr><td>\<!-- -->Z</td><td>The end of the input but for the final terminator, if any</td></tr><tr><td>\<!-- -->z</td><td>The end of the input</td></tr></tbody></table><p>The following examples demonstrate the use of boundary matchers \^ and \$. As noted above, \^ matches the beginning of a line, and \$ matches the end.</p><p>Enter your regex: \^dog\$</p><p>Enter input string to search: dog</p><p>I found the text &quot;dog&quot; starting at index 0 and ending at index 3.</p><p>Enter your regex: \^dog\$</p><p>Enter input string to search: dog</p><p>No match found.</p><p>Enter your regex: <!-- -->\<!-- -->s<!-- -->*<!-- -->dog\$</p><p>Enter input string to search: dog</p><p>I found the text &quot; dog&quot; starting at index 0 and ending at index 15.</p><p>Enter your regex: \^dog<!-- -->\<!-- -->w<!-- -->*</p><p>Enter input string to search: dogblahblah</p><p>I found the text &quot;dogblahblah&quot; starting at index 0 and ending at index 11.</p><p>The first example is successful because the pattern occupies the entire input string. The second example fails because the input string contains extra whitespace at the beginning. The third example specifies an expression that allows for unlimited white space, followed by &quot;dog&quot; on the end of the line. The fourth example requires &quot;dog&quot; to be present at the beginning of a line followed by an unlimited number of word characters.</p><p>To check if a pattern begins and ends on a word boundary (as opposed to a substring within a longer string), just use <!-- -->\<!-- -->b on either side; for example, <!-- -->\<!-- -->bdog<!-- -->\<!-- -->b</p><p>Enter your regex: <!-- -->\<!-- -->bdog<!-- -->\<!-- -->b</p><p>Enter input string to search: The dog plays in the yard.</p><p>I found the text &quot;dog&quot; starting at index 4 and ending at index 7.</p><p>Enter your regex: <!-- -->\<!-- -->bdog<!-- -->\<!-- -->b</p><p>Enter input string to search: The doggie plays in the yard.</p><p>No match found.</p><p>To match the expression on a non-word boundary, use <!-- -->\<!-- -->B instead:</p><p>Enter your regex: <!-- -->\<!-- -->bdog<!-- -->\<!-- -->B</p><p>Enter input string to search: The dog plays in the yard.</p><p>No match found.</p><p>Enter your regex: <!-- -->\<!-- -->bdog<!-- -->\<!-- -->B</p><p>Enter input string to search: The doggie plays in the yard.</p><p>I found the text &quot;dog&quot; starting at index 4 and ending at index 7.</p><p>To require the match to occur only at the end of the previous match, use <!-- -->\<!-- -->G:</p><p>Enter your regex: dog</p><p>Enter input string to search: dog dog</p><p>I found the text &quot;dog&quot; starting at index 0 and ending at index 3.</p><p>I found the text &quot;dog&quot; starting at index 4 and ending at index 7.</p><p>Enter your regex: <!-- -->\<!-- -->Gdog</p><p>Enter input string to search: dog dog</p><p>I found the text &quot;dog&quot; starting at index 0 and ending at index 3.</p><p>Here the second example finds only one match, because the second occurrence of &quot;dog&quot; does not start at the end of the previous match.</p><h2>17.8 Methods of the Pattern Class</h2><p>Until now, we&#x27;ve only used the test harness to create Pattern objects in their most basic form. This section explores advanced techniques such as creating patterns with flags and using embedded flag expressions. It also explores some additional useful methods that we haven&#x27;t yet discussed.</p><h3>17.8.1 Creating a Pattern with Flags</h3><p>The Pattern class defines an alternate compile method that accepts a set of flags affecting the way the pattern is matched. The flags parameter is a bit mask that may include any of the following public static fields:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#CANON_EQ">Pattern.CANON_EQ</a> Enables canonical equivalence. When this flag is specified, two characters will be considered to match if, and only if, their full canonical decompositions match. The expression &quot;a<!-- -->\<!-- -->u030A&quot;, for example, will match the string &quot;<!-- -->\<!-- -->u00E5&quot; when this flag is specified. By default, matching does not take canonical equivalence into account. Specifying this flag may impose a performance penalty.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#CASE_INSENSITIVE">Pattern.CASE_INSENSITIVE</a> Enables case-insensitive matching. By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched. Unicode-aware case-insensitive matching can be enabled by specifying the UNICODE_CASE flag in conjunction with this flag. Case-insensitive matching can also be enabled via the embedded flag expression (?i). Specifying this flag may impose a slight performance penalty.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#COMMENTS">Pattern.COMMENTS</a> Permits whitespace and comments in the pattern. In this mode, whitespace is ignored, and embedded comments starting with <!-- -->#<!-- --> are ignored until the end of a line. Comments mode can also be enabled via the embedded flag expression (?x).</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#DOTALL">Pattern.DOTALL</a> Enables dotall mode. In dotall mode, the expression . matches any character, including a line terminator. By default this expression does not match line terminators. Dotall mode can also be enabled via the embedded flag expression (?s). (The s is a mnemonic for &quot;single-line&quot; mode, which is what this is called in Perl.)</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#LITERAL">Pattern.LITERAL</a> Enables literal parsing of the pattern. When this flag is specified then the input string that specifies the pattern is treated as a sequence of literal characters. Metacharacters or escape sequences in the input sequence will be given no special meaning. The flags CASE_INSENSITIVE and UNICODE_CASE retain their impact on matching when used in conjunction with this flag. The other flags become superfluous. There is no embedded flag character for enabling literal parsing.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#MULTILINE">Pattern.MULTILINE</a> Enables multiline mode. In multiline mode the expressions \^ and \$ match just after or just before, respectively, a line terminator or the end of the input sequence. By default these expressions only match at the beginning and the end of the entire input sequence. Multiline mode can also be enabled via the embedded flag expression (?m).</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#UNICODE_CASE">Pattern.UNICODE_CASE</a> Enables Unicode-aware case folding. When this flag is specified then case-insensitive matching, when enabled by the CASE_INSENSITIVE flag, is done in a manner consistent with the Unicode Standard. By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched. Unicode-aware case folding can also be enabled via the embedded flag expression (?u). Specifying this flag may impose a performance penalty.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#UNIX_LINES">Pattern.UNIX_LINES</a> Enables UNIX lines mode. In this mode, only the &#x27;<!-- -->\<!-- -->n&#x27; line terminator is recognized in the behavior of ., \^, and \$. UNIX lines mode can also be enabled via the embedded flag expression (?d).</li></ul><p>In the following steps we will modify the test harness, <a href="https://docs.oracle.com/javase/tutorial/essential/regex/examples/RegexTestHarness.java">RegexTestHarness.java</a> to create a pattern with case-insensitive matching.</p><p>First, modify the code to invoke the alternate version of compile:</p><p>Pattern pattern =</p><p>Pattern.compile(console.readLine(&quot;%nEnter your regex: &quot;),</p><p>Pattern.CASE_INSENSITIVE);</p><p>Then compile and run the test harness to get the following results:</p><p>Enter your regex: dog</p><p>Enter input string to search: DoGDOg</p><p>I found the text &quot;DoG&quot; starting at index 0 and ending at index 3.</p><p>I found the text &quot;DOg&quot; starting at index 3 and ending at index 6.</p><p>As you can see, the string literal &quot;dog&quot; matches both occurences, regardless of case. To compile a pattern with multiple flags, separate the flags to be included using the bitwise OR operator &quot;<!-- -->|<!-- -->&quot;. For clarity, the following code samples hardcode the regular expression instead of reading it from the Console:</p><p>pattern = Pattern.compile(&quot;<!-- -->[az]<!-- -->\$&quot;, Pattern.MULTILINE <strong>|</strong> Pattern.UNIX_LINES);</p><p>You could also specify an int variable instead:</p><p>final int flags = Pattern.CASE_INSENSITIVE <!-- -->|<!-- --> Pattern.UNICODE_CASE;</p><p>Pattern pattern = Pattern.compile(&quot;aa&quot;, flags);</p><h3>17.8.2 Embedded Flag Expressions</h3><p>It&#x27;s also possible to enable various flags using <em>embedded flag expressions</em>. Embedded flag expressions are an alternative to the two-argument version of compile, and are specified in the regular expression itself. The following example uses the original test harness, <a href="https://docs.oracle.com/javase/tutorial/essential/regex/examples/RegexTestHarness.java">RegexTestHarness.java</a> with the embedded flag expression (?i) to enable case-insensitive matching.</p><p>Enter your regex: (?i)foo</p><p>Enter input string to search: FOOfooFoOfoO</p><p>I found the text &quot;FOO&quot; starting at index 0 and ending at index 3.</p><p>I found the text &quot;foo&quot; starting at index 3 and ending at index 6.</p><p>I found the text &quot;FoO&quot; starting at index 6 and ending at index 9.</p><p>I found the text &quot;foO&quot; starting at index 9 and ending at index 12.</p><p>Once again, all matches succeed regardless of case.</p><p>The embedded flag expressions that correspond to Pattern&#x27;s publicly accessible fields are presented in the following table:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Constant</strong></td><td><strong>Equivalent Embedded Flag Expression</strong></td></tr><tr><td>Pattern.CANON_EQ</td><td>None</td></tr><tr><td>Pattern.CASE_INSENSITIVE</td><td>(?i)</td></tr><tr><td>Pattern.COMMENTS</td><td>(?x)</td></tr><tr><td>Pattern.MULTILINE</td><td>(?m)</td></tr><tr><td>Pattern.DOTALL</td><td>(?s)</td></tr><tr><td>Pattern.LITERAL</td><td>None</td></tr><tr><td>Pattern.UNICODE_CASE</td><td>(?u)</td></tr><tr><td>Pattern.UNIX_LINES</td><td>(?d)</td></tr></tbody></table><h3>17.8.3 Using the matches(String,CharSequence) Method</h3><p>The Pattern class defines a convenient <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#matches-java.lang.String-java.lang.CharSequence-">matches</a> method that allows you to quickly check if a pattern is present in a given input string. As with all public static methods, you should invoke matches by its class name, such as Pattern.matches(&quot;<!-- -->\<!-- -->\<!-- -->d&quot;,&quot;1&quot;);. In this example, the method returns true, because the digit &quot;1&quot; matches the regular expression <!-- -->\<!-- -->d.</p><h3>17.8.4 Using the split(String) Method</h3><p>The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#split-java.lang.CharSequence-">split</a> method is a great tool for gathering the text that lies on either side of the pattern that&#x27;s been matched. As shown below in <a href="https://docs.oracle.com/javase/tutorial/essential/regex/examples/SplitDemo.java">SplitDemo.java</a>, the split method could extract the words &quot;one two three four five&quot; from the string &quot;one:two:three:four:five&quot;:</p><pre><code class="language-java">import java.util.regex.Pattern;

import java.util.regex.Matcher;

public class SplitDemo {

private static final String REGEX = &quot;:&quot;;

private static final String INPUT =

&quot;one:two:three:four:five&quot;;

public static void main(String[] args) {

Pattern p = Pattern.compile(REGEX);

String[] items = p.split(INPUT);

for(String s : items) {

System.out.println(s);

}

}

}
</code></pre><p>OUTPUT:</p><p>one</p><p>two</p><p>three</p><p>four</p><p>five</p><p>For simplicity, we&#x27;ve matched a string literal, the colon (:) instead of a complex regular expression. Since we&#x27;re still using Pattern and Matcher objects, you can use split to get the text that falls on either side of any regular expression. Here&#x27;s the same example, <a href="https://docs.oracle.com/javase/tutorial/essential/regex/examples/SplitDemo2.java">SplitDemo2.java</a>, modified to split on digits instead:</p><pre><code class="language-java">import java.util.regex.Pattern;

import java.util.regex.Matcher;

public class SplitDemo2 {

private static final String REGEX = &quot;\\\\d&quot;;

private static final String INPUT =

&quot;one9two4three7four1five&quot;;

public static void main(String[] args) {

Pattern p = Pattern.compile(REGEX);

String[] items = p.split(INPUT);

for(String s : items) {

System.out.println(s);

}

}

}
</code></pre><p>OUTPUT:</p><p>one</p><p>two</p><p>three</p><p>four</p><p>five</p><h3>17.8.5 Other Utility Methods</h3><p>You may find the following methods to be of some use as well:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#quote-java.lang.String-">public static String quote(String s)</a> Returns a literal pattern String for the specified String. This method produces a String that can be used to create a Pattern that would match String s as if it were a literal pattern. Metacharacters or escape sequences in the input sequence will be given no special meaning.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#toString--">public String toString()</a> Returns the String representation of this pattern. This is the regular expression from which this pattern was compiled.</li></ul><h3>17.8.6 Pattern Method Equivalents in java.lang.String</h3><p>Regular expression support also exists in java.lang.String through several methods that mimic the behavior of java.util.regex.Pattern. For convenience, key excerpts from their API are presented below.</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-">public boolean matches(String regex)</a>: Tells whether or not this string matches the given regular expression. An invocation of this method of the form <em>str</em>.matches(<em>regex</em>)yields exactly the same result as the expression Pattern.matches(<em>regex</em>, <em>str</em>).</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-int-">public String[] split(String regex, int limit)</a>: Splits this string around matches of the given regular expression. An invocation of this method of the form <em>str</em>.split(<em>regex</em>, <em>n</em>) yields the same result as the expression Pattern.compile(<em>regex</em>).split(<em>str</em>, <em>n</em>)</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-">public String[] split(String regex)</a>: Splits this string around matches of the given regular expression. This method works the same as if you invoked the two-argument split method with the given expression and a limit argument of zero. Trailing empty strings are not included in the resulting array.</li></ul><p>There is also a replace method, that replaces one CharSequence with another:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#replace-java.lang.CharSequence-java.lang.CharSequence-">public String replace(CharSequence target,CharSequence replacement)</a>: Replaces each substring of this string that matches the literal target sequence with the specified literal replacement sequence. The replacement proceeds from the beginning of the string to the end, for example, replacing &quot;aa&quot; with &quot;b&quot; in the string &quot;aaa&quot; will result in &quot;ba&quot; rather than &quot;ab&quot;.</li></ul><h2>17.9 Methods of the Matcher Class</h2><p>This section describes some additional useful methods of the Matcher class. For convenience, the methods listed below are grouped according to functionality.</p><h3>17.9.1 Index Methods</h3><p><em>Index methods</em> provide useful index values that show precisely where the match was found in the input string:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#start--">public int start()</a>: Returns the start index of the previous match.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#start-int-">public int start(int group)</a>: Returns the start index of the subsequence captured by the given group during the previous match operation.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#end--">public int end()</a>: Returns the offset after the last character matched.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#end-int-">public int end(int group)</a>: Returns the offset after the last character of the subsequence captured by the given group during the previous match operation.</li></ul><h3>17.9.2 Study Methods</h3><p><em>Study methods</em> review the input string and return a boolean indicating whether or not the pattern is found.</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#lookingAt--">public boolean lookingAt()</a>: Attempts to match the input sequence, starting at the beginning of the region, against the pattern.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#find--">public boolean find()</a>: Attempts to find the next subsequence of the input sequence that matches the pattern.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#find-int-">public boolean find(int start)</a>: Resets this matcher and then attempts to find the next subsequence of the input sequence that matches the pattern, starting at the specified index.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#matches--">public boolean matches()</a>: Attempts to match the entire region against the pattern.</li></ul><h3>17.9.3 Replacement Methods</h3><p><em>Replacement methods</em> are useful methods for replacing text in an input string.</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#appendReplacement-java.lang.StringBuffer-java.lang.String-">public Matcher appendReplacement(StringBuffer sb, String replacement)</a>: Implements a non-terminal append-and-replace step.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#appendTail-java.lang.StringBuffer-">public StringBuffer appendTail(StringBuffer sb)</a>: Implements a terminal append-and-replace step.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#replaceAll-java.lang.String-">public String replaceAll(String replacement)</a>: Replaces every subsequence of the input sequence that matches the pattern with the given replacement string.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#replaceFirst-java.lang.String-">public String replaceFirst(String replacement)</a>: Replaces the first subsequence of the input sequence that matches the pattern with the given replacement string.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#quoteReplacement-java.lang.String-">public static String quoteReplacement(String s)</a>: Returns a literal replacement String for the specified String. This method produces a String that will work as a literal replacement s in the appendReplacement method of the Matcher class. The String produced will match the sequence of characters in s treated as a literal sequence. Slashes (&#x27;<!-- -->\<!-- -->&#x27;) and dollar signs (&#x27;\$&#x27;) will be given no special meaning.</li></ul><h3>17.9.4 Using the start and end Methods</h3><p>Here&#x27;s an example, <a href="https://docs.oracle.com/javase/tutorial/essential/regex/examples/MatcherDemo.java">MatcherDemo.java</a>, that counts the number of times the word &quot;dog&quot; appears in the input string.</p><pre><code class="language-java">import java.util.regex.Pattern;

import java.util.regex.Matcher;

public class MatcherDemo {

private static final String REGEX =

&quot;\\\\bdog\\\\b&quot;;

private static final String INPUT =

&quot;dog dog dog doggie dogg&quot;;

public static void main(String[] args) {

Pattern p = Pattern.compile(REGEX);

// get a matcher object

Matcher m = p.matcher(INPUT);

int count = 0;

while(m.find()) {

count++;

System.out.println(&quot;Match number &quot;

+ count);

System.out.println(&quot;start(): &quot; + m.start());
System.out.println(&quot;end(): &quot; + m.end());

}

}

}
</code></pre><p>OUTPUT:</p><p>Match number 1</p><p>start(): 0</p><p>end(): 3</p><p>Match number 2</p><p>start(): 4</p><p>end(): 7</p><p>Match number 3</p><p>start(): 8</p><p>end(): 11</p><p>You can see that this example uses word boundaries to ensure that the letters &quot;d&quot; &quot;o&quot; &quot;g&quot; are not merely a substring in a longer word. It also gives some useful information about where in the input string the match has occurred. The start method returns the start index of the subsequence captured by the given group during the previous match operation, and end returns the index of the last character matched, plus one.</p><h3>17.9.5 Using the matches and lookingAt Methods</h3><p>The matches and lookingAt methods both attempt to match an input sequence against a pattern. The difference, however, is that matches requires the entire input sequence to be matched, while lookingAt does not. Both methods always start at the beginning of the input string. Here&#x27;s the full code, <a href="https://docs.oracle.com/javase/tutorial/essential/regex/examples/MatchesLooking.java">MatchesLooking.java</a>:</p><pre><code class="language-java">import java.util.regex.Pattern;

import java.util.regex.Matcher;

public class MatchesLooking {

private static final String REGEX = &quot;foo&quot;;

private static final String INPUT =

&quot;fooooooooooooooooo&quot;;

private static Pattern pattern;

private static Matcher matcher;

public static void main(String[] args) {

// Initialize

pattern = Pattern.compile(REGEX);

matcher = pattern.matcher(INPUT);

System.out.println(&quot;Current REGEX is: &quot;

+ REGEX);

System.out.println(&quot;Current INPUT is: &quot;

+ INPUT);

System.out.println(&quot;lookingAt(): &quot;

+ matcher.lookingAt());

System.out.println(&quot;matches(): &quot;

+ matcher.matches());

}

}
</code></pre><p>Current REGEX is: foo</p><p>Current INPUT is: fooooooooooooooooo</p><p>lookingAt(): true</p><p>matches(): false</p><h3>17.9.6 Using replaceFirst(String) and replaceAll(String)</h3><p>The replaceFirst and replaceAll methods replace text that matches a given regular expression. As their names indicate, replaceFirst replaces the first occurrence, and replaceAllreplaces all occurences. Here&#x27;s the <a href="https://docs.oracle.com/javase/tutorial/essential/regex/examples/ReplaceDemo.java">ReplaceDemo.java</a> code:</p><pre><code class="language-java">import java.util.regex.Pattern;

import java.util.regex.Matcher;

public class ReplaceDemo {

private static String REGEX = &quot;dog&quot;;

private static String INPUT =

&quot;The dog says meow. All dogs say meow.&quot;;

private static String REPLACE = &quot;cat&quot;;

public static void main(String[] args) {

Pattern p = Pattern.compile(REGEX);

// get a matcher object

Matcher m = p.matcher(INPUT);

INPUT = m.replaceAll(REPLACE);

System.out.println(INPUT);

}

}
</code></pre><p>OUTPUT: The cat says meow. All cats say meow.</p><p>In this first version, all occurrences of dog are replaced with cat. But why stop here? Rather than replace a simple literal like dog, you can replace text that matches <em>any</em> regular expression. The API for this method states that &quot;given the regular expression a<!-- -->*<!-- -->b, the input aabfooaabfooabfoob, and the replacement string -, an invocation of this method on a matcher for that expression would yield the string -foo-foo-foo-.&quot;</p><p>Here&#x27;s the <a href="https://docs.oracle.com/javase/tutorial/essential/regex/examples/ReplaceDemo2.java">ReplaceDemo2.java</a> code:</p><pre><code class="language-java">import java.util.regex.Pattern;

import java.util.regex.Matcher;

public class ReplaceDemo2 {

private static String REGEX = &quot;a\*b&quot;;

private static String INPUT =

&quot;aabfooaabfooabfoob&quot;;

private static String REPLACE = &quot;-&quot;;

public static void main(String[] args) {

Pattern p = Pattern.compile(REGEX);

// get a matcher object

Matcher m = p.matcher(INPUT);

INPUT = m.replaceAll(REPLACE);

System.out.println(INPUT);

}

}
</code></pre><p>OUTPUT: -foo-foo-foo-</p><p>To replace only the first occurrence of the pattern, simply call replaceFirst instead of replaceAll. It accepts the same parameter.</p><h3>17.9.7 Using appendReplacement(StringBuffer,String) and appendTail(StringBuffer)</h3><p>The Matcher class also provides appendReplacement and appendTail methods for text replacement. The following example, <a href="https://docs.oracle.com/javase/tutorial/essential/regex/examples/RegexDemo.java">RegexDemo.java</a>, uses these two methods to achieve the same effect as replaceAll.</p><pre><code class="language-java">import java.util.regex.Pattern;

import java.util.regex.Matcher;

public class RegexDemo {

private static String REGEX = &quot;a\*b&quot;;

private static String INPUT = &quot;aabfooaabfooabfoob&quot;;

private static String REPLACE = &quot;-&quot;;

public static void main(String[] args) {

Pattern p = Pattern.compile(REGEX);

Matcher m = p.matcher(INPUT); // get a matcher object

StringBuffer sb = new StringBuffer();

while(m.find()){

m.appendReplacement(sb,REPLACE);

}

m.appendTail(sb);

System.out.println(sb.toString());

}

}
</code></pre><p>OUTPUT: -foo-foo-foo-</p><h3>17.9.8 Matcher Method Equivalents in java.lang.String</h3><p>For convenience, the String class mimics a couple of Matcher methods as well:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#replaceFirst-java.lang.String-java.lang.String-">public String replaceFirst(String regex, String replacement)</a>: Replaces the first substring of this string that matches the given regular expression with the given replacement. An invocation of this method of the form <em>str</em>.replaceFirst(<em>regex</em>, <em>repl</em>) yields exactly the same result as the expression Pattern.compile(<em>regex</em>).matcher(<em>str</em>).replaceFirst(<em>repl</em>)</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#replaceAll-java.lang.String-java.lang.String-">public String replaceAll(String regex, String replacement)</a>: Replaces each substring of this string that matches the given regular expression with the given replacement. An invocation of this method of the form <em>str</em>.replaceAll(<em>regex</em>, <em>repl</em>) yields exactly the same result as the expression Pattern.compile(<em>regex</em>).matcher(<em>str</em>).replaceAll(<em>repl</em>)</li></ul><h2>17.10 Methods of the PatternSyntaxException Class</h2><p>A <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html">PatternSyntaxException</a> is an unchecked exception that indicates a syntax error in a regular expression pattern. The PatternSyntaxException class provides the following methods to help you determine what went wrong:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html#getDescription--">public String getDescription()</a>: Retrieves the description of the error.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html#getIndex--">public int getIndex()</a>: Retrieves the error index.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html#getPattern--">public String getPattern()</a>: Retrieves the erroneous regular expression pattern.</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html#getMessage--">public String getMessage()</a>: Returns a multi-line string containing the description of the syntax error and its index, the erroneous regular-expression pattern, and a visual indication of the error index within the pattern.</li></ul><p>The following source code, <a href="https://docs.oracle.com/javase/tutorial/essential/regex/examples/RegexTestHarness2.java">RegexTestHarness2.java</a>, updates our test harness to check for malformed regular expressions:</p><pre><code class="language-java">import java.io.Console;

import java.util.regex.Pattern;

import java.util.regex.Matcher;

import java.util.regex.PatternSyntaxException;

public class RegexTestHarness2 {

public static void main(String[] args){

Pattern pattern = null;

Matcher matcher = null;

Console console = System.console();

if (console == null) {

System.err.println(&quot;No console.&quot;);

System.exit(1);

}

while (true) {

try{

pattern =

Pattern.compile(console.readLine(&quot;%nEnter your regex: &quot;));

matcher =

pattern.matcher(console.readLine(&quot;Enter input string to search: &quot;));

}

catch(PatternSyntaxException pse){

console.format(&quot;There is a problem&quot; +

&quot; with the regular expression!%n&quot;);

console.format(&quot;The pattern in question is: %s%n&quot;,

pse.getPattern());

console.format(&quot;The description is: %s%n&quot;,

pse.getDescription());

console.format(&quot;The message is: %s%n&quot;,

pse.getMessage());

console.format(&quot;The index is: %s%n&quot;,

pse.getIndex());

System.exit(0);

}

boolean found = false;

while (matcher.find()) {

console.format(&quot;I found the text&quot; +

&quot; \\&quot;%s\\&quot; starting at &quot; +

&quot;index %d and ending at index %d.%n&quot;,

matcher.group(),

matcher.start(),

matcher.end());

found = true;

}

if(!found){

console.format(&quot;No match found.%n&quot;);

}

}

}

}
</code></pre><p>To run this test, enter ?i)foo as the regular expression. This mistake is a common scenario in which the programmer has forgotten the opening parenthesis in the embedded flag expression (?i). Doing so will produce the following results:</p><p>Enter your regex: ?i)</p><p>There is a problem with the regular expression!</p><p>The pattern in question is: ?i)</p><p>The description is: Dangling meta character &#x27;?&#x27;</p><p>The message is: Dangling meta character &#x27;?&#x27; near index 0</p><p>?i)</p><p>\^</p><p>The index is: 0</p><p>From this output, we can see that the syntax error is a dangling metacharacter (the question mark) at index 0. A missing opening parenthesis is the culprit.</p><h2>17.11 Unicode Support</h2><p>As of the JDK 7 release, Regular Expression pattern matching has expanded functionality to support Unicode 6.0.</p><ul><li><a href="https://docs.oracle.com/javase/tutorial/essential/regex/unicode.html#matchingSpecific">Matching a Specific Code Point</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/regex/unicode.html#properties">Unicode Character Properties</a></li></ul><h3>17.11.1 Matching a Specific Code Point</h3><p>You can match a specific Unicode code point using an escape sequence of the form <!-- -->\<!-- -->uFFFF, where FFFF is the hexidecimal value of the code point you want to match. For example, <!-- -->\<!-- -->u6771matches the Han character for east.</p><p>Alternatively, you can specify a code point using Perl-style hex notation, <!-- -->\<!-- -->x{<!-- -->.<!-- -->..}. For example:</p><p>String hexPattern = &quot;<!-- -->\<!-- -->x{&quot; + Integer.toHexString(codePoint) + &quot;}&quot;;</p><h3>17.11.2 Unicode Character Properties</h3><p>Each Unicode character, in addition to its value, has certain attributes, or properties. You can match a single character belonging to a particular category with the expression <!-- -->\<!-- -->p{<em>prop</em>}. You can match a single character <em>not</em> belonging to a particular category with the expression <!-- -->\<!-- -->P{<em>prop</em>}.</p><p>The three supported property types are scripts, blocks, and a &quot;general&quot; category.</p><h4>17.11.2.1 Scripts</h4><p>To determine if a code point belongs to a specific script, you can either use the script keyword, or the sc short form, for example, <!-- -->\<!-- -->p{script=Hiragana}. Alternatively, you can prefix the script name with the string Is, such as <!-- -->\<!-- -->p{IsHiragana}.</p><p>Valid script names supported by Pattern are those accepted by <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.UnicodeScript.html#forName-java.lang.String-">UnicodeScript.forName</a>.</p><h4>17.11.2.2 Blocks</h4><p>A block can be specified using the block keyword, or the blk short form, for example, <!-- -->\<!-- -->p{block=Mongolian}. Alternatively, you can prefix the block name with the string In, such as <!-- -->\<!-- -->p{InMongolian}.</p><p>Valid block names supported by Pattern are those accepted by <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.UnicodeBlock.html#forName-java.lang.String-">UnicodeBlock.forName</a>.</p><h4>17.11.2.3 General Category</h4><p>Categories can be specified with optional prefix Is. For example, IsL matches the category of Unicode letters. Categories can also be specified by using the general_category keyword, or the short form gc. For example, an uppercase letter can be matched using general_category=Lu or gc=Lu.</p><p>Supported categories are those of <a href="http://www.unicode.org/unicode/standard/standard.html">The Unicode Standard</a> in the version specified by the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html">Character</a> class.</p><h2>17.12 Additional Resources</h2><p>Now that you&#x27;ve completed this lesson on regular expressions, you&#x27;ll probably find that your main references will be the API documentation for the following classes: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">Pattern</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html">Matcher</a>, and<a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/PatternSyntaxException.html">PatternSyntaxException</a>.</p><p>For a more precise description of the behavior of regular expression constructs, we recommend reading the book <a href="http://www.amazon.com/exec/obidos/ASIN/0596002890/javasoftsunmicroA/"><em>Mastering Regular Expressions</em></a> by Jeffrey E. F. Friedl.</p></main></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/Java/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-eb0d07966faded618939.js"],"app":["/app-7f3ebe45394a9b8abff6.js"],"component---src-pages-index-js":["/component---src-pages-index-js-4c33a3bd3ae1b955fdc5.js"],"component---src-templates-blog-post-template-js":["/component---src-templates-blog-post-template-js-67eb11ed87f6378502cd.js"]};/*]]>*/</script><script src="/personal-blog/polyfill-eb0d07966faded618939.js" nomodule=""></script><script src="/personal-blog/component---src-templates-blog-post-template-js-67eb11ed87f6378502cd.js" async=""></script><script src="/personal-blog/commons-a0cdf84f460a5805ce1d.js" async=""></script><script src="/personal-blog/app-7f3ebe45394a9b8abff6.js" async=""></script><script src="/personal-blog/framework-078d6d248b03e80a6d05.js" async=""></script><script src="/personal-blog/webpack-runtime-e97e5792841cfd3b9064.js" async=""></script></body></html>