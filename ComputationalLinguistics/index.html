<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.30.3"/><style data-styled="" data-styled-version="5.2.1">.lbxEjx{width:800px;margin:0 auto;}/*!sc*/
data-styled.g1[id="Layout__AppStyles-sc-1q9f5ll-0"]{content:"lbxEjx,"}/*!sc*/
</style><link as="script" rel="preload" href="/webpack-runtime-1cc8a7a2a2463b047184.js"/><link as="script" rel="preload" href="/framework-078d6d248b03e80a6d05.js"/><link as="script" rel="preload" href="/app-34acdf110c4a267ec1db.js"/><link as="script" rel="preload" href="/commons-a0cdf84f460a5805ce1d.js"/><link as="script" rel="preload" href="/component---src-templates-blog-post-template-js-67eb11ed87f6378502cd.js"/><link as="fetch" rel="preload" href="/page-data\ComputationalLinguistics\page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/4080856488.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data\app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><main class="Layout__AppStyles-sc-1q9f5ll-0 lbxEjx"><a href="/"><h1>The Study Blog</h1><p>This is personal study blog</p></a><h1>Computational Lingusitics</h1><p>2021 January 17th</p><p>[]{#_heading=h.gjdgxs}Natural Language Processing</p><h1>[]{#_heading=h.30j0zll}Words</h1><p>The Brown corpus is a million-word collection of samples from 500 written English texts. How many words are in the following Brown sentence?</p><p>He stepped out into the hall, was delighted to encounter a water brother.</p><p>This sentence has 13 words if we don&#x27;t count punctuation marks as words, 15 if we count punctuation. Whether we treat period (&quot;.&quot;), comma (&quot;,&quot;), and so on as words depend on the task.</p><p><strong>Punctuation</strong> is critical for finding boundaries of things (commas, periods, colons) and for identifying some aspects of meaning (question marks, exclamation marks, quotation marks). For some tasks, like part-of-speech tagging or parsing or speech synthesis, we sometimes treat punctuation marks as if they were separate words.</p><p>An utterance is the spoken correlate of a sentence:</p><p>I do uh main- mainly business data processing</p><p>This <strong>utterance</strong> has two kinds of <strong>disfluencies</strong>. The broken-off word &quot;main-&quot; is a fragment. Words like &quot;uh&quot; and &quot;um&quot; are called <strong>fillers</strong> or filled pauses.</p><p>For a speech transcription system, we might want to eventually strip out the disfluencies. But we also sometimes keep disfluencies around. <strong>Disfluencies</strong> like uh or um are actually helpful in speech recognition in <strong>predicting the upcoming word</strong>, because they may signal that the speaker is restarting the clause or idea, and so for speech recognition they are treated as regular words. Because people use different disfluencies they can also be a cue to <strong>speaker identification</strong>.</p><p>What do you think they are? Are capitalized tokens like They and uncapitalized tokens like they the same word? These are lumped together in some tasks (speech recognition), while for part-of-speech or named-entity tagging, capitalization is a useful feature and is retained.</p><p>How about inflected forms like cats versus cat? These two words have the same lemma cat but are different wordforms. A <strong>lemma</strong> is a set of lexical forms having the same stem, the same major part-of-speech, and the same word sense. The <strong>wordform</strong> is the full inflected or derived form of the word.</p><p>How many words are there in English? To answer this question we need to distinguish two ways of talking about words. <strong>Types</strong> are the number of distinct words in a corpus; if the set of words in the vocabulary is V, the number of types is the word token vocabulary size <!-- -->|<!-- -->V<!-- -->|<!-- -->. <strong>Tokens</strong> are the total number N of running words. If we ignore punctuation, the following Brown sentence has 16 tokens and 14 types:</p><p>They picnicked by the pool, then lay back on the grass and looked at the stars.</p><hr/><p>  <strong>Corpus</strong>                            <strong>Tokens = N</strong>   <strong>Types = <!-- -->|<!-- -->V<!-- -->|</strong>
Shakespeare                           884 thousand     31 thousand
Brown corpus                          1 million        38 thousand
Switchboard telephone conversations   2.4 million      20 thousand
COCA                                  440 million      2 million
Google N-grams                        1 trillion       13 million</p><hr/><p>The larger the corpora we look at, the more word types we find, and in fact this relationship between the number of types <!-- -->|<!-- -->V<!-- -->|<!-- --> and number Herdan&#x27;s Law of tokens N is called Herdan&#x27;s Law (Herdan, 1960) or Heaps&#x27; Law (Heaps, 1978) after its discoverers (in linguistics and information retrieval respectively).</p><p>where k and β are positive constants, and .. The value of β depends on the corpus size and the genre.</p><p>Another measure of the number of words in the language is the number of lemmas instead of wordform types. Dictionaries can help in giving lemma counts; dictionary <strong>entries</strong> or <strong>boldface forms</strong> are a very rough upper bound on the number of lemmas (since some lemmas have multiple boldface forms). The 1989 edition of the Oxford English Dictionary had 615,000 entries.</p><h1>[]{#_heading=h.1fob9te}Corpora</h1><p><strong>Any particular piece of text that we study is produced by one or more specific speakers or writers, in a specific dialect of a specific language, at a specific time, in a specific place, for a specific function.</strong></p><p>It&#x27;s also quite common for speakers or writers to use multiple languages in a code switching single communicative act, a phenomenon called <strong>code switching.</strong></p><p><strong>Common dimensions of corpora to consider:</strong></p><ul><li><strong>Genre:</strong> fiction, legal, scientific,</li><li><strong>Demographic</strong> characteristics.</li><li><strong>Time:</strong> historical period languages change over time.</li></ul><h1>[]{#_heading=h.3znysh7}Text Normalization</h1><h2>[]{#_heading=h.2et92p0}Word Tokenization and Normalization</h2><p>Things to keep in mind for tokenization</p><ul><li><strong>Punctuations</strong> are considered as tokens but in cases where they are removed or used as a marker. We should be careful with texts like Ph.D., AT&amp;T, cap&#x27;n. prices (\$45.55), dates (01/02/06); URLs (<a href="http://www.stanford.edu">http://www.stanford.edu</a>), hashtags (<!-- -->#<!-- -->nlproc), or email addresses (<a href="mailto:someone@cs.colorado.edu">someone@cs.colorado.edu</a>)</li><li><strong>Clitic contractions</strong> must be expanded like what&#x27;re to the two tokens what are, and we&#x27;re to we are.</li><li>Tokenization is tied up with <strong>named entity recognition</strong> and must recognize, multiword expressions as single token like New York or rock &#x27;n&#x27; roll</li><li><strong>Tokens</strong> can be normalized like the USA and US or Uh-Huh and Uhhuh. Help in information retrieval and coherent information extraction.</li><li><strong>Case folding</strong>, everything is mapped to lower case for speech recognition and information retrieval(<strong>!!!</strong>), but in case of sentiment analysis, information extraction case is useful.</li></ul><p>Some languages like Chinese, Japanese do not use spaces to mark word boundaries; they require alternative segmentation methods, <strong>MaxMatch Algorithm</strong>, The maximum matching algorithm starts by pointing at the beginning of a string. It chooses the longest word in the dictionary that matches the input at the current position. The pointer is then advanced to the end of that word in the string. If no word matches, the pointer is instead advanced to one character (creating a one character word). Surprisingly works well for Chinese.</p><h2>[]{#_heading=h.tyjcwt}Lemmatization and Stemming</h2><p><strong>Lemmatization</strong> is the task of determining that two words have the same root, despite their surface differences. The words am, are, and is have the shared lemma be; the words dinner and dinners both have the lemma dinner.</p><p>Lemmatization involves <strong>morphological parsing</strong>. <strong>Morphology</strong> is the study of the way words are built up from smaller meaning-bearing units called morphemes. Two broad classes of morphemes can be distinguished: <strong>stems</strong>---the central morpheme of the word, supplying the main meaning--- and <strong>affixes</strong>---adding &quot;additional&quot; meanings of various kinds.</p><p><strong>Stemming</strong> is a naive version of morphological parsing.</p><p>Lemmatization and Stemming lose a lot of information that is very useful in human linguistic understanding.</p><h3>[]{#_heading=h.3dy6vkm}Porter Stemmer ()</h3><p>Porter Stemmer is based on a crude approach of chopping off the word final affixes and at each pass has rewrite rules to reduce to a lemma.</p><ul><li>ATIONAL → ATE (e.g., relational → relate)</li><li>ING → if stem contains vowel (e.g., motoring → motor)</li><li>SSES → SS (e.g., grasses → grass) lot many...</li></ul><h2>[]{#_heading=h.1t3h5sf}Byte Pair Encoding</h2><p>Byte-pair encoding is based on a method for text compression, but here we use it for tokenization instead. The intuition of the algorithm is to <strong>iteratively merge frequent pairs of characters</strong>.</p><p>By treating two similar words identically, <strong>these normalization methods help deal with the problem of unknown words, words that a system has not seen before</strong>.</p><p>Steps:</p><ul><li>Prepare an <strong>input dictionary of words</strong>, with a special character at the end to represent the word, <strong>with its frequency</strong>. Since it\&#x27;s a pairwise encoding make sure to have a <strong>unique delimiter between pairs</strong> Ex: \&#x27;l_o<!-- -->_<!-- -->w<!-- -->_<!-- -->\&lt;/w<!-- -->&gt;<!-- -->\&#x27;: 5 where word is low, \&lt;<!-- -->\<!-- -->w<!-- -->&gt;<!-- --> denotes end of word and <!-- -->_<!-- --> denotes unmerged byte pairs. 5 is its frequency.</li><li><strong>Create pairs</strong> of characters from the input dictionary with their frequency. Ex: (&#x27;w&#x27;, &#x27;\&lt;<!-- -->\<!-- -->w<!-- -->&gt;<!-- -->&#x27;): 5</li><li>Choose the <strong>pairs with maximum frequency and merge the input dictionary</strong>. Ex: &#x27;l_o<!-- -->_<!-- -->w\&lt;/w<!-- -->&gt;<!-- -->&#x27;: 5</li><li>The existing token pair (&#x27;w&#x27;,&#x27;\&lt;/w<!-- -->&gt;<!-- -->&#x27;): 5 get <strong>merged into new token &#x27;w\&lt;/w<!-- -->&gt;<!-- -->&#x27;: 5</strong></li><li>When the above steps are run iteratively, <strong>new tokens representing unique words are generated</strong> and <strong>unknown words are represented as multiple tokens</strong>.</li><li><strong>Number of iterative steps can be defined by the system</strong>. num_merges.</li></ul><pre><code class="language-python">**import** collections

**import** re

**def** get_stats**(**vocab**):**

pairs **=** collections**.**defaultdict**(int)**

**for** word**,** freq **in** vocab**.**items**():**

symbols **=** word**.**split**()**

**for** i **in** **range(len(**symbols**)** **-** 1**):**

pairs**\[**symbols**\[**i**\],** symbols**\[**i **+** 1**\]\]** **+=** freq

**return** pairs

**def** merge_vocab**(**pair**,** v_in**):**

v_out **=** **{}**

bigram **=** re**.**escape**(**\&#x27;\_\&#x27;**.**join**(**pair**))**

p **=** re**.compile(**r\&#x27;(?\&lt;!\\S)\&#x27; **+** bigram **+** r\&#x27;(?!\\S)\&#x27;**)**

**for** word **in** v_in**:**

w_out **=** p**.**sub**(**\&#x27;\&#x27;**.**join**(**pair**),** word**)**

v_out**\[**w_out**\]** **=** v_in**\[**word**\]**

**return** v_out

**def** get_tokens**(**vocab**):**

tokens **=** collections**.**defaultdict**(int)**

**for** word**,** freq **in** vocab**.**items**():**

word_tokens **=** word**.**split**()**

**for** token **in** word_tokens**:**

tokens**\[**token**\]** **+=** freq

**return** tokens

vocab **=** **{**\&#x27;l_o\_w\_\&lt;/w\&gt;\&#x27;**:** 5**,** \&#x27;l_o\_w_e\_s_t\_\&lt;/w\&gt;\&#x27;**:** 2**,**

\&#x27;n_e\_w_e\_r\_\&lt;/w\&gt;\&#x27;**:** 6**,** \&#x27;w_i\_d_e\_r\_\&lt;/w\&gt;\&#x27;**:** 3**,** \&#x27;n_e\_w\_\&lt;/w\&gt;\&#x27;**:** 2**}**

num_merges **=** 8

**for** i **in** **range(**num_merges**):**

pairs **=** get_stats**(**vocab**)**

best **=** **max(**pairs**,** key**=**pairs**.**get**)**

vocab **=** merge_vocab**(**best**,** vocab**)**

tokens = get_tokens(vocab)

**print(**best**)**

**print(**&#x27;New Tokens: {}&#x27;.format(tokens))
</code></pre><p>Of course in real algorithms BPE is run with many thousands of merges on a very large input dictionary. The result is that most words will be represented as full symbols, and <strong>only the very rare words (and unknown words) will have to be represented by their parts.</strong></p><h2>[]{#_heading=h.4d34og8}Sentence Segmentation</h2></main></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/ComputationalLinguistics/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-eb0d07966faded618939.js"],"app":["/app-34acdf110c4a267ec1db.js"],"component---src-pages-index-js":["/component---src-pages-index-js-4c33a3bd3ae1b955fdc5.js"],"component---src-templates-blog-post-template-js":["/component---src-templates-blog-post-template-js-67eb11ed87f6378502cd.js"]};/*]]>*/</script><script src="/polyfill-eb0d07966faded618939.js" nomodule=""></script><script src="/component---src-templates-blog-post-template-js-67eb11ed87f6378502cd.js" async=""></script><script src="/commons-a0cdf84f460a5805ce1d.js" async=""></script><script src="/app-34acdf110c4a267ec1db.js" async=""></script><script src="/framework-078d6d248b03e80a6d05.js" async=""></script><script src="/webpack-runtime-1cc8a7a2a2463b047184.js" async=""></script></body></html>